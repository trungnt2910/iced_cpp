/* 
SPDX-License-Identifier: MIT
Copyright (C) 2018-present iced project and contributors
 */

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once

#if defined(ENCODER) && defined(BLOCK_ENCODER) && defined(CODE_ASSEMBLER)
#include <cstdint>
#include <stdexcept>
#include <string>
#include "../Register.g.h"
#include "../RegisterExtensions.h"
#include "../ToString.h"
#include "AssemblerRegister.defs.g.h"
#include "AssemblerMemoryOperand.h"

namespace Iced::Intel {

	constexpr AssemblerRegister8::AssemblerRegister8(Register value) : Value(value) {
		if (!RegisterExtensions::IsGPR8(value))
			throw std::invalid_argument("Invalid register value. Must be a GPR8 register");
	}


	constexpr AssemblerRegister8::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegister8::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegister8::operator ==(const AssemblerRegister8& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegister8::operator !=(const AssemblerRegister8& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegister8::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegister8::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegister16::AssemblerRegister16(Register value) : Value(value) {
		if (!RegisterExtensions::IsGPR16(value))
			throw std::invalid_argument("Invalid register value. Must be a GPR16 register");
	}


	constexpr AssemblerRegister16::operator Register() const {
		return Value;
	}

	constexpr AssemblerMemoryOperand AssemblerRegister16::operator +(const AssemblerRegister16& right) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, right, 1, 0, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister16::operator +(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister16::operator -(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, -displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister16::operator *(std::int32_t scale) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, Register::None, *this, scale, 0, AssemblerOperandFlags::None);
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegister16::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegister16::operator ==(const AssemblerRegister16& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegister16::operator !=(const AssemblerRegister16& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegister16::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegister16::ToString() const {
		return Iced::Intel::ToString(Value);
	};

	/// <summary>
	/// Adds a 16-bit memory operand with an new base or index.
	/// </summary>
	/// <param name="left">The base or index.</param>
	/// <param name="right">The memory operand.</param>
	/// <returns></returns>
	constexpr AssemblerMemoryOperand operator + (AssemblerRegister16 left, AssemblerMemoryOperand right) {
		auto hasBase = right.Base != Register::None;
		return AssemblerMemoryOperand(right.Size, Register::None, hasBase ? right.Base : left.Value, hasBase ? left.Value : right.Index, right.Scale, right.Displacement, right.Flags);
	}

	constexpr AssemblerRegister32::AssemblerRegister32(Register value) : Value(value), Flags(AssemblerOperandFlags::None) {
		if (!RegisterExtensions::IsGPR32(value))
			throw std::invalid_argument("Invalid register value. Must be a GPR32 register");
	}


	constexpr AssemblerRegister32::AssemblerRegister32(Register value, AssemblerOperandFlags flags) : Value(value), Flags(flags) {
		if (!RegisterExtensions::IsGPR32(value))
			throw std::invalid_argument("Invalid register value. Must be a GPR32 register");
	}

	constexpr AssemblerRegister32 AssemblerRegister32::k1() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K1);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::k2() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K2);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::k3() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K3);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::k4() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K4);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::k5() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K5);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::k6() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K6);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::k7() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K7);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::z() const {
		return AssemblerRegister32(Value, Flags | AssemblerOperandFlags::Zeroing);
	}


	constexpr AssemblerRegister32 AssemblerRegister32::sae() const {
		return AssemblerRegister32(Value, Flags | AssemblerOperandFlags::SuppressAllExceptions);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::rn_sae() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundToNearest);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::rd_sae() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundDown);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::ru_sae() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundUp);
	}

	constexpr AssemblerRegister32 AssemblerRegister32::rz_sae() const {
		return AssemblerRegister32(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundTowardZero);
	}

	constexpr AssemblerRegister32::operator Register() const {
		return Value;
	}

	constexpr AssemblerMemoryOperand AssemblerRegister32::operator +(const AssemblerRegister32& right) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, right, 1, 0, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister32::operator +(const AssemblerRegisterXMM& right) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, right, 1, 0, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister32::operator +(const AssemblerRegisterYMM& right) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, right, 1, 0, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister32::operator +(const AssemblerRegisterZMM& right) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, right, 1, 0, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister32::operator +(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister32::operator -(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, -displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister32::operator *(std::int32_t scale) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, Register::None, *this, scale, 0, AssemblerOperandFlags::None);
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegister32::GetHashCode() const {
		return ((std::size_t)Value * 397) ^ (std::size_t)Flags;
	}

	constexpr bool AssemblerRegister32::operator ==(const AssemblerRegister32& right) const {
		return Value == right.Value && Flags == right.Flags;
	}

	constexpr bool AssemblerRegister32::operator !=(const AssemblerRegister32& right) const {
		return Value != right.Value || Flags != right.Flags;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegister32::ToString() const {
		return Iced::Intel::ToString(Value);
	};

	/// <summary>
	/// Adds a 32-bit memory operand with an new base or index.
	/// </summary>
	/// <param name="left">The base or index.</param>
	/// <param name="right">The memory operand.</param>
	/// <returns></returns>
	constexpr AssemblerMemoryOperand operator + (AssemblerRegister32 left, AssemblerMemoryOperand right) {
		auto hasBase = right.Base != Register::None;
		return AssemblerMemoryOperand(right.Size, Register::None, hasBase ? right.Base : left.Value, hasBase ? left.Value : right.Index, right.Scale, right.Displacement, right.Flags);
	}

	constexpr AssemblerRegister64::AssemblerRegister64(Register value) : Value(value), Flags(AssemblerOperandFlags::None) {
		if (!RegisterExtensions::IsGPR64(value))
			throw std::invalid_argument("Invalid register value. Must be a GPR64 register");
	}


	constexpr AssemblerRegister64::AssemblerRegister64(Register value, AssemblerOperandFlags flags) : Value(value), Flags(flags) {
		if (!RegisterExtensions::IsGPR64(value))
			throw std::invalid_argument("Invalid register value. Must be a GPR64 register");
	}

	constexpr AssemblerRegister64 AssemblerRegister64::k1() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K1);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::k2() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K2);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::k3() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K3);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::k4() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K4);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::k5() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K5);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::k6() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K6);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::k7() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K7);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::z() const {
		return AssemblerRegister64(Value, Flags | AssemblerOperandFlags::Zeroing);
	}


	constexpr AssemblerRegister64 AssemblerRegister64::sae() const {
		return AssemblerRegister64(Value, Flags | AssemblerOperandFlags::SuppressAllExceptions);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::rn_sae() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundToNearest);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::rd_sae() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundDown);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::ru_sae() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundUp);
	}

	constexpr AssemblerRegister64 AssemblerRegister64::rz_sae() const {
		return AssemblerRegister64(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundTowardZero);
	}

	constexpr AssemblerRegister64::operator Register() const {
		return Value;
	}

	constexpr AssemblerMemoryOperand AssemblerRegister64::operator +(const AssemblerRegister64& right) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, right, 1, 0, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister64::operator +(const AssemblerRegisterXMM& right) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, right, 1, 0, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister64::operator +(const AssemblerRegisterYMM& right) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, right, 1, 0, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister64::operator +(const AssemblerRegisterZMM& right) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, right, 1, 0, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister64::operator +(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister64::operator -(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, -displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegister64::operator *(std::int32_t scale) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, Register::None, *this, scale, 0, AssemblerOperandFlags::None);
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegister64::GetHashCode() const {
		return ((std::size_t)Value * 397) ^ (std::size_t)Flags;
	}

	constexpr bool AssemblerRegister64::operator ==(const AssemblerRegister64& right) const {
		return Value == right.Value && Flags == right.Flags;
	}

	constexpr bool AssemblerRegister64::operator !=(const AssemblerRegister64& right) const {
		return Value != right.Value || Flags != right.Flags;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegister64::ToString() const {
		return Iced::Intel::ToString(Value);
	};

	/// <summary>
	/// Adds a 64-bit memory operand with an new base or index.
	/// </summary>
	/// <param name="left">The base or index.</param>
	/// <param name="right">The memory operand.</param>
	/// <returns></returns>
	constexpr AssemblerMemoryOperand operator + (AssemblerRegister64 left, AssemblerMemoryOperand right) {
		auto hasBase = right.Base != Register::None;
		return AssemblerMemoryOperand(right.Size, Register::None, hasBase ? right.Base : left.Value, hasBase ? left.Value : right.Index, right.Scale, right.Displacement, right.Flags);
	}

	constexpr AssemblerRegisterSegment::AssemblerRegisterSegment(Register value) : Value(value) {
		if (!RegisterExtensions::IsSegmentRegister(value))
			throw std::invalid_argument("Invalid register value. Must be a SegmentRegister register");
	}


	constexpr AssemblerRegisterSegment::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterSegment::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegisterSegment::operator ==(const AssemblerRegisterSegment& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegisterSegment::operator !=(const AssemblerRegisterSegment& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegisterSegment::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterSegment::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterCR::AssemblerRegisterCR(Register value) : Value(value) {
		if (!RegisterExtensions::IsCR(value))
			throw std::invalid_argument("Invalid register value. Must be a CR register");
	}


	constexpr AssemblerRegisterCR::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterCR::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegisterCR::operator ==(const AssemblerRegisterCR& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegisterCR::operator !=(const AssemblerRegisterCR& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegisterCR::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterCR::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterDR::AssemblerRegisterDR(Register value) : Value(value) {
		if (!RegisterExtensions::IsDR(value))
			throw std::invalid_argument("Invalid register value. Must be a DR register");
	}


	constexpr AssemblerRegisterDR::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterDR::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegisterDR::operator ==(const AssemblerRegisterDR& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegisterDR::operator !=(const AssemblerRegisterDR& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegisterDR::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterDR::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterTR::AssemblerRegisterTR(Register value) : Value(value) {
		if (!RegisterExtensions::IsTR(value))
			throw std::invalid_argument("Invalid register value. Must be a TR register");
	}


	constexpr AssemblerRegisterTR::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterTR::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegisterTR::operator ==(const AssemblerRegisterTR& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegisterTR::operator !=(const AssemblerRegisterTR& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegisterTR::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterTR::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterST::AssemblerRegisterST(Register value) : Value(value) {
		if (!RegisterExtensions::IsST(value))
			throw std::invalid_argument("Invalid register value. Must be a ST register");
	}


	constexpr AssemblerRegisterST::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterST::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegisterST::operator ==(const AssemblerRegisterST& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegisterST::operator !=(const AssemblerRegisterST& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegisterST::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterST::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterMM::AssemblerRegisterMM(Register value) : Value(value) {
		if (!RegisterExtensions::IsMM(value))
			throw std::invalid_argument("Invalid register value. Must be a MM register");
	}


	constexpr AssemblerRegisterMM::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterMM::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegisterMM::operator ==(const AssemblerRegisterMM& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegisterMM::operator !=(const AssemblerRegisterMM& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegisterMM::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterMM::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterXMM::AssemblerRegisterXMM(Register value) : Value(value), Flags(AssemblerOperandFlags::None) {
		if (!RegisterExtensions::IsXMM(value))
			throw std::invalid_argument("Invalid register value. Must be a XMM register");
	}


	constexpr AssemblerRegisterXMM::AssemblerRegisterXMM(Register value, AssemblerOperandFlags flags) : Value(value), Flags(flags) {
		if (!RegisterExtensions::IsXMM(value))
			throw std::invalid_argument("Invalid register value. Must be a XMM register");
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::k1() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K1);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::k2() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K2);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::k3() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K3);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::k4() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K4);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::k5() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K5);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::k6() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K6);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::k7() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K7);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::z() const {
		return AssemblerRegisterXMM(Value, Flags | AssemblerOperandFlags::Zeroing);
	}


	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::sae() const {
		return AssemblerRegisterXMM(Value, Flags | AssemblerOperandFlags::SuppressAllExceptions);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::rn_sae() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundToNearest);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::rd_sae() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundDown);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::ru_sae() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundUp);
	}

	constexpr AssemblerRegisterXMM AssemblerRegisterXMM::rz_sae() const {
		return AssemblerRegisterXMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundTowardZero);
	}

	constexpr AssemblerRegisterXMM::operator Register() const {
		return Value;
	}

	constexpr AssemblerMemoryOperand AssemblerRegisterXMM::operator +(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegisterXMM::operator -(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, -displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegisterXMM::operator *(std::int32_t scale) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, Register::None, *this, scale, 0, AssemblerOperandFlags::None);
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterXMM::GetHashCode() const {
		return ((std::size_t)Value * 397) ^ (std::size_t)Flags;
	}

	constexpr bool AssemblerRegisterXMM::operator ==(const AssemblerRegisterXMM& right) const {
		return Value == right.Value && Flags == right.Flags;
	}

	constexpr bool AssemblerRegisterXMM::operator !=(const AssemblerRegisterXMM& right) const {
		return Value != right.Value || Flags != right.Flags;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterXMM::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterYMM::AssemblerRegisterYMM(Register value) : Value(value), Flags(AssemblerOperandFlags::None) {
		if (!RegisterExtensions::IsYMM(value))
			throw std::invalid_argument("Invalid register value. Must be a YMM register");
	}


	constexpr AssemblerRegisterYMM::AssemblerRegisterYMM(Register value, AssemblerOperandFlags flags) : Value(value), Flags(flags) {
		if (!RegisterExtensions::IsYMM(value))
			throw std::invalid_argument("Invalid register value. Must be a YMM register");
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::k1() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K1);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::k2() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K2);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::k3() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K3);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::k4() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K4);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::k5() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K5);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::k6() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K6);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::k7() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K7);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::z() const {
		return AssemblerRegisterYMM(Value, Flags | AssemblerOperandFlags::Zeroing);
	}


	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::sae() const {
		return AssemblerRegisterYMM(Value, Flags | AssemblerOperandFlags::SuppressAllExceptions);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::rn_sae() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundToNearest);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::rd_sae() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundDown);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::ru_sae() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundUp);
	}

	constexpr AssemblerRegisterYMM AssemblerRegisterYMM::rz_sae() const {
		return AssemblerRegisterYMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundTowardZero);
	}

	constexpr AssemblerRegisterYMM::operator Register() const {
		return Value;
	}

	constexpr AssemblerMemoryOperand AssemblerRegisterYMM::operator +(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegisterYMM::operator -(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, -displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegisterYMM::operator *(std::int32_t scale) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, Register::None, *this, scale, 0, AssemblerOperandFlags::None);
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterYMM::GetHashCode() const {
		return ((std::size_t)Value * 397) ^ (std::size_t)Flags;
	}

	constexpr bool AssemblerRegisterYMM::operator ==(const AssemblerRegisterYMM& right) const {
		return Value == right.Value && Flags == right.Flags;
	}

	constexpr bool AssemblerRegisterYMM::operator !=(const AssemblerRegisterYMM& right) const {
		return Value != right.Value || Flags != right.Flags;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterYMM::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterZMM::AssemblerRegisterZMM(Register value) : Value(value), Flags(AssemblerOperandFlags::None) {
		if (!RegisterExtensions::IsZMM(value))
			throw std::invalid_argument("Invalid register value. Must be a ZMM register");
	}


	constexpr AssemblerRegisterZMM::AssemblerRegisterZMM(Register value, AssemblerOperandFlags flags) : Value(value), Flags(flags) {
		if (!RegisterExtensions::IsZMM(value))
			throw std::invalid_argument("Invalid register value. Must be a ZMM register");
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::k1() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K1);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::k2() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K2);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::k3() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K3);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::k4() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K4);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::k5() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K5);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::k6() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K6);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::k7() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K7);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::z() const {
		return AssemblerRegisterZMM(Value, Flags | AssemblerOperandFlags::Zeroing);
	}


	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::sae() const {
		return AssemblerRegisterZMM(Value, Flags | AssemblerOperandFlags::SuppressAllExceptions);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::rn_sae() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundToNearest);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::rd_sae() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundDown);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::ru_sae() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundUp);
	}

	constexpr AssemblerRegisterZMM AssemblerRegisterZMM::rz_sae() const {
		return AssemblerRegisterZMM(Value, (Flags & ~AssemblerOperandFlags::RoundControlMask) | AssemblerOperandFlags::RoundTowardZero);
	}

	constexpr AssemblerRegisterZMM::operator Register() const {
		return Value;
	}

	constexpr AssemblerMemoryOperand AssemblerRegisterZMM::operator +(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegisterZMM::operator -(std::int64_t displacement) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, *this, Register::None, 1, -displacement, AssemblerOperandFlags::None);
	}

	constexpr AssemblerMemoryOperand AssemblerRegisterZMM::operator *(std::int32_t scale) const {
		return AssemblerMemoryOperand(MemoryOperandSize::None, Register::None, Register::None, *this, scale, 0, AssemblerOperandFlags::None);
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterZMM::GetHashCode() const {
		return ((std::size_t)Value * 397) ^ (std::size_t)Flags;
	}

	constexpr bool AssemblerRegisterZMM::operator ==(const AssemblerRegisterZMM& right) const {
		return Value == right.Value && Flags == right.Flags;
	}

	constexpr bool AssemblerRegisterZMM::operator !=(const AssemblerRegisterZMM& right) const {
		return Value != right.Value || Flags != right.Flags;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterZMM::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterTMM::AssemblerRegisterTMM(Register value) : Value(value) {
		if (!RegisterExtensions::IsTMM(value))
			throw std::invalid_argument("Invalid register value. Must be a TMM register");
	}


	constexpr AssemblerRegisterTMM::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterTMM::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegisterTMM::operator ==(const AssemblerRegisterTMM& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegisterTMM::operator !=(const AssemblerRegisterTMM& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegisterTMM::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterTMM::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterK::AssemblerRegisterK(Register value) : Value(value), Flags(AssemblerOperandFlags::None) {
		if (!RegisterExtensions::IsK(value))
			throw std::invalid_argument("Invalid register value. Must be a K register");
	}


	constexpr AssemblerRegisterK::AssemblerRegisterK(Register value, AssemblerOperandFlags flags) : Value(value), Flags(flags) {
		if (!RegisterExtensions::IsK(value))
			throw std::invalid_argument("Invalid register value. Must be a K register");
	}

	constexpr AssemblerRegisterK AssemblerRegisterK::k1() const {
		return AssemblerRegisterK(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K1);
	}

	constexpr AssemblerRegisterK AssemblerRegisterK::k2() const {
		return AssemblerRegisterK(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K2);
	}

	constexpr AssemblerRegisterK AssemblerRegisterK::k3() const {
		return AssemblerRegisterK(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K3);
	}

	constexpr AssemblerRegisterK AssemblerRegisterK::k4() const {
		return AssemblerRegisterK(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K4);
	}

	constexpr AssemblerRegisterK AssemblerRegisterK::k5() const {
		return AssemblerRegisterK(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K5);
	}

	constexpr AssemblerRegisterK AssemblerRegisterK::k6() const {
		return AssemblerRegisterK(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K6);
	}

	constexpr AssemblerRegisterK AssemblerRegisterK::k7() const {
		return AssemblerRegisterK(Value, (Flags & ~AssemblerOperandFlags::RegisterMask) | AssemblerOperandFlags::K7);
	}

	constexpr AssemblerRegisterK AssemblerRegisterK::z() const {
		return AssemblerRegisterK(Value, Flags | AssemblerOperandFlags::Zeroing);
	}


	constexpr AssemblerRegisterK::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterK::GetHashCode() const {
		return ((std::size_t)Value * 397) ^ (std::size_t)Flags;
	}

	constexpr bool AssemblerRegisterK::operator ==(const AssemblerRegisterK& right) const {
		return Value == right.Value && Flags == right.Flags;
	}

	constexpr bool AssemblerRegisterK::operator !=(const AssemblerRegisterK& right) const {
		return Value != right.Value || Flags != right.Flags;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterK::ToString() const {
		return Iced::Intel::ToString(Value);
	};


	constexpr AssemblerRegisterBND::AssemblerRegisterBND(Register value) : Value(value) {
		if (!RegisterExtensions::IsBND(value))
			throw std::invalid_argument("Invalid register value. Must be a BND register");
	}


	constexpr AssemblerRegisterBND::operator Register() const {
		return Value;
	}

	/// <inheritdoc />
	constexpr std::size_t AssemblerRegisterBND::GetHashCode() const {
		return (std::size_t)Value;
	}

	constexpr bool AssemblerRegisterBND::operator ==(const AssemblerRegisterBND& right) const {
		return Value == right.Value;
	}

	constexpr bool AssemblerRegisterBND::operator !=(const AssemblerRegisterBND& right) const {
		return Value != right.Value;
	}

	constexpr bool AssemblerRegisterBND::operator ==(const Register& right) const {
		return Value == right;
	}
	/// <inheritdoc />
	constexpr std::string AssemblerRegisterBND::ToString() const {
		return Iced::Intel::ToString(Value);
	};

}
#endif
