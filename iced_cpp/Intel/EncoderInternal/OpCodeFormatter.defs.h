// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

#if defined(ENCODER) && defined(OPCODE_INFO)
#pragma once

#include "../OpCodeOperandKind.g.h"
#include <string>
#include <cassert>

namespace Iced::Intel
{
	class OpCodeInfo;
}

namespace Iced::Intel::EncoderInternal
{
	// GENERATOR-BEGIN: LKind
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	enum class LKind : std::uint8_t {
		None ,
		/// <summary>.128, .256, .512</summary>
		L128 ,
		/// <summary>.L0, .L1</summary>
		L0 ,
		/// <summary>.LZ</summary>
		LZ ,
	};
	constexpr std::uint8_t operator+(const LKind& a, const LKind& b) { return ((std::uint8_t)a + (std::uint8_t)b); }
	constexpr std::uint8_t operator+(const LKind& a, const std::uint8_t& b) { return ((std::uint8_t)a + b); }
	constexpr std::uint8_t operator+(const std::uint8_t& a, const LKind& b) { return (a + (std::uint8_t)b); }
	constexpr std::uint8_t operator-(const LKind& a, const LKind& b) { return ((std::uint8_t)a - (std::uint8_t)b); }
	constexpr std::uint8_t operator-(const LKind& a, const std::uint8_t& b) { return ((std::uint8_t)a - b); }
	constexpr std::uint8_t operator-(const std::uint8_t& a, const LKind& b) { return (a - (std::uint8_t)b); }
	constexpr LKind operator++(LKind& a, int) { auto temp = a; a = LKind(a + 1); return temp; }
	constexpr LKind& operator++(LKind& a) { return a = LKind(a + 1); }
	constexpr LKind operator--(LKind& a, int) { auto temp = a; a = LKind(a - 1); return temp; }
	constexpr LKind& operator--(LKind& a) { return a = LKind(a - 1); }
	constexpr bool operator==(const LKind& a, const std::uint8_t& b) { return ((std::uint8_t)a == b); }
	constexpr bool operator==(const std::uint8_t& a, const LKind& b) { return (a == (std::uint8_t)b); }
	constexpr bool operator>=(const LKind& a, const std::uint8_t& b) { return ((std::uint8_t)a >= b); }
	constexpr bool operator>=(const std::uint8_t& a, const LKind& b) { return (a >= (std::uint8_t)b); }
	constexpr bool operator<=(const LKind& a, const std::uint8_t& b) { return ((std::uint8_t)a <= b); }
	constexpr bool operator<=(const std::uint8_t& a, const LKind& b) { return (a <= (std::uint8_t)b); }
	constexpr bool operator>(const LKind& a, const std::uint8_t& b) { return ((std::uint8_t)a > b); }
	constexpr bool operator>(const std::uint8_t& a, const LKind& b) { return (a > (std::uint8_t)b); }
	constexpr bool operator<(const LKind& a, const std::uint8_t& b) { return ((std::uint8_t)a < b); }
	constexpr bool operator<(const std::uint8_t& a, const LKind& b) { return (a < (std::uint8_t)b); }
	constexpr bool operator!=(const LKind& a, const std::uint8_t& b) { return ((std::uint8_t)a != b); }
	constexpr bool operator!=(const std::uint8_t& a, const LKind& b) { return (a != (std::uint8_t)b); }
	// GENERATOR-END: LKind

	class OpCodeFormatter
	{
	private:
		const bool isConstexprEval = false;
		bool ownsSb = false;
		const OpCodeInfo* opCode = nullptr;
		std::string* sb = nullptr;
		LKind lkind = static_cast<LKind>(0);
		bool hasModrmInfo = false;
	public:
		inline OpCodeFormatter(const OpCodeInfo& opCode, std::string& sb, LKind lkind, bool hasModrmInfo);
		constexpr OpCodeFormatter(const OpCodeInfo& opCode, LKind lkind, bool hasModrmInfo);
		constexpr ~OpCodeFormatter();
		constexpr std::string Format();
	private:
		constexpr OpCodeFormatter(const OpCodeInfo& opCode, LKind lkind, bool hasModrmInfo, bool constructString);
		constexpr void AppendHexByte(std::uint8_t value);
		constexpr void AppendOpCode(std::uint32_t value, std::int32_t valueLen, bool sep);
		constexpr void AppendTable(bool sep);
		constexpr bool HasModRM();
		constexpr bool HasVsib();
		constexpr OpCodeOperandKind GetOpCodeBitsOperand();
		constexpr bool TryGetModrmInfo(bool& isRegOnly, std::int32_t& rrr, std::int32_t& bbb);
		constexpr void AppendBits(const std::string& name, std::int32_t bits, std::int32_t numBits);
		constexpr void AppendRest();
		constexpr std::string Format_Legacy();
		constexpr std::string Format_3DNow();
		constexpr std::string FormatVecEncoding(const std::string& encodingName);

		constexpr OpCodeFormatter() = default;
	};
}
#endif
