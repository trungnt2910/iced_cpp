// C# helper headers
#include <csharp/classes.h>
#include <csharp/enum.h>
#include <csharp/interfaces.h>
#include <csharp/primitives.h>

// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#include "InstructionInfoFactory.h"
#include "Static.h"
#include "Iced.Intel.RegisterExtensions.h"
#include "OpKind.g.h"
#include "UsedMemory.h"
#include "UsedRegister.h"
#include "MvexRegMemConv.g.h"
#include "Iced.Intel.IcedConstants.h"

using namespace Iced::Intel::InstructionInfoInternal;

namespace Iced::Intel
{

	InstructionInfoFactory::InstructionInfoFactory()
	{
		info = InstructionInfo(true);
	}

	Register InstructionInfoFactory::GetXSP(CodeSize codeSize, std::uint64_t& xspMask, CodeSize& addressSize)
	{
		if (codeSize == CodeSize::Code64 || codeSize == CodeSize::Unknown)
		{
			xspMask = std::numeric_limits<std::uint64_t>::max();
			addressSize = CodeSize::Code64;
			return Register::RSP;
		}
		if (codeSize == CodeSize::Code32)
		{
			xspMask = std::numeric_limits<std::uint32_t>::max();
			addressSize = CodeSize::Code32;
			return Register::ESP;
		}
		assert(codeSize == CodeSize::Code16);
		xspMask = std::numeric_limits<std::uint16_t>::max();
		addressSize = CodeSize::Code16;
		return Register::SP;
	}

	void InstructionInfoFactory::AddImpliedAccesses(ImpliedAccess impliedAccess, Instruction const instruction, Flags flags)
	{
		assert(impliedAccess != ImpliedAccess::None);
		switch (impliedAccess)
		{
			// GENERATOR-BEGIN: ImpliedAccessHandler
			// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		case ImpliedAccess::None:
			break;
		case ImpliedAccess::Shift_Ib_MASK1FMOD9:
			break;
		case ImpliedAccess::Shift_Ib_MASK1FMOD11:
			break;
		case ImpliedAccess::Shift_Ib_MASK1F:
			break;
		case ImpliedAccess::Shift_Ib_MASK3F:
			break;
		case ImpliedAccess::Clear_rflags:
			CommandClearRflags(instruction, flags);
			break;
		case ImpliedAccess::t_push1x2:
			CommandPush(instruction, flags, 1, 2);
			break;
		case ImpliedAccess::t_push1x4:
			CommandPush(instruction, flags, 1, 4);
			break;
		case ImpliedAccess::t_pop1x2:
			CommandPop(instruction, flags, 1, 2);
			break;
		case ImpliedAccess::t_pop1x4:
			CommandPop(instruction, flags, 1, 4);
			break;
		case ImpliedAccess::t_RWal:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_push1x8:
			CommandPush(instruction, flags, 1, 8);
			break;
		case ImpliedAccess::t_pop1x8:
			CommandPop(instruction, flags, 1, 8);
			break;
		case ImpliedAccess::t_pusha2:
			CommandPusha(instruction, flags, 2);
			break;
		case ImpliedAccess::t_pusha4:
			CommandPusha(instruction, flags, 4);
			break;
		case ImpliedAccess::t_popa2:
			CommandPopa(instruction, flags, 2);
			break;
		case ImpliedAccess::t_popa4:
			CommandPopa(instruction, flags, 4);
			break;
		case ImpliedAccess::t_arpl:
			CommandArpl(instruction, flags);
			break;
		case ImpliedAccess::t_ins:
			CommandIns(instruction, flags);
			break;
		case ImpliedAccess::t_outs:
			CommandOuts(instruction, flags);
			break;
		case ImpliedAccess::t_lea:
			CommandLea(instruction, flags);
			break;
		case ImpliedAccess::t_gpr16:
			CommandLastGpr(instruction, flags, Register::AX);
			break;
		case ImpliedAccess::t_poprm2:
			CommandPopRm(instruction, flags, 2);
			break;
		case ImpliedAccess::t_poprm4:
			CommandPopRm(instruction, flags, 4);
			break;
		case ImpliedAccess::t_poprm8:
			CommandPopRm(instruction, flags, 8);
			break;
		case ImpliedAccess::t_Ral_Wah:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::Read);
				AddRegister(flags, Register::AH, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rax_Weax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_RWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rax_Wdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::DX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Wedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrax_Wrdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_push2x2:
			CommandPush(instruction, flags, 2, 2);
			break;
		case ImpliedAccess::t_push2x4:
			CommandPush(instruction, flags, 2, 4);
			break;
		case ImpliedAccess::t_Rah:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AH, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wah:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AH, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_movs:
			CommandMovs(instruction, flags);
			break;
		case ImpliedAccess::t_cmps:
			CommandCmps(instruction, flags);
			break;
		case ImpliedAccess::t_stos:
			CommandStos(instruction, flags);
			break;
		case ImpliedAccess::t_lods:
			CommandLods(instruction, flags);
			break;
		case ImpliedAccess::t_scas:
			CommandScas(instruction, flags);
			break;
		case ImpliedAccess::t_Wes:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ES, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wds:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::DS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_CWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
			}
			break;
		case ImpliedAccess::t_enter2:
			CommandEnter(instruction, flags, 2);
			break;
		case ImpliedAccess::t_enter4:
			CommandEnter(instruction, flags, 4);
			break;
		case ImpliedAccess::t_enter8:
			CommandEnter(instruction, flags, 8);
			break;
		case ImpliedAccess::t_leave2:
			CommandLeave(instruction, flags, 2);
			break;
		case ImpliedAccess::t_leave4:
			CommandLeave(instruction, flags, 4);
			break;
		case ImpliedAccess::t_leave8:
			CommandLeave(instruction, flags, 8);
			break;
		case ImpliedAccess::t_pop2x2:
			CommandPop(instruction, flags, 2, 2);
			break;
		case ImpliedAccess::t_pop2x4:
			CommandPop(instruction, flags, 2, 4);
			break;
		case ImpliedAccess::t_pop2x8:
			CommandPop(instruction, flags, 2, 8);
			break;
		case ImpliedAccess::b64_t_Wss_pop5x2_f_pop3x2:
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::SS, OpAccess::Write);
				}
				CommandPop(instruction, flags, 5, 2);
			}
			else
			{
				CommandPop(instruction, flags, 3, 2);
			}
			break;
		case ImpliedAccess::b64_t_Wss_pop5x4_f_pop3x4:
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::SS, OpAccess::Write);
				}
				CommandPop(instruction, flags, 5, 4);
			}
			else
			{
				CommandPop(instruction, flags, 3, 4);
			}
			break;
		case ImpliedAccess::t_Wss_pop5x8:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			CommandPop(instruction, flags, 5, 8);
			break;
		case ImpliedAccess::t_Ral_Wax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::Read);
				AddRegister(flags, Register::AX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wal:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_RWst0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rst0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rst0_RWst1:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::Read);
				AddRegister(flags, Register::ST1, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RCWst0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Rst1_RWst0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST1, OpAccess::Read);
				AddRegister(flags, Register::ST0, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rst0_Rst1:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::Read);
				AddRegister(flags, Register::ST1, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wst0TOst7_Wmm0TOmm7:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				for (auto reg = Register::ST0; reg <= Register::ST7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
				for (auto reg = Register::MM0; reg <= Register::MM7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_Rst0TOst7_Rmm0TOmm7:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				for (auto reg = Register::ST0; reg <= Register::ST7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Read);
				}
				for (auto reg = Register::MM0; reg <= Register::MM7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Read);
				}
			}
			break;
		case ImpliedAccess::t_RWcx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWecx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWrcx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rcx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrcx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wdx_RWax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::DX, OpAccess::Write);
				AddRegister(flags, Register::AX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Wedx_RWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EDX, OpAccess::Write);
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Wrdx_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RDX, OpAccess::Write);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWax_RWdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::ReadWrite);
				AddRegister(flags, Register::DX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWeax_RWedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
				AddRegister(flags, Register::EDX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWrax_RWrdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
				AddRegister(flags, Register::RDX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_push2x8:
			CommandPush(instruction, flags, 2, 8);
			break;
		case ImpliedAccess::t_Rcr0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CR0, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_RWcr0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CR0, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_gpr16_RWcr0:
			CommandLastGpr(instruction, flags, Register::AX);
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CR0, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RCWeax_b64_t_CRrcx_CRrdx_CRrbx_CWrcx_CWrdx_CWrbx_f_CRecx_CRedx_CRebx_CRds_CWecx_CWedx_CWebx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::RCX, OpAccess::CondRead);
					AddRegister(flags, Register::RDX, OpAccess::CondRead);
					AddRegister(flags, Register::RBX, OpAccess::CondRead);
					AddRegister(flags, Register::RCX, OpAccess::CondWrite);
					AddRegister(flags, Register::RDX, OpAccess::CondWrite);
					AddRegister(flags, Register::RBX, OpAccess::CondWrite);
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::ECX, OpAccess::CondRead);
					AddRegister(flags, Register::EDX, OpAccess::CondRead);
					AddRegister(flags, Register::EBX, OpAccess::CondRead);
					AddRegister(flags, Register::DS, OpAccess::CondRead);
					AddRegister(flags, Register::ECX, OpAccess::CondWrite);
					AddRegister(flags, Register::EDX, OpAccess::CondWrite);
					AddRegister(flags, Register::EBX, OpAccess::CondWrite);
				}
			}
			break;
		case ImpliedAccess::t_CWecx_CWedx_CWebx_RWeax_b64_t_CRrcx_CRrdx_CRrbx_f_CRecx_CRedx_CRebx_CRds:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::EBX, OpAccess::CondWrite);
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::RCX, OpAccess::CondRead);
					AddRegister(flags, Register::RDX, OpAccess::CondRead);
					AddRegister(flags, Register::RBX, OpAccess::CondRead);
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::ECX, OpAccess::CondRead);
					AddRegister(flags, Register::EDX, OpAccess::CondRead);
					AddRegister(flags, Register::EBX, OpAccess::CondRead);
					AddRegister(flags, Register::DS, OpAccess::CondRead);
				}
			}
			break;
		case ImpliedAccess::t_Rax_Recx_Redx_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Recx_Redx_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_Rrax_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Recx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Weax_Wedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Recx_Redx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rax_Wfs_Wgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Write);
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Wfs_Wgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Write);
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrax_Wfs_Wgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Write);
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rax_Rfs_Rgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Read);
				AddRegister(flags, Register::GS, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Rfs_Rgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Read);
				AddRegister(flags, Register::GS, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrax_Rfs_Rgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Read);
				AddRegister(flags, Register::GS, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Wcr0_Wdr6_Wdr7_WesTOgs_Wcr2TOcr4_Wdr0TOdr3_b64_t_WraxTOr15_f_WeaxTOedi:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::CR0, OpAccess::Write);
				AddRegister(flags, Register::DR6, OpAccess::Write);
				AddRegister(flags, Register::DR7, OpAccess::Write);
				for (auto reg = Register::ES; reg <= Register::GS; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
				for (auto reg = Register::CR2; reg <= Register::CR4; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
				for (auto reg = Register::DR0; reg <= Register::DR3; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::RAX; reg <= Register::R15; reg++)
					{
						AddRegister(flags, reg, OpAccess::Write);
					}
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::EAX; reg <= Register::EDI; reg++)
					{
						AddRegister(flags, reg, OpAccess::Write);
					}
				}
			}
			break;
		case ImpliedAccess::t_Rax_Recx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Rrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Weax_Wecx_Wedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Write);
				AddRegister(flags, Register::ECX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Recx_CRebx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
			}
			break;
		case ImpliedAccess::t_Rax_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrax_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wecx_b64_t_Wr11:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Write);
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::R11, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_Redi_Res:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EDI, OpAccess::Read);
				AddRegister(flags, Register::ES, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Wcs_Wss_b64_t_Rr11d:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::R11D, OpAccess::Read);
				}
			}
			break;
		case ImpliedAccess::t_Rr11d_Rrcx_Wcs_Wss:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::R11D, OpAccess::Read);
				AddRegister(flags, Register::RCX, OpAccess::Read);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Weax_Wedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wesp:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ESP, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_Wesp_Wcs_Wss:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::ESP, OpAccess::Write);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrcx_Rrdx_Wrsp_Wcs_Wss:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Read);
				AddRegister(flags, Register::RSP, OpAccess::Write);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_zrrm:
			CommandClearRegRegmem(instruction, flags);
			break;
		case ImpliedAccess::t_zrrrm:
			CommandClearRegRegRegmem(instruction, flags);
			break;
		case ImpliedAccess::b64_t_RWxmm0TOxmm15_f_RWxmm0TOxmm7:
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::XMM0; reg <= Register::XMM15; reg++)
					{
						AddRegister(flags, reg, OpAccess::ReadWrite);
					}
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::XMM0; reg <= Register::XMM7; reg++)
					{
						AddRegister(flags, reg, OpAccess::ReadWrite);
					}
				}
			}
			break;
		case ImpliedAccess::b64_t_Wzmm0TOzmm15_f_Wzmm0TOzmm7:
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::ZMM0; reg <= Register::ZMM15; reg++)
					{
						AddRegister(flags, reg, OpAccess::Write);
					}
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::ZMM0; reg <= Register::ZMM7; reg++)
					{
						AddRegister(flags, reg, OpAccess::Write);
					}
				}
			}
			break;
		case ImpliedAccess::t_CRecx_Wecx_Wedx_Webx_RWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::CondRead);
				AddRegister(flags, Register::ECX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Write);
				AddRegister(flags, Register::EBX, OpAccess::Write);
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRsi_CReax_CRes_CWeax_CWedx_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CReax_CResi_CRes_CWeax_CWedx_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CReax_CRrsi_CRes_CWeax_CWedx_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRsi_CRdi_CRes_CWsi_RCWax_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::AX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CResi_CRedi_CRes_CWesi_RCWeax_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRrsi_CRrdi_CRes_CWrsi_RCWrax_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Rcl_Rax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CL, OpAccess::Read);
				AddRegister(flags, Register::AX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rcl_Reax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CL, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_xstore2:
			CommandXstore(instruction, flags, 2);
			break;
		case ImpliedAccess::t_xstore4:
			CommandXstore(instruction, flags, 4);
			break;
		case ImpliedAccess::t_xstore8:
			CommandXstore(instruction, flags, 8);
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRdx_CRbx_CRsi_CRdi_CRes_CWsi_CWdi_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::DX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::BX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::DX, OpAccess::CondRead);
				AddRegister(flags, Register::BX, OpAccess::CondRead);
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::DI, OpAccess::CondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRedx_CRebx_CResi_CRedi_CRes_CWesi_CWedi_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::EDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EDX, OpAccess::CondRead);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EDI, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRrdx_CRrbx_CRrsi_CRrdi_CRes_CWrsi_CWrdi_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RDX, OpAccess::CondRead);
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RDI, OpAccess::CondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CRmem_CWmem_CWmem_CRax_CRdx_CRbx_CRsi_CRdi_CRes_CWsi_CWdi_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::AX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::BX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::AX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::CondRead);
				AddRegister(flags, Register::DX, OpAccess::CondRead);
				AddRegister(flags, Register::BX, OpAccess::CondRead);
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::DI, OpAccess::CondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CRmem_CWmem_CWmem_CReax_CRedx_CRebx_CResi_CRedi_CRes_CWesi_CWedi_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::EAX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EAX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				AddRegister(flags, Register::EDX, OpAccess::CondRead);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EDI, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CRmem_CWmem_CWmem_CRrax_CRrdx_CRrbx_CRrsi_CRrdi_CRes_CWrsi_CWrdi_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RAX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RAX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::CondRead);
				AddRegister(flags, Register::RDX, OpAccess::CondRead);
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RDI, OpAccess::CondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_RCWal:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_RCWax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_RCWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Reax_Redx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_gpr8:
			CommandLastGpr(instruction, flags, Register::AL);
			break;
		case ImpliedAccess::t_gpr32_Reax_Redx:
			CommandLastGpr(instruction, flags, Register::EAX);
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rmem_Rseg:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(GetSegDefaultDS(instruction), instruction.GetOp0Register(), Register::None, 1, 0x0, MemorySize::UInt8, OpAccess::Read, CodeSize::Unknown, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_RCWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Wss:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wfs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::FS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_CRecx_CRebx_RCWeax_RCWedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::CondRead);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::EDX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRrcx_CRrbx_RCWrax_RCWrdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::CondRead);
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::RDX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Wmem_RarDI_Rseg:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(GetSegDefaultDS(instruction), GetARDI(instruction), Register::None, 1, 0x0, instruction.GetMemorySize(), OpAccess::Write, CodeSize::Unknown, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, GetARDI(instruction), OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::XMM0, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Redx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wmem_Res:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, instruction.GetOp0Register(), Register::None, 1, 0x0, instruction.GetMemorySize(), OpAccess::Write, CodeSize::Unknown, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
			}
			break;
		case ImpliedAccess::t_Reax_Redx_Wxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::XMM0, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrax_Rrdx_Wxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Read);
				AddRegister(flags, Register::XMM0, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Redx_Wecx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrax_Rrdx_Wecx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::XMM0, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wecx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rmem_Rds:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::DS, instruction.GetOp0Register(), Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::Read, CodeSize::Unknown, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::DS, OpAccess::Read);
				}
			}
			break;
		case ImpliedAccess::t_Rrcx_Rrdx_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rmem_Rrcx_Rseg_RWrax:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(GetSegDefaultDS(instruction), Register::RCX, Register::None, 1, 0x0, MemorySize::UInt128, OpAccess::Read, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rax_Recx_Redx_Weax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_RWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rax_Recx_Redx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_Rrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wtmm0TOtmm7:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				for (auto reg = Register::TMM0; reg <= Register::TMM7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_Reax_Rebx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EBX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rebx_Weax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EBX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_emmiW:
			CommandEmmi(instruction, flags, OpAccess::Write);
			break;
		case ImpliedAccess::t_emmiRW:
			CommandEmmi(instruction, flags, OpAccess::ReadWrite);
			break;
		case ImpliedAccess::t_emmiR:
			CommandEmmi(instruction, flags, OpAccess::Read);
			break;
		case ImpliedAccess::t_CRrcx_CRrdx_CRr8_CRr9_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::CondRead);
				AddRegister(flags, Register::RDX, OpAccess::CondRead);
				AddRegister(flags, Register::R8, OpAccess::CondRead);
				AddRegister(flags, Register::R9, OpAccess::CondRead);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWxmm0TOxmm7:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				for (auto reg = Register::XMM0; reg <= Register::XMM7; reg++)
				{
					AddRegister(flags, reg, OpAccess::ReadWrite);
				}
			}
			break;
		case ImpliedAccess::t_Reax_Rxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::XMM0, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wxmm1_Wxmm2_RWxmm0_Wxmm4TOxmm6:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::XMM1, OpAccess::Write);
				AddRegister(flags, Register::XMM2, OpAccess::Write);
				AddRegister(flags, Register::XMM0, OpAccess::ReadWrite);
				for (auto reg = Register::XMM4; reg <= Register::XMM6; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_RWxmm0_RWxmm1_Wxmm2TOxmm6:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::XMM0, OpAccess::ReadWrite);
				AddRegister(flags, Register::XMM1, OpAccess::ReadWrite);
				for (auto reg = Register::XMM2; reg <= Register::XMM6; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_pop3x8:
			CommandPop(instruction, flags, 3, 8);
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRbx_CRsi_CRdi_CRes_CWsi_RCWax_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::BX, OpAccess::CondRead);
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::AX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRebx_CResi_CRedi_CRes_CWesi_RCWeax_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRrbx_CRrsi_CRrdi_CRes_CWrsi_RCWrax_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRax_CRdx_CRbx_CRsi_CRdi_CRes_CWsi_CWdi_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::DX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::BX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::CondRead);
				AddRegister(flags, Register::DX, OpAccess::CondRead);
				AddRegister(flags, Register::BX, OpAccess::CondRead);
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::DI, OpAccess::CondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CReax_CRedx_CRebx_CResi_CRedi_CRes_CWesi_CWedi_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::EDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				AddRegister(flags, Register::EDX, OpAccess::CondRead);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EDI, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRrax_CRrdx_CRrbx_CRrsi_CRrdi_CRes_CWrsi_CWrdi_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::CondRead);
				AddRegister(flags, Register::RDX, OpAccess::CondRead);
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RDI, OpAccess::CondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_gpr16_Wgs:
			CommandLastGpr(instruction, flags, Register::AX);
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wrsp_Wcs_Wss_pop5x8:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RSP, OpAccess::Write);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			CommandPop(instruction, flags, 5, 8);
			break;
		case ImpliedAccess::t_Wrsp_pop5x8:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RSP, OpAccess::Write);
			}
			CommandPop(instruction, flags, 5, 8);
			break;
		case ImpliedAccess::t_Reax_Recx_Wedx_Webx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Write);
				AddRegister(flags, Register::EBX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Recx_Redx_CRebx_CWedx_CWebx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::EBX, OpAccess::CondWrite);
			}
			break;
		case ImpliedAccess::t_memdisplm64:
			CommandMemDispl(flags, -64);
			break;
			// GENERATOR-END: ImpliedAccessHandler
		default:
			throw InvalidOperationException();
		}
	}

	Register InstructionInfoFactory::GetARDI(Instruction instruction)
	{
		auto switchTempVar_1 = instruction.GetOp0Kind();

		return (switchTempVar_1 == OpKind::MemorySegDI) ? Register::DI : (switchTempVar_1 == OpKind::MemorySegEDI) ? Register::EDI : Register::RDI;
	}

	Register InstructionInfoFactory::GetSegDefaultDS(Instruction instruction)
	{
		auto seg = instruction.GetSegmentPrefix();
		return seg == Register::None ? Register::DS : seg;
	}

	void InstructionInfoFactory::CommandPush(Instruction const instruction, Flags flags, std::int32_t count, std::uint32_t opSize)
	{
		assert(count > 0);
		std::uint64_t xspMask;
		Iced.Intel.CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), xspMask, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			MemorySize memSize;
			if (opSize == 8)
			{
				memSize = MemorySize::UInt64;
			}
			else if (opSize == 4)
			{
				memSize = MemorySize::UInt32;
			}
			else
			{
				assert(opSize == 2);
				memSize = MemorySize::UInt16;
			}
			std::uint64_t offset = 0ULL - opSize;
			for (std::int32_t i = 0; i < count; i++, offset -= opSize)
			{
				AddMemory(Register::SS, xsp, Register::None, 1, offset & xspMask, memSize, OpAccess::Write, addressSize, 0);
			}
		}
	}

	void InstructionInfoFactory::CommandPop(Instruction const instruction, Flags flags, std::int32_t count, std::uint32_t opSize)
	{
		assert(count > 0);
		Iced.Intel.CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), _, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			MemorySize memSize;
			if (opSize == 8)
			{
				memSize = MemorySize::UInt64;
			}
			else if (opSize == 4)
			{
				memSize = MemorySize::UInt32;
			}
			else
			{
				assert(opSize == 2);
				memSize = MemorySize::UInt16;
			}
			std::uint64_t offset = 0;
			for (std::int32_t i = 0; i < count; i++, offset += opSize)
			{
				AddMemory(Register::SS, xsp, Register::None, 1, offset, memSize, OpAccess::Read, addressSize, 0);
			}
		}
	}

	void InstructionInfoFactory::CommandPopRm(Instruction const instruction, Flags flags, std::uint32_t opSize)
	{
		Iced.Intel.CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), _, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			MemorySize memSize;
			if (opSize == 8)
			{
				memSize = MemorySize::UInt64;
			}
			else if (opSize == 4)
			{
				memSize = MemorySize::UInt32;
			}
			else
			{
				assert(opSize == 2);
				memSize = MemorySize::UInt16;
			}
			if (instruction.GetOp0Kind() == OpKind::Memory)
			{
				assert(info.usedMemoryLocations.ValidLength == 1);
				if (instruction.GetMemoryBase() == Register::RSP || instruction.GetMemoryBase() == Register::ESP)
				{
					//C# TO C++ CONVERTER TODO TASK: 'ref locals' are not converted by C# to C++ Converter:
					//ORIGINAL LINE: ref var mem = ref info.usedMemoryLocations.Array[0];
					auto mem = info.usedMemoryLocations.Array[0];
					auto displ = mem->Displacement + opSize;
					if (instruction.GetMemoryBase() == Register::ESP)
					{
						displ = static_cast<std::uint32_t>(displ);
					}
					info.usedMemoryLocations.Array[0] = UsedMemory(mem->Segment, mem->Base, mem->Index, mem->Scale, displ, mem->MemorySize, mem->Access, mem->AddressSize, mem->VsibSize);
				}
			}
			AddMemory(Register::SS, xsp, Register::None, 1, 0, memSize, OpAccess::Read, addressSize, 0);
		}
	}

	void InstructionInfoFactory::CommandPusha(Instruction const instruction, Flags flags, std::uint32_t opSize)
	{
		std::uint64_t xspMask;
		Iced.Intel.CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), xspMask, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		std::int64_t displ;
		MemorySize memSize;
		Register baseReg;
		if (opSize == 4)
		{
			displ = -4;
			memSize = MemorySize::UInt32;
			baseReg = Register::EAX;
		}
		else
		{
			assert(opSize == 2);
			displ = -2;
			memSize = MemorySize::UInt16;
			baseReg = Register::AX;
		}
		for (std::int32_t i = 0; i < 8; i++)
		{
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, baseReg + i, OpAccess::Read);
			}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, xsp, Register::None, 1, static_cast<std::uint64_t>((displ * (i + 1)) & xspMask), memSize, OpAccess::Write, addressSize, 0);
			}
		}
	}

	void InstructionInfoFactory::CommandPopa(Instruction const instruction, Flags flags, std::uint32_t opSize)
	{
		std::uint64_t xspMask;
		Iced.Intel.CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), xspMask, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		MemorySize memSize;
		Register baseReg;
		if (opSize == 4)
		{
			memSize = MemorySize::UInt32;
			baseReg = Register::EAX;
		}
		else
		{
			assert(opSize == 2);
			memSize = MemorySize::UInt16;
			baseReg = Register::AX;
		}
		for (std::int32_t i = 0; i < 8; i++)
		{
			// Ignore eSP
			if (i != 3)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, baseReg + 7 - i, OpAccess::Write);
				}
				if ((flags & Flags::NoMemoryUsage) == 0)
				{
					AddMemory(Register::SS, xsp, Register::None, 1, opSize * static_cast<std::uint32_t>(i & xspMask), memSize, OpAccess::Read, addressSize, 0);
				}
			}
		}
	}

	void InstructionInfoFactory::CommandIns(Instruction const instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rDI, rCX;
		switch (instruction.GetOp0Kind())
		{
		case OpKind::MemoryESDI:
			addressSize = CodeSize::Code16;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemoryESEDI:
			addressSize = CodeSize::Code32;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[0] = (byte)OpAccess.CondWrite;
				//	}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[1] = (byte)OpAccess.CondRead;
				//	}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondWrite, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(Register::DX, OpAccess::CondRead);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Write, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandOuts(Instruction const instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rSI, rCX;
		switch (instruction.GetOp1Kind())
		{
		case OpKind::MemorySegSI:
			addressSize = CodeSize::Code16;
			rSI = Register::SI;
			rCX = Register::CX;
			break;
		case OpKind::MemorySegESI:
			addressSize = CodeSize::Code32;
			rSI = Register::ESI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rSI = Register::RSI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[0] = (byte)OpAccess.CondRead;
				//	}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[1] = (byte)OpAccess.CondRead;
				//	}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(Register::DX, OpAccess::CondRead);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::Read);
				AddRegister(flags, rSI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandMovs(Instruction const instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rSI, rDI, rCX;
		switch (instruction.GetOp0Kind())
		{
		case OpKind::MemoryESDI:
			addressSize = CodeSize::Code16;
			rSI = Register::SI;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemoryESEDI:
			addressSize = CodeSize::Code32;
			rSI = Register::ESI;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rSI = Register::RSI;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[0] = (byte)OpAccess.CondWrite;
				//	}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[1] = (byte)OpAccess.CondRead;
				//	}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondWrite, addressSize, 0);
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Write, addressSize, 0);
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::Read);
				AddRegister(flags, rSI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandCmps(Instruction const instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rSI, rDI, rCX;
		switch (instruction.GetOp0Kind())
		{
		case OpKind::MemorySegSI:
			addressSize = CodeSize::Code16;
			rSI = Register::SI;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemorySegESI:
			addressSize = CodeSize::Code32;
			rSI = Register::ESI;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rSI = Register::RSI;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[0] = (byte)OpAccess.CondRead;
				//	}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[1] = (byte)OpAccess.CondRead;
				//	}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::Read);
				AddRegister(flags, rSI, OpAccess::ReadWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandStos(Instruction const instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rDI, rCX;
		switch (instruction.GetOp0Kind())
		{
		case OpKind::MemoryESDI:
			addressSize = CodeSize::Code16;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemoryESEDI:
			addressSize = CodeSize::Code32;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[0] = (byte)OpAccess.CondWrite;
				//	}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[1] = (byte)OpAccess.CondRead;
				//	}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondWrite, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(info.usedRegisters.Array[0]->Register, OpAccess::CondRead);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Write, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandLods(Instruction const instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rSI, rCX;
		switch (instruction.GetOp1Kind())
		{
		case OpKind::MemorySegSI:
			addressSize = CodeSize::Code16;
			rSI = Register::SI;
			rCX = Register::CX;
			break;
		case OpKind::MemorySegESI:
			addressSize = CodeSize::Code32;
			rSI = Register::ESI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rSI = Register::RSI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[0] = (byte)OpAccess.CondWrite;
				//	}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[1] = (byte)OpAccess.CondRead;
				//	}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(info.usedRegisters.Array[0]->Register, OpAccess::CondWrite);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::Read);
				AddRegister(flags, rSI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandScas(Instruction const instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rDI, rCX;
		switch (instruction.GetOp1Kind())
		{
		case OpKind::MemoryESDI:
			addressSize = CodeSize::Code16;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemoryESEDI:
			addressSize = CodeSize::Code32;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[0] = (byte)OpAccess.CondRead;
				//	}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
				//	{
				//		info.opAccesses[1] = (byte)OpAccess.CondRead;
				//	}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(info.usedRegisters.Array[0]->Register, OpAccess::CondRead);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandXstore(Instruction const instruction, Flags flags, std::uint32_t size)
	{
		CodeSize addressSize;
		Register rDI, rCX;
		switch (size)
		{
		case 2:
			addressSize = CodeSize::Code16;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case 4:
			addressSize = CodeSize::Code32;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondWrite, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 0);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondRead);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Write, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
				AddRegister(flags, Register::EAX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
		}
	}

	void InstructionInfoFactory::CommandEnter(Instruction const instruction, Flags flags, std::uint32_t opSize)
	{
		std::uint64_t xspMask;
		Iced.Intel.CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), xspMask, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		MemorySize memSize;
		Register rSP;
		if (opSize == 8)
		{
			memSize = MemorySize::UInt64;
			rSP = Register::RSP;
		}
		else if (opSize == 4)
		{
			memSize = MemorySize::UInt32;
			rSP = Register::ESP;
		}
		else
		{
			assert(opSize == 2);
			memSize = MemorySize::UInt16;
			rSP = Register::SP;
		}
		if (rSP != xsp && (flags & Flags::NoRegisterUsage) == 0)
		{
			AddRegister(flags, rSP, OpAccess::ReadWrite);
		}
		std::int32_t nestingLevel = instruction.GetImmediate8_2nd() & 0x1F;
		std::uint64_t xspOffset = 0;
		// push rBP
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			AddRegister(flags, rSP + 1, OpAccess::ReadWrite);
		}
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			AddMemory(Register::SS, xsp, Register::None, 1, (xspOffset -= opSize) & xspMask, memSize, OpAccess::Write, addressSize, 0);
		}
		if (nestingLevel != 0)
		{
			auto xbp = xsp + 1; // rBP immediately follows rSP
			std::uint64_t xbpOffset = 0;
			for (std::int32_t i = 1; i < nestingLevel; i++)
			{
				if (i == 1 && rSP + 1 != xbp && (flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, xbp, OpAccess::ReadWrite);
				}
				// push [xbp]
				if ((flags & Flags::NoMemoryUsage) == 0)
				{
					AddMemory(Register::SS, xbp, Register::None, 1, (xbpOffset -= opSize) & xspMask, memSize, OpAccess::Read, addressSize, 0);
					AddMemory(Register::SS, xsp, Register::None, 1, (xspOffset -= opSize) & xspMask, memSize, OpAccess::Write, addressSize, 0);
				}
			}
			// push frameTemp
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, xsp, Register::None, 1, (xspOffset -= opSize) & xspMask, memSize, OpAccess::Write, addressSize, 0);
			}
		}
	}

	void InstructionInfoFactory::CommandLeave(Instruction const instruction, Flags flags, std::uint32_t opSize)
	{
		Iced.Intel.CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), _, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::Write);
		}
		if (opSize == 8)
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, xsp + 1, Register::None, 1, 0, MemorySize::UInt64, OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if (xsp + 1 == Register::RBP)
				{
					AddRegister(flags, Register::RBP, OpAccess::ReadWrite);
				}
				else
				{
					AddRegister(flags, xsp + 1, OpAccess::Read);
					AddRegister(flags, Register::RBP, OpAccess::Write);
				}
			}
		}
		else if (opSize == 4)
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, xsp + 1, Register::None, 1, 0, MemorySize::UInt32, OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if (xsp + 1 == Register::EBP)
				{
					AddRegister(flags, Register::EBP, OpAccess::ReadWrite);
				}
				else
				{
					AddRegister(flags, xsp + 1, OpAccess::Read);
					AddRegister(flags, Register::EBP, OpAccess::Write);
				}
			}
		}
		else
		{
			assert(opSize == 2);
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, xsp + 1, Register::None, 1, 0, MemorySize::UInt16, OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if (xsp + 1 == Register::BP)
				{
					AddRegister(flags, Register::BP, OpAccess::ReadWrite);
				}
				else
				{
					AddRegister(flags, xsp + 1, OpAccess::Read);
					AddRegister(flags, Register::BP, OpAccess::Write);
				}
			}
		}
	}

	void InstructionInfoFactory::CommandClearRflags(Instruction const instruction, Flags flags)
	{
		if (instruction.GetOp0Register() != instruction.GetOp1Register())
		{
			return;
		}
		if (instruction.GetOp0Kind() != OpKind::Register || instruction.GetOp1Kind() != OpKind::Register)
		{
			return;
		}
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			//   {
			//	   info.opAccesses[0] = (byte)OpAccess.Write;
			//   }
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			//   {
			//	   info.opAccesses[1] = (byte)OpAccess.None;
			//   }
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength == 2 || info.usedRegisters.ValidLength == 3);
			info.usedRegisters.ValidLength = 0;
			AddRegister(flags, instruction.GetOp0Register(), OpAccess::Write);
		}
	}

	bool InstructionInfoFactory::IsClearInstr(Instruction const instruction)
	{
		switch (instruction.GetMvexRegMemConv())
		{
		case MvexRegMemConv::None:
		case MvexRegMemConv::RegSwizzleNone:
			return true;
		default:
			return false;
		}
	}

	void InstructionInfoFactory::CommandClearRegRegmem(Instruction const instruction, Flags flags)
	{
		if (instruction.GetOp0Register() != instruction.GetOp1Register())
		{
			return;
		}
		if (instruction.GetOp1Kind() != OpKind::Register)
		{
			return;
		}
		if (!IsClearInstr(instruction))
		{
			return;
		}
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			//   {
			//	   info.opAccesses[0] = (byte)OpAccess.Write;
			//   }
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			//   {
			//	   info.opAccesses[1] = (byte)OpAccess.None;
			//   }
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength == 2 || info.usedRegisters.ValidLength == 3);
			info.usedRegisters.Array[0] = UsedRegister(instruction.GetOp0Register(), OpAccess::Write);
			info.usedRegisters.ValidLength = 1;
		}
	}

	void InstructionInfoFactory::CommandClearRegRegRegmem(Instruction const instruction, Flags flags)
	{
		if (instruction.GetOp1Register() != instruction.GetOp2Register())
		{
			return;
		}
		if (instruction.GetOp2Kind() != OpKind::Register)
		{
			return;
		}
		if (!IsClearInstr(instruction))
		{
			return;
		}
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			//   {
			//	   info.opAccesses[1] = (byte)OpAccess.None;
			//   }
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			//   {
			//	   info.opAccesses[2] = (byte)OpAccess.None;
			//   }
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength == 3 || info.usedRegisters.ValidLength == 4);
			assert(info.usedRegisters.Array[info.usedRegisters.ValidLength - 2]->Register == instruction.GetOp1Register());
			assert(info.usedRegisters.Array[info.usedRegisters.ValidLength - 1]->Register == instruction.GetOp2Register());
			info.usedRegisters.ValidLength -= 2;
		}
	}

	void InstructionInfoFactory::CommandArpl(Instruction const instruction, Flags flags)
	{
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength != 0);
			// Skip memory operand, if any
			std::int32_t startIndex = instruction.GetOp0Kind() == OpKind::Register ? 0 : info.usedRegisters.ValidLength - 1;
			for (std::int32_t i = 0; i < info.usedRegisters.ValidLength; i++)
			{
				if (i < startIndex)
				{
					continue;
				}
				auto regInfo = info.usedRegisters.Array[i];
				std::int32_t index = TryGetGpr163264Index(regInfo->Register);
				if (index >= 4)
				{
					index += 4; // Skip AH, CH, DH, BH
				}
				if (index >= 0)
				{
					info.usedRegisters.Array[i] = UsedRegister(Register::AL + index, regInfo->Access);
				}
			}
		}
	}

	void InstructionInfoFactory::CommandLastGpr(Instruction const instruction, Flags flags, Register baseReg)
	{
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			std::int32_t opCount = instruction.GetOpCount();
			std::int32_t immCount = instruction.GetOpKind(opCount - 1) == OpKind::Immediate8 ? 1 : 0;
			constexpr std::int32_t N = 1;
			std::int32_t opIndex = opCount - N - immCount;
			if (instruction.GetOpKind(opIndex) == OpKind::Register)
			{
				assert(info.usedRegisters.ValidLength >= N);
				assert(info.usedRegisters.Array[info.usedRegisters.ValidLength - N]->Register == instruction.GetOpRegister(opIndex));
				assert(info.usedRegisters.Array[info.usedRegisters.ValidLength - N]->Access == OpAccess::Read);
				std::int32_t index = TryGetGpr163264Index(instruction.GetOpRegister(opIndex));
				if (index >= 4 && baseReg == Register::AL)
				{
					index += 4; // Skip AH, CH, DH, BH
				}
				if (index >= 0)
				{
					info.usedRegisters.Array[info.usedRegisters.ValidLength - N] = UsedRegister(baseReg + index, OpAccess::Read);
				}
			}
		}
	}

	void InstructionInfoFactory::CommandLea(Instruction const instruction, Flags flags)
	{
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength >= 1);
			assert(instruction.GetOp0Kind() == OpKind::Register);
			auto reg = instruction.GetOp0Register();
			// The memory operand's regs start at index 1
			for (std::int32_t i = 1; i < info.usedRegisters.ValidLength; i++)
			{
				auto regInfo = info.usedRegisters.Array[i];
				if (reg >= Register::EAX && reg <= Register::R15D)
				{
					if (regInfo->Register >= Register::RAX && regInfo->Register <= Register::R15)
					{
						auto memReg = regInfo->Register - Register::RAX + Register::EAX;
						info.usedRegisters.Array[i] = UsedRegister(memReg, regInfo->Access);
					}
				}
				else if (reg >= Register::AX && reg <= Register::R15W)
				{
					if (regInfo->Register >= Register::EAX && regInfo->Register <= Register::R15)
					{
						auto memReg = ((regInfo->Register - Register::EAX) & 0xF) + Register::AX;
						info.usedRegisters.Array[i] = UsedRegister(memReg, regInfo->Access);
					}
				}
				else
				{
					assert(reg >= Register::RAX && reg <= Register::R15);
					break;
				}
			}
		}
	}

	void InstructionInfoFactory::CommandEmmi(Instruction const instruction, Flags flags, OpAccess opAccess)
	{
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if (instruction.GetOp0Kind() == OpKind::Register)
			{
				auto reg = instruction.GetOp0Register();
				if (reg >= Register::MM0 && reg <= Register::MM7)
				{
					reg = ((reg - Register::MM0) ^ 1) + Register::MM0;
					AddRegister(flags, reg, opAccess);
				}
			}
		}
	}

	void InstructionInfoFactory::CommandMemDispl(Flags flags, std::int32_t extraDispl)
	{
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			if (info.usedMemoryLocations.ValidLength == 1)
			{
				//C# TO C++ CONVERTER TODO TASK: 'ref locals' are not converted by C# to C++ Converter:
				//ORIGINAL LINE: ref var mem = ref info.usedMemoryLocations.Array[0];
				auto mem = info.usedMemoryLocations.Array[0];
				auto switchTempVar_2 = mem->AddressSize;


				std::uint64_t mask = (switchTempVar_2 == CodeSize::Code16) ? std::numeric_limits<std::uint16_t>::max() : (switchTempVar_2 == CodeSize::Code32) ? std::numeric_limits<std::uint32_t>::max() : std::numeric_limits<std::uint64_t>::max();
				auto displ = (mem->Displacement + static_cast<std::uint64_t>(extraDispl)) & mask;
				info.usedMemoryLocations.Array[0] = UsedMemory(mem->Segment, mem->Base, mem->Index, mem->Scale, displ, mem->MemorySize, mem->Access, mem->AddressSize, mem->VsibSize);
			}
			else
			{
				assert(false);
			}
		}
	}

	std::int32_t InstructionInfoFactory::TryGetGpr163264Index(Register register_)
	{
		std::int32_t index;
		index = register_ - Register::EAX;
		if (static_cast<std::uint32_t>(index) <= 15)
		{
			return index;
		}
		index = register_ - Register::RAX;
		if (static_cast<std::uint32_t>(index) <= 15)
		{
			return index;
		}
		index = register_ - Register::AX;
		if (static_cast<std::uint32_t>(index) <= 15)
		{
			return index;
		}
		return -1;
	}

	void InstructionInfoFactory::AddMemory(Register segReg, Register baseReg, Register indexReg, std::int32_t scale, std::uint64_t displ, MemorySize memorySize, OpAccess access, CodeSize addressSize, std::int32_t vsibSize)
	{
		if (addressSize == CodeSize::Unknown)
		{
			auto reg = baseReg != Register::None ? baseReg : indexReg;
			if (Iced::Intel::RegisterExtensions::IsGPR64(reg))
			{
				addressSize = CodeSize::Code64;
			}
			else if (Iced::Intel::RegisterExtensions::IsGPR32(reg))
			{
				addressSize = CodeSize::Code32;
			}
			else if (Iced::Intel::RegisterExtensions::IsGPR16(reg))
			{
				addressSize = CodeSize::Code16;
			}
		}
		if (access != OpAccess::NoMemAccess)
		{
			std::int32_t arrayLength = info.usedMemoryLocations.Array.size();
			std::int32_t validLen = info.usedMemoryLocations.ValidLength;
			if (arrayLength == validLen)
			{
				if (arrayLength == 0)
				{
					info.usedMemoryLocations.Array = std::vector<UsedMemory>(defaultMemoryArrayCount);
				}
				else
				{
					Array::Resize(info.usedMemoryLocations.Array, arrayLength * 2);
				}
			}
			info.usedMemoryLocations.Array[validLen] = UsedMemory(segReg, baseReg, indexReg, scale, displ, memorySize, access, addressSize, vsibSize);
			info.usedMemoryLocations.ValidLength = validLen + 1;
		}
	}

	void InstructionInfoFactory::AddMemorySegmentRegister(Flags flags, Register seg, OpAccess access)
	{
		assert(Register::ES <= seg && seg <= Register::GS);
		// Ignore es,cs,ss,ds memory operand segment registers in 64-bit mode
		if ((flags & Flags::Is64Bit) == 0 || seg >= Register::FS)
		{
			AddRegister(flags, seg, access);
		}
	}

	void InstructionInfoFactory::AddRegister(Flags flags, Register reg, OpAccess access)
	{
		assert(((flags & Flags::NoRegisterUsage) == 0, "Caller should check flags before calling this method"));
		auto writeReg = reg;
		if ((flags & (Flags::Is64Bit | Flags::ZeroExtVecRegs)) != 0)
		{
			Static::Assert(OpAccess::Write + 1 == OpAccess::CondWrite ? 0 : -1);
			Static::Assert(OpAccess::Write + 2 == OpAccess::ReadWrite ? 0 : -1);
			Static::Assert(OpAccess::Write + 3 == OpAccess::ReadCondWrite ? 0 : -1);
			if (static_cast<std::uint32_t>(access - OpAccess::Write) <= 3)
			{
				std::int32_t index;
				Static::Assert(IcedConstants::VMM_first == Register::ZMM0 ? 0 : -1);
				if ((flags & Flags::Is64Bit) != 0 && static_cast<std::uint32_t>(index = reg - Register::EAX) <= (Register::R15D - Register::EAX))
				{
					writeReg = Register::RAX + index;
				}
				else if ((flags & Flags::ZeroExtVecRegs) != 0 && static_cast<std::uint32_t>(index = reg - Register::XMM0) <= IcedConstants::VMM_last - Register::XMM0)
				{
					writeReg = Register::ZMM0 + (index % IcedConstants::VMM_count);
				}
				if (access != OpAccess::ReadWrite && access != OpAccess::ReadCondWrite)
				{
					reg = writeReg;
				}
			}
		}
		auto array = info.usedRegisters.Array;
		std::int32_t validLen = info.usedRegisters.ValidLength;
		std::int32_t arrayLength = array.size();
		std::int32_t numRegs = writeReg == reg ? 1 : 2;
		if (validLen + numRegs > arrayLength)
		{
			if (arrayLength == 0)
			{
				// The code below that resizes the array assumes there's at least 2 new free elements, so the minimum array length is 2.
				assert(defaultRegisterArrayCount >= 2);
				info.usedRegisters.Array = array = std::vector<UsedRegister>(defaultRegisterArrayCount);
			}
			else
			{
				assert(arrayLength * 2 >= arrayLength + numRegs);
				Array::Resize(info.usedRegisters.Array, arrayLength * 2);
				array = info.usedRegisters.Array;
			}
		}
		if (writeReg == reg)
		{
			array[validLen] = UsedRegister(reg, access);
			info.usedRegisters.ValidLength = validLen + 1;
		}
		else
		{
			assert(access == OpAccess::ReadWrite || access == OpAccess::ReadCondWrite);
			array[validLen] = UsedRegister(reg, OpAccess::Read);
			validLen++;
			auto lastAccess = access == OpAccess::ReadWrite ? OpAccess::Write : OpAccess::CondWrite;
			array[validLen] = UsedRegister(writeReg, lastAccess);
			info.usedRegisters.ValidLength = validLen + 1;
		}
	}
}
