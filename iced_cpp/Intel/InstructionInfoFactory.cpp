// C# helper headers
#include <csharp/classes.h>
#include <csharp/enum.h>
#include <csharp/interfaces.h>
#include <csharp/primitives.h>

// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#include "InstructionInfoFactory.h"
#include "Static.h"
#include "RegisterExtensions.h"
#include "OpKind.g.h"
#include "UsedMemory.h"
#include "UsedRegister.h"
#include "MvexRegMemConv.g.h"
#include "Iced.Intel.IcedConstants.h"
#include "InstructionInfoInternal/InstrInfoTable.g.h"
#include "InstructionUtils.h"

using namespace Iced::Intel::InstructionInfoInternal;

namespace Iced::Intel
{

	InstructionInfoFactory::InstructionInfoFactory()
	{
		info = InstructionInfo(true);
	}

	Register InstructionInfoFactory::GetXSP(CodeSize codeSize, std::uint64_t& xspMask, CodeSize& addressSize)
	{
		if (codeSize == CodeSize::Code64 || codeSize == CodeSize::Unknown)
		{
			xspMask = std::numeric_limits<std::uint64_t>::max();
			addressSize = CodeSize::Code64;
			return Register::RSP;
		}
		if (codeSize == CodeSize::Code32)
		{
			xspMask = std::numeric_limits<std::uint32_t>::max();
			addressSize = CodeSize::Code32;
			return Register::ESP;
		}
		assert(codeSize == CodeSize::Code16);
		xspMask = std::numeric_limits<std::uint16_t>::max();
		addressSize = CodeSize::Code16;
		return Register::SP;
	}

	void InstructionInfoFactory::AddImpliedAccesses(ImpliedAccess impliedAccess, const Instruction& instruction, Flags flags)
	{
		assert(impliedAccess != ImpliedAccess::None);
		switch (impliedAccess)
		{
			// GENERATOR-BEGIN: ImpliedAccessHandler
			// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		case ImpliedAccess::None:
			break;
		case ImpliedAccess::Shift_Ib_MASK1FMOD9:
			break;
		case ImpliedAccess::Shift_Ib_MASK1FMOD11:
			break;
		case ImpliedAccess::Shift_Ib_MASK1F:
			break;
		case ImpliedAccess::Shift_Ib_MASK3F:
			break;
		case ImpliedAccess::Clear_rflags:
			CommandClearRflags(instruction, flags);
			break;
		case ImpliedAccess::t_push1x2:
			CommandPush(instruction, flags, 1, 2);
			break;
		case ImpliedAccess::t_push1x4:
			CommandPush(instruction, flags, 1, 4);
			break;
		case ImpliedAccess::t_pop1x2:
			CommandPop(instruction, flags, 1, 2);
			break;
		case ImpliedAccess::t_pop1x4:
			CommandPop(instruction, flags, 1, 4);
			break;
		case ImpliedAccess::t_RWal:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_push1x8:
			CommandPush(instruction, flags, 1, 8);
			break;
		case ImpliedAccess::t_pop1x8:
			CommandPop(instruction, flags, 1, 8);
			break;
		case ImpliedAccess::t_pusha2:
			CommandPusha(instruction, flags, 2);
			break;
		case ImpliedAccess::t_pusha4:
			CommandPusha(instruction, flags, 4);
			break;
		case ImpliedAccess::t_popa2:
			CommandPopa(instruction, flags, 2);
			break;
		case ImpliedAccess::t_popa4:
			CommandPopa(instruction, flags, 4);
			break;
		case ImpliedAccess::t_arpl:
			CommandArpl(instruction, flags);
			break;
		case ImpliedAccess::t_ins:
			CommandIns(instruction, flags);
			break;
		case ImpliedAccess::t_outs:
			CommandOuts(instruction, flags);
			break;
		case ImpliedAccess::t_lea:
			CommandLea(instruction, flags);
			break;
		case ImpliedAccess::t_gpr16:
			CommandLastGpr(instruction, flags, Register::AX);
			break;
		case ImpliedAccess::t_poprm2:
			CommandPopRm(instruction, flags, 2);
			break;
		case ImpliedAccess::t_poprm4:
			CommandPopRm(instruction, flags, 4);
			break;
		case ImpliedAccess::t_poprm8:
			CommandPopRm(instruction, flags, 8);
			break;
		case ImpliedAccess::t_Ral_Wah:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::Read);
				AddRegister(flags, Register::AH, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rax_Weax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_RWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rax_Wdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::DX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Wedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrax_Wrdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_push2x2:
			CommandPush(instruction, flags, 2, 2);
			break;
		case ImpliedAccess::t_push2x4:
			CommandPush(instruction, flags, 2, 4);
			break;
		case ImpliedAccess::t_Rah:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AH, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wah:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AH, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_movs:
			CommandMovs(instruction, flags);
			break;
		case ImpliedAccess::t_cmps:
			CommandCmps(instruction, flags);
			break;
		case ImpliedAccess::t_stos:
			CommandStos(instruction, flags);
			break;
		case ImpliedAccess::t_lods:
			CommandLods(instruction, flags);
			break;
		case ImpliedAccess::t_scas:
			CommandScas(instruction, flags);
			break;
		case ImpliedAccess::t_Wes:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ES, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wds:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::DS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_CWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
			}
			break;
		case ImpliedAccess::t_enter2:
			CommandEnter(instruction, flags, 2);
			break;
		case ImpliedAccess::t_enter4:
			CommandEnter(instruction, flags, 4);
			break;
		case ImpliedAccess::t_enter8:
			CommandEnter(instruction, flags, 8);
			break;
		case ImpliedAccess::t_leave2:
			CommandLeave(instruction, flags, 2);
			break;
		case ImpliedAccess::t_leave4:
			CommandLeave(instruction, flags, 4);
			break;
		case ImpliedAccess::t_leave8:
			CommandLeave(instruction, flags, 8);
			break;
		case ImpliedAccess::t_pop2x2:
			CommandPop(instruction, flags, 2, 2);
			break;
		case ImpliedAccess::t_pop2x4:
			CommandPop(instruction, flags, 2, 4);
			break;
		case ImpliedAccess::t_pop2x8:
			CommandPop(instruction, flags, 2, 8);
			break;
		case ImpliedAccess::b64_t_Wss_pop5x2_f_pop3x2:
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::SS, OpAccess::Write);
				}
				CommandPop(instruction, flags, 5, 2);
			}
			else
			{
				CommandPop(instruction, flags, 3, 2);
			}
			break;
		case ImpliedAccess::b64_t_Wss_pop5x4_f_pop3x4:
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::SS, OpAccess::Write);
				}
				CommandPop(instruction, flags, 5, 4);
			}
			else
			{
				CommandPop(instruction, flags, 3, 4);
			}
			break;
		case ImpliedAccess::t_Wss_pop5x8:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			CommandPop(instruction, flags, 5, 8);
			break;
		case ImpliedAccess::t_Ral_Wax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::Read);
				AddRegister(flags, Register::AX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wal:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_RWst0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rst0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rst0_RWst1:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::Read);
				AddRegister(flags, Register::ST1, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RCWst0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Rst1_RWst0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST1, OpAccess::Read);
				AddRegister(flags, Register::ST0, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rst0_Rst1:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ST0, OpAccess::Read);
				AddRegister(flags, Register::ST1, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wst0TOst7_Wmm0TOmm7:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				for (auto reg = Register::ST0; reg <= Register::ST7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
				for (auto reg = Register::MM0; reg <= Register::MM7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_Rst0TOst7_Rmm0TOmm7:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				for (auto reg = Register::ST0; reg <= Register::ST7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Read);
				}
				for (auto reg = Register::MM0; reg <= Register::MM7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Read);
				}
			}
			break;
		case ImpliedAccess::t_RWcx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWecx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWrcx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rcx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrcx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wdx_RWax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::DX, OpAccess::Write);
				AddRegister(flags, Register::AX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Wedx_RWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EDX, OpAccess::Write);
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Wrdx_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RDX, OpAccess::Write);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWax_RWdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::ReadWrite);
				AddRegister(flags, Register::DX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWeax_RWedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
				AddRegister(flags, Register::EDX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWrax_RWrdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
				AddRegister(flags, Register::RDX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_push2x8:
			CommandPush(instruction, flags, 2, 8);
			break;
		case ImpliedAccess::t_Rcr0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CR0, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_RWcr0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CR0, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_gpr16_RWcr0:
			CommandLastGpr(instruction, flags, Register::AX);
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CR0, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RCWeax_b64_t_CRrcx_CRrdx_CRrbx_CWrcx_CWrdx_CWrbx_f_CRecx_CRedx_CRebx_CRds_CWecx_CWedx_CWebx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::RCX, OpAccess::CondRead);
					AddRegister(flags, Register::RDX, OpAccess::CondRead);
					AddRegister(flags, Register::RBX, OpAccess::CondRead);
					AddRegister(flags, Register::RCX, OpAccess::CondWrite);
					AddRegister(flags, Register::RDX, OpAccess::CondWrite);
					AddRegister(flags, Register::RBX, OpAccess::CondWrite);
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::ECX, OpAccess::CondRead);
					AddRegister(flags, Register::EDX, OpAccess::CondRead);
					AddRegister(flags, Register::EBX, OpAccess::CondRead);
					AddRegister(flags, Register::DS, OpAccess::CondRead);
					AddRegister(flags, Register::ECX, OpAccess::CondWrite);
					AddRegister(flags, Register::EDX, OpAccess::CondWrite);
					AddRegister(flags, Register::EBX, OpAccess::CondWrite);
				}
			}
			break;
		case ImpliedAccess::t_CWecx_CWedx_CWebx_RWeax_b64_t_CRrcx_CRrdx_CRrbx_f_CRecx_CRedx_CRebx_CRds:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::EBX, OpAccess::CondWrite);
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::RCX, OpAccess::CondRead);
					AddRegister(flags, Register::RDX, OpAccess::CondRead);
					AddRegister(flags, Register::RBX, OpAccess::CondRead);
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::ECX, OpAccess::CondRead);
					AddRegister(flags, Register::EDX, OpAccess::CondRead);
					AddRegister(flags, Register::EBX, OpAccess::CondRead);
					AddRegister(flags, Register::DS, OpAccess::CondRead);
				}
			}
			break;
		case ImpliedAccess::t_Rax_Recx_Redx_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Recx_Redx_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_Rrax_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Recx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Weax_Wedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Recx_Redx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rax_Wfs_Wgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Write);
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Wfs_Wgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Write);
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrax_Wfs_Wgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Write);
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rax_Rfs_Rgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Read);
				AddRegister(flags, Register::GS, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Rfs_Rgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Read);
				AddRegister(flags, Register::GS, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrax_Rfs_Rgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::FS, OpAccess::Read);
				AddRegister(flags, Register::GS, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Wcr0_Wdr6_Wdr7_WesTOgs_Wcr2TOcr4_Wdr0TOdr3_b64_t_WraxTOr15_f_WeaxTOedi:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::CR0, OpAccess::Write);
				AddRegister(flags, Register::DR6, OpAccess::Write);
				AddRegister(flags, Register::DR7, OpAccess::Write);
				for (auto reg = Register::ES; reg <= Register::GS; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
				for (auto reg = Register::CR2; reg <= Register::CR4; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
				for (auto reg = Register::DR0; reg <= Register::DR3; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::RAX; reg <= Register::R15; reg++)
					{
						AddRegister(flags, reg, OpAccess::Write);
					}
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::EAX; reg <= Register::EDI; reg++)
					{
						AddRegister(flags, reg, OpAccess::Write);
					}
				}
			}
			break;
		case ImpliedAccess::t_Rax_Recx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Rrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Weax_Wecx_Wedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Write);
				AddRegister(flags, Register::ECX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Recx_CRebx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
			}
			break;
		case ImpliedAccess::t_Rax_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Reax_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrax_Rseg:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wecx_b64_t_Wr11:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Write);
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::R11, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_Redi_Res:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EDI, OpAccess::Read);
				AddRegister(flags, Register::ES, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Wcs_Wss_b64_t_Rr11d:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, Register::R11D, OpAccess::Read);
				}
			}
			break;
		case ImpliedAccess::t_Rr11d_Rrcx_Wcs_Wss:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::R11D, OpAccess::Read);
				AddRegister(flags, Register::RCX, OpAccess::Read);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Weax_Wedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wesp:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ESP, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_Wesp_Wcs_Wss:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::ESP, OpAccess::Write);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrcx_Rrdx_Wrsp_Wcs_Wss:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Read);
				AddRegister(flags, Register::RSP, OpAccess::Write);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_zrrm:
			CommandClearRegRegmem(instruction, flags);
			break;
		case ImpliedAccess::t_zrrrm:
			CommandClearRegRegRegmem(instruction, flags);
			break;
		case ImpliedAccess::b64_t_RWxmm0TOxmm15_f_RWxmm0TOxmm7:
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::XMM0; reg <= Register::XMM15; reg++)
					{
						AddRegister(flags, reg, OpAccess::ReadWrite);
					}
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::XMM0; reg <= Register::XMM7; reg++)
					{
						AddRegister(flags, reg, OpAccess::ReadWrite);
					}
				}
			}
			break;
		case ImpliedAccess::b64_t_Wzmm0TOzmm15_f_Wzmm0TOzmm7:
			if ((flags & Flags::Is64Bit) != 0)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::ZMM0; reg <= Register::ZMM15; reg++)
					{
						AddRegister(flags, reg, OpAccess::Write);
					}
				}
			}
			else
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					for (auto reg = Register::ZMM0; reg <= Register::ZMM7; reg++)
					{
						AddRegister(flags, reg, OpAccess::Write);
					}
				}
			}
			break;
		case ImpliedAccess::t_CRecx_Wecx_Wedx_Webx_RWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::CondRead);
				AddRegister(flags, Register::ECX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Write);
				AddRegister(flags, Register::EBX, OpAccess::Write);
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRsi_CReax_CRes_CWeax_CWedx_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CReax_CResi_CRes_CWeax_CWedx_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CReax_CRrsi_CRes_CWeax_CWedx_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRsi_CRdi_CRes_CWsi_RCWax_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::AX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CResi_CRedi_CRes_CWesi_RCWeax_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRrsi_CRrdi_CRes_CWrsi_RCWrax_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Rcl_Rax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CL, OpAccess::Read);
				AddRegister(flags, Register::AX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rcl_Reax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::CL, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_xstore2:
			CommandXstore(instruction, flags, 2);
			break;
		case ImpliedAccess::t_xstore4:
			CommandXstore(instruction, flags, 4);
			break;
		case ImpliedAccess::t_xstore8:
			CommandXstore(instruction, flags, 8);
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRdx_CRbx_CRsi_CRdi_CRes_CWsi_CWdi_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::DX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::BX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::DX, OpAccess::CondRead);
				AddRegister(flags, Register::BX, OpAccess::CondRead);
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::DI, OpAccess::CondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRedx_CRebx_CResi_CRedi_CRes_CWesi_CWedi_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::EDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EDX, OpAccess::CondRead);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EDI, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRrdx_CRrbx_CRrsi_CRrdi_CRes_CWrsi_CWrdi_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RDX, OpAccess::CondRead);
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RDI, OpAccess::CondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CRmem_CWmem_CWmem_CRax_CRdx_CRbx_CRsi_CRdi_CRes_CWsi_CWdi_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::AX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::BX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::AX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::CondRead);
				AddRegister(flags, Register::DX, OpAccess::CondRead);
				AddRegister(flags, Register::BX, OpAccess::CondRead);
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::DI, OpAccess::CondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CRmem_CWmem_CWmem_CReax_CRedx_CRebx_CResi_CRedi_CRes_CWesi_CWedi_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::EAX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EAX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				AddRegister(flags, Register::EDX, OpAccess::CondRead);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EDI, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CRmem_CWmem_CWmem_CRrax_CRrdx_CRrbx_CRrsi_CRrdi_CRes_CWrsi_CWrdi_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RAX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RAX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::CondRead);
				AddRegister(flags, Register::RDX, OpAccess::CondRead);
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RDI, OpAccess::CondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_RCWal:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AL, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_RCWax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_RCWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Reax_Redx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_gpr8:
			CommandLastGpr(instruction, flags, Register::AL);
			break;
		case ImpliedAccess::t_gpr32_Reax_Redx:
			CommandLastGpr(instruction, flags, Register::EAX);
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rmem_Rseg:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(GetSegDefaultDS(instruction), instruction.GetOp0Register(), Register::None, 1, 0x0, MemorySize::UInt8, OpAccess::Read, CodeSize::Unknown, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_RCWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Wss:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wfs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::FS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wgs:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_CRecx_CRebx_RCWeax_RCWedx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::CondRead);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::EDX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRrcx_CRrbx_RCWrax_RCWrdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::CondRead);
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::RDX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_Wmem_RarDI_Rseg:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(GetSegDefaultDS(instruction), GetARDI(instruction), Register::None, 1, 0x0, instruction.GetMemorySize(), OpAccess::Write, CodeSize::Unknown, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, GetARDI(instruction), OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::XMM0, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Redx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rrdx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wmem_Res:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, instruction.GetOp0Register(), Register::None, 1, 0x0, instruction.GetMemorySize(), OpAccess::Write, CodeSize::Unknown, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
			}
			break;
		case ImpliedAccess::t_Reax_Redx_Wxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::XMM0, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrax_Rrdx_Wxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Read);
				AddRegister(flags, Register::XMM0, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Redx_Wecx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rrax_Rrdx_Wecx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::XMM0, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wecx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Rmem_Rds:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::DS, instruction.GetOp0Register(), Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::Read, CodeSize::Unknown, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::DS, OpAccess::Read);
				}
			}
			break;
		case ImpliedAccess::t_Rrcx_Rrdx_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::Read);
				AddRegister(flags, Register::RDX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rmem_Rrcx_Rseg_RWrax:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(GetSegDefaultDS(instruction), Register::RCX, Register::None, 1, 0x0, MemorySize::UInt128, OpAccess::Read, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::Read);
				AddMemorySegmentRegister(flags, GetSegDefaultDS(instruction), OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rax_Recx_Redx_Weax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_RWeax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_Rax_Recx_Redx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Recx_Redx_Rrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::RAX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wtmm0TOtmm7:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				for (auto reg = Register::TMM0; reg <= Register::TMM7; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_Reax_Rebx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::EBX, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Rebx_Weax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EBX, OpAccess::Read);
				AddRegister(flags, Register::EAX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_emmiW:
			CommandEmmi(instruction, flags, OpAccess::Write);
			break;
		case ImpliedAccess::t_emmiRW:
			CommandEmmi(instruction, flags, OpAccess::ReadWrite);
			break;
		case ImpliedAccess::t_emmiR:
			CommandEmmi(instruction, flags, OpAccess::Read);
			break;
		case ImpliedAccess::t_CRrcx_CRrdx_CRr8_CRr9_RWrax:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RCX, OpAccess::CondRead);
				AddRegister(flags, Register::RDX, OpAccess::CondRead);
				AddRegister(flags, Register::R8, OpAccess::CondRead);
				AddRegister(flags, Register::R9, OpAccess::CondRead);
				AddRegister(flags, Register::RAX, OpAccess::ReadWrite);
			}
			break;
		case ImpliedAccess::t_RWxmm0TOxmm7:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				for (auto reg = Register::XMM0; reg <= Register::XMM7; reg++)
				{
					AddRegister(flags, reg, OpAccess::ReadWrite);
				}
			}
			break;
		case ImpliedAccess::t_Reax_Rxmm0:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::XMM0, OpAccess::Read);
			}
			break;
		case ImpliedAccess::t_Wxmm1_Wxmm2_RWxmm0_Wxmm4TOxmm6:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::XMM1, OpAccess::Write);
				AddRegister(flags, Register::XMM2, OpAccess::Write);
				AddRegister(flags, Register::XMM0, OpAccess::ReadWrite);
				for (auto reg = Register::XMM4; reg <= Register::XMM6; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_RWxmm0_RWxmm1_Wxmm2TOxmm6:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::XMM0, OpAccess::ReadWrite);
				AddRegister(flags, Register::XMM1, OpAccess::ReadWrite);
				for (auto reg = Register::XMM2; reg <= Register::XMM6; reg++)
				{
					AddRegister(flags, reg, OpAccess::Write);
				}
			}
			break;
		case ImpliedAccess::t_pop3x8:
			CommandPop(instruction, flags, 3, 8);
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRbx_CRsi_CRdi_CRes_CWsi_RCWax_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::BX, OpAccess::CondRead);
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::AX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRebx_CResi_CRedi_CRes_CWesi_RCWeax_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CWmem_CRrbx_CRrsi_CRrdi_CRes_CWrsi_RCWrax_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RAX, OpAccess::ReadCondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRax_CRdx_CRbx_CRsi_CRdi_CRes_CWsi_CWdi_RCWcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::DX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::BX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::SI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code16, 0);
				AddMemory(Register::ES, Register::DI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code16, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::AX, OpAccess::CondRead);
				AddRegister(flags, Register::DX, OpAccess::CondRead);
				AddRegister(flags, Register::BX, OpAccess::CondRead);
				AddRegister(flags, Register::SI, OpAccess::CondRead);
				AddRegister(flags, Register::DI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::SI, OpAccess::CondWrite);
				AddRegister(flags, Register::DI, OpAccess::CondWrite);
				AddRegister(flags, Register::CX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CReax_CRedx_CRebx_CResi_CRedi_CRes_CWesi_CWedi_RCWecx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::EDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::ESI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code32, 0);
				AddMemory(Register::ES, Register::EDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code32, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::CondRead);
				AddRegister(flags, Register::EDX, OpAccess::CondRead);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::ESI, OpAccess::CondRead);
				AddRegister(flags, Register::EDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::ESI, OpAccess::CondWrite);
				AddRegister(flags, Register::EDI, OpAccess::CondWrite);
				AddRegister(flags, Register::ECX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_CRmem_CRmem_CRmem_CWmem_CRrax_CRrdx_CRrbx_CRrsi_CRrdi_CRes_CWrsi_CWrdi_RCWrcx:
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, Register::RDX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RBX, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RSI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondRead, CodeSize::Code64, 0);
				AddMemory(Register::ES, Register::RDI, Register::None, 1, 0x0, MemorySize::Unknown, OpAccess::CondWrite, CodeSize::Code64, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RAX, OpAccess::CondRead);
				AddRegister(flags, Register::RDX, OpAccess::CondRead);
				AddRegister(flags, Register::RBX, OpAccess::CondRead);
				AddRegister(flags, Register::RSI, OpAccess::CondRead);
				AddRegister(flags, Register::RDI, OpAccess::CondRead);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, Register::RSI, OpAccess::CondWrite);
				AddRegister(flags, Register::RDI, OpAccess::CondWrite);
				AddRegister(flags, Register::RCX, OpAccess::ReadCondWrite);
			}
			break;
		case ImpliedAccess::t_gpr16_Wgs:
			CommandLastGpr(instruction, flags, Register::AX);
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::GS, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Wrsp_Wcs_Wss_pop5x8:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RSP, OpAccess::Write);
				AddRegister(flags, Register::CS, OpAccess::Write);
				AddRegister(flags, Register::SS, OpAccess::Write);
			}
			CommandPop(instruction, flags, 5, 8);
			break;
		case ImpliedAccess::t_Wrsp_pop5x8:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::RSP, OpAccess::Write);
			}
			CommandPop(instruction, flags, 5, 8);
			break;
		case ImpliedAccess::t_Reax_Recx_Wedx_Webx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Write);
				AddRegister(flags, Register::EBX, OpAccess::Write);
			}
			break;
		case ImpliedAccess::t_Reax_Recx_Redx_CRebx_CWedx_CWebx:
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, Register::EAX, OpAccess::Read);
				AddRegister(flags, Register::ECX, OpAccess::Read);
				AddRegister(flags, Register::EDX, OpAccess::Read);
				AddRegister(flags, Register::EBX, OpAccess::CondRead);
				AddRegister(flags, Register::EDX, OpAccess::CondWrite);
				AddRegister(flags, Register::EBX, OpAccess::CondWrite);
			}
			break;
		case ImpliedAccess::t_memdisplm64:
			CommandMemDispl(flags, -64);
			break;
			// GENERATOR-END: ImpliedAccessHandler
		default:
			throw InvalidOperationException();
		}
	}

	Register InstructionInfoFactory::GetARDI(Instruction instruction)
	{
		auto switchTempVar_1 = instruction.GetOp0Kind();

		return (switchTempVar_1 == OpKind::MemorySegDI) ? Register::DI : (switchTempVar_1 == OpKind::MemorySegEDI) ? Register::EDI : Register::RDI;
	}

	Register InstructionInfoFactory::GetSegDefaultDS(Instruction instruction)
	{
		auto seg = instruction.GetSegmentPrefix();
		return seg == Register::None ? Register::DS : seg;
	}

	void InstructionInfoFactory::CommandPush(const Instruction& instruction, Flags flags, std::int32_t count, std::uint32_t opSize)
	{
		assert(count > 0);
		std::uint64_t xspMask;
		::Iced::Intel::CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), xspMask, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			MemorySize memSize;
			if (opSize == 8)
			{
				memSize = MemorySize::UInt64;
			}
			else if (opSize == 4)
			{
				memSize = MemorySize::UInt32;
			}
			else
			{
				assert(opSize == 2);
				memSize = MemorySize::UInt16;
			}
			std::uint64_t offset = 0ULL - opSize;
			for (std::int32_t i = 0; i < count; i++, offset -= opSize)
			{
				AddMemory(Register::SS, xsp, Register::None, 1, offset & xspMask, memSize, OpAccess::Write, addressSize, 0);
			}
		}
	}

	void InstructionInfoFactory::CommandPop(const Instruction& instruction, Flags flags, std::int32_t count, std::uint32_t opSize)
	{
		assert(count > 0);
		::Iced::Intel::CodeSize addressSize;
		uint64_t _;
		auto xsp = GetXSP(instruction.GetCodeSize(), _, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			MemorySize memSize;
			if (opSize == 8)
			{
				memSize = MemorySize::UInt64;
			}
			else if (opSize == 4)
			{
				memSize = MemorySize::UInt32;
			}
			else
			{
				assert(opSize == 2);
				memSize = MemorySize::UInt16;
			}
			std::uint64_t offset = 0;
			for (std::int32_t i = 0; i < count; i++, offset += opSize)
			{
				AddMemory(Register::SS, xsp, Register::None, 1, offset, memSize, OpAccess::Read, addressSize, 0);
			}
		}
	}

	void InstructionInfoFactory::CommandPopRm(const Instruction& instruction, Flags flags, std::uint32_t opSize)
	{
		::Iced::Intel::CodeSize addressSize;
		uint64_t _;
		auto xsp = GetXSP(instruction.GetCodeSize(), _, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			MemorySize memSize;
			if (opSize == 8)
			{
				memSize = MemorySize::UInt64;
			}
			else if (opSize == 4)
			{
				memSize = MemorySize::UInt32;
			}
			else
			{
				assert(opSize == 2);
				memSize = MemorySize::UInt16;
			}
			if (instruction.GetOp0Kind() == OpKind::Memory)
			{
				assert(info.usedMemoryLocations.ValidLength == 1);
				if (instruction.GetMemoryBase() == Register::RSP || instruction.GetMemoryBase() == Register::ESP)
				{
					const auto& mem = info.usedMemoryLocations.Array[0];
					auto displ = mem.GetDisplacement() + opSize;
					if (instruction.GetMemoryBase() == Register::ESP)
					{
						displ = static_cast<std::uint32_t>(displ);
					}
					info.usedMemoryLocations.Array[0] = UsedMemory(mem.GetSegment(), mem.GetBase(), mem.GetIndex(), mem.GetScale(), displ, mem.GetMemorySize(), mem.GetAccess(), mem.GetAddressSize(), mem.GetVsibSize());
				}
			}
			AddMemory(Register::SS, xsp, Register::None, 1, 0, memSize, OpAccess::Read, addressSize, 0);
		}
	}

	void InstructionInfoFactory::CommandPusha(const Instruction& instruction, Flags flags, std::uint32_t opSize)
	{
		std::uint64_t xspMask;
		::Iced::Intel::CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), xspMask, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		std::int64_t displ;
		MemorySize memSize;
		Register baseReg;
		if (opSize == 4)
		{
			displ = -4;
			memSize = MemorySize::UInt32;
			baseReg = Register::EAX;
		}
		else
		{
			assert(opSize == 2);
			displ = -2;
			memSize = MemorySize::UInt16;
			baseReg = Register::AX;
		}
		for (std::int32_t i = 0; i < 8; i++)
		{
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, (Register)(baseReg + i), OpAccess::Read);
			}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, xsp, Register::None, 1, static_cast<std::uint64_t>((displ * (i + 1)) & xspMask), memSize, OpAccess::Write, addressSize, 0);
			}
		}
	}

	void InstructionInfoFactory::CommandPopa(const Instruction& instruction, Flags flags, std::uint32_t opSize)
	{
		std::uint64_t xspMask;
		::Iced::Intel::CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), xspMask, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		MemorySize memSize;
		Register baseReg;
		if (opSize == 4)
		{
			memSize = MemorySize::UInt32;
			baseReg = Register::EAX;
		}
		else
		{
			assert(opSize == 2);
			memSize = MemorySize::UInt16;
			baseReg = Register::AX;
		}
		for (std::int32_t i = 0; i < 8; i++)
		{
			// Ignore eSP
			if (i != 3)
			{
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, (Register)(baseReg + 7 - i), OpAccess::Write);
				}
				if ((flags & Flags::NoMemoryUsage) == 0)
				{
					AddMemory(Register::SS, xsp, Register::None, 1, opSize * static_cast<std::uint32_t>(i & xspMask), memSize, OpAccess::Read, addressSize, 0);
				}
			}
		}
	}

	void InstructionInfoFactory::CommandIns(const Instruction& instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rDI, rCX;
		switch (instruction.GetOp0Kind())
		{
		case OpKind::MemoryESDI:
			addressSize = CodeSize::Code16;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemoryESEDI:
			addressSize = CodeSize::Code32;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[0] = (byte)OpAccess::CondWrite;
					}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[1] = (byte)OpAccess::CondRead;
					}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondWrite, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(Register::DX, OpAccess::CondRead);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Write, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandOuts(const Instruction& instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rSI, rCX;
		switch (instruction.GetOp1Kind())
		{
		case OpKind::MemorySegSI:
			addressSize = CodeSize::Code16;
			rSI = Register::SI;
			rCX = Register::CX;
			break;
		case OpKind::MemorySegESI:
			addressSize = CodeSize::Code32;
			rSI = Register::ESI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rSI = Register::RSI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[0] = (byte)OpAccess::CondRead;
					}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[1] = (byte)OpAccess::CondRead;
					}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(Register::DX, OpAccess::CondRead);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::Read);
				AddRegister(flags, rSI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandMovs(const Instruction& instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rSI, rDI, rCX;
		switch (instruction.GetOp0Kind())
		{
		case OpKind::MemoryESDI:
			addressSize = CodeSize::Code16;
			rSI = Register::SI;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemoryESEDI:
			addressSize = CodeSize::Code32;
			rSI = Register::ESI;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rSI = Register::RSI;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[0] = (byte)OpAccess::CondWrite;
					}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[1] = (byte)OpAccess::CondRead;
					}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondWrite, addressSize, 0);
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Write, addressSize, 0);
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::Read);
				AddRegister(flags, rSI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandCmps(const Instruction& instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rSI, rDI, rCX;
		switch (instruction.GetOp0Kind())
		{
		case OpKind::MemorySegSI:
			addressSize = CodeSize::Code16;
			rSI = Register::SI;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemorySegESI:
			addressSize = CodeSize::Code32;
			rSI = Register::ESI;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rSI = Register::RSI;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[0] = (byte)OpAccess::CondRead;
					}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[1] = (byte)OpAccess::CondRead;
					}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::Read);
				AddRegister(flags, rSI, OpAccess::ReadWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandStos(const Instruction& instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rDI, rCX;
		switch (instruction.GetOp0Kind())
		{
		case OpKind::MemoryESDI:
			addressSize = CodeSize::Code16;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemoryESEDI:
			addressSize = CodeSize::Code32;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[0] = (byte)OpAccess::CondWrite;
					}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[1] = (byte)OpAccess::CondRead;
					}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondWrite, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(info.usedRegisters.Array[0].GetRegister(), OpAccess::CondRead);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Write, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandLods(const Instruction& instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rSI, rCX;
		switch (instruction.GetOp1Kind())
		{
		case OpKind::MemorySegSI:
			addressSize = CodeSize::Code16;
			rSI = Register::SI;
			rCX = Register::CX;
			break;
		case OpKind::MemorySegESI:
			addressSize = CodeSize::Code32;
			rSI = Register::ESI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rSI = Register::RSI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[0] = (byte)OpAccess::CondWrite;
					}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[1] = (byte)OpAccess::CondRead;
					}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(info.usedRegisters.Array[0].GetRegister(), OpAccess::CondWrite);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondRead);
				AddRegister(flags, rSI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(instruction.GetMemorySegment(), rSI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				AddMemorySegmentRegister(flags, instruction.GetMemorySegment(), OpAccess::Read);
				AddRegister(flags, rSI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandScas(const Instruction& instruction, Flags flags)
	{
		CodeSize addressSize;
		Register rDI, rCX;
		switch (instruction.GetOp1Kind())
		{
		case OpKind::MemoryESDI:
			addressSize = CodeSize::Code16;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case OpKind::MemoryESEDI:
			addressSize = CodeSize::Code32;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[0] = (byte)OpAccess::CondRead;
					}
			//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
			//	  unsafe
					{
						info.opAccesses[1] = (byte)OpAccess::CondRead;
					}
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondRead, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 1);
				info.usedRegisters.Array[0] = UsedRegister(info.usedRegisters.Array[0].GetRegister(), OpAccess::CondRead);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
			}
		}
	}

	void InstructionInfoFactory::CommandXstore(const Instruction& instruction, Flags flags, std::uint32_t size)
	{
		CodeSize addressSize;
		Register rDI, rCX;
		switch (size)
		{
		case 2:
			addressSize = CodeSize::Code16;
			rDI = Register::DI;
			rCX = Register::CX;
			break;
		case 4:
			addressSize = CodeSize::Code32;
			rDI = Register::EDI;
			rCX = Register::ECX;
			break;
		default:
			addressSize = CodeSize::Code64;
			rDI = Register::RDI;
			rCX = Register::RCX;
			break;
		}
		if (instruction.GetInternalHasRepeOrRepnePrefix())
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, MemorySize::Unknown, OpAccess::CondWrite, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				assert(info.usedRegisters.ValidLength == 0);
				AddRegister(flags, rCX, OpAccess::ReadCondWrite);
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::CondRead);
				}
				AddRegister(flags, rDI, OpAccess::CondRead);
				AddRegister(flags, rDI, OpAccess::CondWrite);
				AddRegister(flags, Register::EAX, OpAccess::CondWrite);
				AddRegister(flags, Register::EDX, OpAccess::CondRead);
			}
		}
		else
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::ES, rDI, Register::None, 1, 0, instruction.GetMemorySize(), OpAccess::Write, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((flags & Flags::Is64Bit) == 0)
				{
					AddRegister(flags, Register::ES, OpAccess::Read);
				}
				AddRegister(flags, rDI, OpAccess::ReadWrite);
				AddRegister(flags, Register::EAX, OpAccess::Write);
				AddRegister(flags, Register::EDX, OpAccess::Read);
			}
		}
	}

	void InstructionInfoFactory::CommandEnter(const Instruction& instruction, Flags flags, std::uint32_t opSize)
	{
		std::uint64_t xspMask;
		::Iced::Intel::CodeSize addressSize;
		auto xsp = GetXSP(instruction.GetCodeSize(), xspMask, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::ReadWrite);
		}
		MemorySize memSize;
		Register rSP;
		if (opSize == 8)
		{
			memSize = MemorySize::UInt64;
			rSP = Register::RSP;
		}
		else if (opSize == 4)
		{
			memSize = MemorySize::UInt32;
			rSP = Register::ESP;
		}
		else
		{
			assert(opSize == 2);
			memSize = MemorySize::UInt16;
			rSP = Register::SP;
		}
		if (rSP != xsp && (flags & Flags::NoRegisterUsage) == 0)
		{
			AddRegister(flags, rSP, OpAccess::ReadWrite);
		}
		std::int32_t nestingLevel = instruction.GetImmediate8_2nd() & 0x1F;
		std::uint64_t xspOffset = 0;
		// push rBP
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			AddRegister(flags, (Register)(rSP + 1), OpAccess::ReadWrite);
		}
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			AddMemory(Register::SS, xsp, Register::None, 1, (xspOffset -= opSize) & xspMask, memSize, OpAccess::Write, addressSize, 0);
		}
		if (nestingLevel != 0)
		{
			auto xbp = (Register)(xsp + 1); // rBP immediately follows rSP
			std::uint64_t xbpOffset = 0;
			for (std::int32_t i = 1; i < nestingLevel; i++)
			{
				if (i == 1 && (Register)(rSP + 1) != xbp && (flags & Flags::NoRegisterUsage) == 0)
				{
					AddRegister(flags, xbp, OpAccess::ReadWrite);
				}
				// push [xbp]
				if ((flags & Flags::NoMemoryUsage) == 0)
				{
					AddMemory(Register::SS, xbp, Register::None, 1, (xbpOffset -= opSize) & xspMask, memSize, OpAccess::Read, addressSize, 0);
					AddMemory(Register::SS, xsp, Register::None, 1, (xspOffset -= opSize) & xspMask, memSize, OpAccess::Write, addressSize, 0);
				}
			}
			// push frameTemp
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, xsp, Register::None, 1, (xspOffset -= opSize) & xspMask, memSize, OpAccess::Write, addressSize, 0);
			}
		}
	}

	void InstructionInfoFactory::CommandLeave(const Instruction& instruction, Flags flags, std::uint32_t opSize)
	{
		::Iced::Intel::CodeSize addressSize;
		uint64_t _;
		auto xsp = GetXSP(instruction.GetCodeSize(), _, addressSize);
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if ((flags & Flags::Is64Bit) == 0)
			{
				AddRegister(flags, Register::SS, OpAccess::Read);
			}
			AddRegister(flags, xsp, OpAccess::Write);
		}
		if (opSize == 8)
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, (Register)(xsp + 1), Register::None, 1, 0, MemorySize::UInt64, OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((Register)(xsp + 1) == Register::RBP)
				{
					AddRegister(flags, Register::RBP, OpAccess::ReadWrite);
				}
				else
				{
					AddRegister(flags, (Register)(xsp + 1), OpAccess::Read);
					AddRegister(flags, Register::RBP, OpAccess::Write);
				}
			}
		}
		else if (opSize == 4)
		{
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, (Register)(xsp + 1), Register::None, 1, 0, MemorySize::UInt32, OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((Register)(xsp + 1) == Register::EBP)
				{
					AddRegister(flags, Register::EBP, OpAccess::ReadWrite);
				}
				else
				{
					AddRegister(flags, (Register)(xsp + 1), OpAccess::Read);
					AddRegister(flags, Register::EBP, OpAccess::Write);
				}
			}
		}
		else
		{
			assert(opSize == 2);
			if ((flags & Flags::NoMemoryUsage) == 0)
			{
				AddMemory(Register::SS, (Register)(xsp + 1), Register::None, 1, 0, MemorySize::UInt16, OpAccess::Read, addressSize, 0);
			}
			if ((flags & Flags::NoRegisterUsage) == 0)
			{
				if ((Register)(xsp + 1) == Register::BP)
				{
					AddRegister(flags, Register::BP, OpAccess::ReadWrite);
				}
				else
				{
					AddRegister(flags, (Register)(xsp + 1), OpAccess::Read);
					AddRegister(flags, Register::BP, OpAccess::Write);
				}
			}
		}
	}

	void InstructionInfoFactory::CommandClearRflags(const Instruction& instruction, Flags flags)
	{
		if (instruction.GetOp0Register() != instruction.GetOp1Register())
		{
			return;
		}
		if (instruction.GetOp0Kind() != OpKind::Register || instruction.GetOp1Kind() != OpKind::Register)
		{
			return;
		}
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			   {
				   info.opAccesses[0] = (byte)OpAccess::Write;
			   }
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			   {
				   info.opAccesses[1] = (byte)OpAccess::None;
			   }
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength == 2 || info.usedRegisters.ValidLength == 3);
			info.usedRegisters.ValidLength = 0;
			AddRegister(flags, instruction.GetOp0Register(), OpAccess::Write);
		}
	}

	bool InstructionInfoFactory::IsClearInstr(const Instruction& instruction)
	{
		switch (instruction.GetMvexRegMemConv())
		{
		case MvexRegMemConv::None:
		case MvexRegMemConv::RegSwizzleNone:
			return true;
		default:
			return false;
		}
	}

	void InstructionInfoFactory::CommandClearRegRegmem(const Instruction& instruction, Flags flags)
	{
		if (instruction.GetOp0Register() != instruction.GetOp1Register())
		{
			return;
		}
		if (instruction.GetOp1Kind() != OpKind::Register)
		{
			return;
		}
		if (!IsClearInstr(instruction))
		{
			return;
		}
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			   {
				   info.opAccesses[0] = (byte)OpAccess::Write;
			   }
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			   {
				   info.opAccesses[1] = (byte)OpAccess::None;
			   }
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength == 2 || info.usedRegisters.ValidLength == 3);
			info.usedRegisters.Array[0] = UsedRegister(instruction.GetOp0Register(), OpAccess::Write);
			info.usedRegisters.ValidLength = 1;
		}
	}

	void InstructionInfoFactory::CommandClearRegRegRegmem(const Instruction& instruction, Flags flags)
	{
		if (instruction.GetOp1Register() != instruction.GetOp2Register())
		{
			return;
		}
		if (instruction.GetOp2Kind() != OpKind::Register)
		{
			return;
		}
		if (!IsClearInstr(instruction))
		{
			return;
		}
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			   {
				   info.opAccesses[1] = (byte)OpAccess::None;
			   }
		//C# TO C++ CONVERTER TODO TASK: C# 'unsafe' code is not converted by C# to C++ Converter:
		//	 unsafe
			   {
				   info.opAccesses[2] = (byte)OpAccess::None;
			   }
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength == 3 || info.usedRegisters.ValidLength == 4);
			assert(info.usedRegisters.Array[info.usedRegisters.ValidLength - 2].GetRegister() == instruction.GetOp1Register());
			assert(info.usedRegisters.Array[info.usedRegisters.ValidLength - 1].GetRegister() == instruction.GetOp2Register());
			info.usedRegisters.ValidLength -= 2;
		}
	}

	void InstructionInfoFactory::CommandArpl(const Instruction& instruction, Flags flags)
	{
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength != 0);
			// Skip memory operand, if any
			std::int32_t startIndex = instruction.GetOp0Kind() == OpKind::Register ? 0 : info.usedRegisters.ValidLength - 1;
			for (std::int32_t i = 0; i < info.usedRegisters.ValidLength; i++)
			{
				if (i < startIndex)
				{
					continue;
				}
				auto regInfo = info.usedRegisters.Array[i];
				std::int32_t index = TryGetGpr163264Index(regInfo.GetRegister());
				if (index >= 4)
				{
					index += 4; // Skip AH, CH, DH, BH
				}
				if (index >= 0)
				{
					info.usedRegisters.Array[i] = UsedRegister((Register)(Register::AL + index), regInfo.GetAccess());
				}
			}
		}
	}

	void InstructionInfoFactory::CommandLastGpr(const Instruction& instruction, Flags flags, Register baseReg)
	{
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			std::int32_t opCount = instruction.GetOpCount();
			std::int32_t immCount = instruction.GetOpKind(opCount - 1) == OpKind::Immediate8 ? 1 : 0;
			constexpr std::int32_t N = 1;
			std::int32_t opIndex = opCount - N - immCount;
			if (instruction.GetOpKind(opIndex) == OpKind::Register)
			{
				assert(info.usedRegisters.ValidLength >= N);
				assert(info.usedRegisters.Array[info.usedRegisters.ValidLength - N].GetRegister() == instruction.GetOpRegister(opIndex));
				assert(info.usedRegisters.Array[info.usedRegisters.ValidLength - N].GetAccess() == OpAccess::Read);
				std::int32_t index = TryGetGpr163264Index(instruction.GetOpRegister(opIndex));
				if (index >= 4 && baseReg == Register::AL)
				{
					index += 4; // Skip AH, CH, DH, BH
				}
				if (index >= 0)
				{
					info.usedRegisters.Array[info.usedRegisters.ValidLength - N] = UsedRegister((Register)(baseReg + index), OpAccess::Read);
				}
			}
		}
	}

	void InstructionInfoFactory::CommandLea(const Instruction& instruction, Flags flags)
	{
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			assert(info.usedRegisters.ValidLength >= 1);
			assert(instruction.GetOp0Kind() == OpKind::Register);
			auto reg = instruction.GetOp0Register();
			// The memory operand's regs start at index 1
			for (std::int32_t i = 1; i < info.usedRegisters.ValidLength; i++)
			{
				auto regInfo = info.usedRegisters.Array[i];
				if (reg >= Register::EAX && reg <= Register::R15D)
				{
					if (regInfo.GetRegister() >= Register::RAX && regInfo.GetRegister() <= Register::R15)
					{
						auto memReg = regInfo.GetRegister() - Register::RAX + Register::EAX;
						info.usedRegisters.Array[i] = UsedRegister((Register)memReg, regInfo.GetAccess());
					}
				}
				else if (reg >= Register::AX && reg <= Register::R15W)
				{
					if (regInfo.GetRegister() >= Register::EAX && regInfo.GetRegister() <= Register::R15)
					{
						auto memReg = ((regInfo.GetRegister() - Register::EAX) & 0xF) + Register::AX;
						info.usedRegisters.Array[i] = UsedRegister((Register)memReg, regInfo.GetAccess());
					}
				}
				else
				{
					assert(reg >= Register::RAX && reg <= Register::R15);
					break;
				}
			}
		}
	}

	void InstructionInfoFactory::CommandEmmi(const Instruction& instruction, Flags flags, OpAccess opAccess)
	{
		if ((flags & Flags::NoRegisterUsage) == 0)
		{
			if (instruction.GetOp0Kind() == OpKind::Register)
			{
				auto reg = instruction.GetOp0Register();
				if (reg >= Register::MM0 && reg <= Register::MM7)
				{
					reg = (Register)(((reg - Register::MM0) ^ 1) + Register::MM0);
					AddRegister(flags, reg, opAccess);
				}
			}
		}
	}

	void InstructionInfoFactory::CommandMemDispl(Flags flags, std::int32_t extraDispl)
	{
		if ((flags & Flags::NoMemoryUsage) == 0)
		{
			if (info.usedMemoryLocations.ValidLength == 1)
			{
				const auto& mem = info.usedMemoryLocations.Array[0];
				auto switchTempVar_2 = mem.GetAddressSize();


				std::uint64_t mask = (switchTempVar_2 == CodeSize::Code16) ? std::numeric_limits<std::uint16_t>::max() : (switchTempVar_2 == CodeSize::Code32) ? std::numeric_limits<std::uint32_t>::max() : std::numeric_limits<std::uint64_t>::max();
				auto displ = (mem.GetDisplacement() + static_cast<std::uint64_t>(extraDispl)) & mask;
				info.usedMemoryLocations.Array[0] = UsedMemory(mem.GetSegment(), mem.GetBase(), mem.GetIndex(), mem.GetScale(), displ, mem.GetMemorySize(), mem.GetAccess(), mem.GetAddressSize(), mem.GetVsibSize());
			}
			else
			{
				assert(false);
			}
		}
	}

	std::int32_t InstructionInfoFactory::TryGetGpr163264Index(Register register_)
	{
		std::int32_t index;
		index = register_ - Register::EAX;
		if (static_cast<std::uint32_t>(index) <= 15)
		{
			return index;
		}
		index = register_ - Register::RAX;
		if (static_cast<std::uint32_t>(index) <= 15)
		{
			return index;
		}
		index = register_ - Register::AX;
		if (static_cast<std::uint32_t>(index) <= 15)
		{
			return index;
		}
		return -1;
	}

	void InstructionInfoFactory::AddMemory(Register segReg, Register baseReg, Register indexReg, std::int32_t scale, std::uint64_t displ, MemorySize memorySize, OpAccess access, CodeSize addressSize, std::int32_t vsibSize)
	{
		if (addressSize == CodeSize::Unknown)
		{
			auto reg = baseReg != Register::None ? baseReg : indexReg;
			if (Iced::Intel::RegisterExtensions::IsGPR64(reg))
			{
				addressSize = CodeSize::Code64;
			}
			else if (Iced::Intel::RegisterExtensions::IsGPR32(reg))
			{
				addressSize = CodeSize::Code32;
			}
			else if (Iced::Intel::RegisterExtensions::IsGPR16(reg))
			{
				addressSize = CodeSize::Code16;
			}
		}
		if (access != OpAccess::NoMemAccess)
		{
			std::int32_t arrayLength = (std::int32_t)info.usedMemoryLocations.Array.size();
			std::int32_t validLen = info.usedMemoryLocations.ValidLength;
			if (arrayLength == validLen)
			{
				if (arrayLength == 0)
				{
					info.usedMemoryLocations.Array = std::vector<UsedMemory>(defaultMemoryArrayCount);
				}
				else
				{
					info.usedMemoryLocations.Array.resize(arrayLength * 2);
				}
			}
			info.usedMemoryLocations.Array[validLen] = UsedMemory(segReg, baseReg, indexReg, scale, displ, memorySize, access, addressSize, vsibSize);
			info.usedMemoryLocations.ValidLength = validLen + 1;
		}
	}

	void InstructionInfoFactory::AddMemorySegmentRegister(Flags flags, Register seg, OpAccess access)
	{
		assert(Register::ES <= seg && seg <= Register::GS);
		// Ignore es,cs,ss,ds memory operand segment registers in 64-bit mode
		if ((flags & Flags::Is64Bit) == 0 || seg >= Register::FS)
		{
			AddRegister(flags, seg, access);
		}
	}

	void InstructionInfoFactory::AddRegister(Flags flags, Register reg, OpAccess access)
	{
		assert(((flags & Flags::NoRegisterUsage) == 0, "Caller should check flags before calling this method"));
		auto writeReg = reg;
		if ((flags & (Flags::Is64Bit | Flags::ZeroExtVecRegs)) != 0)
		{
			Static::Assert(OpAccess::Write + 1 == OpAccess::CondWrite ? 0 : -1);
			Static::Assert(OpAccess::Write + 2 == OpAccess::ReadWrite ? 0 : -1);
			Static::Assert(OpAccess::Write + 3 == OpAccess::ReadCondWrite ? 0 : -1);
			if (static_cast<std::uint32_t>(access - OpAccess::Write) <= 3)
			{
				std::int32_t index;
				Static::Assert(IcedConstants::VMM_first == Register::ZMM0 ? 0 : -1);
				if ((flags & Flags::Is64Bit) != 0 && static_cast<std::uint32_t>(index = reg - Register::EAX) <= (Register::R15D - Register::EAX))
				{
					writeReg = (Register)(Register::RAX + index);
				}
				else if ((flags & Flags::ZeroExtVecRegs) != 0 && static_cast<std::uint32_t>(index = reg - Register::XMM0) <= IcedConstants::VMM_last - Register::XMM0)
				{
					writeReg = (Register)(Register::ZMM0 + (index % IcedConstants::VMM_count));
				}
				if (access != OpAccess::ReadWrite && access != OpAccess::ReadCondWrite)
				{
					reg = writeReg;
				}
			}
		}
		auto array = info.usedRegisters.Array;
		std::int32_t validLen = info.usedRegisters.ValidLength;
		std::int32_t arrayLength = (std::int32_t)array.size();
		std::int32_t numRegs = writeReg == reg ? 1 : 2;
		if (validLen + numRegs > arrayLength)
		{
			if (arrayLength == 0)
			{
				// The code below that resizes the array assumes there's at least 2 new free elements, so the minimum array length is 2.
				assert(defaultRegisterArrayCount >= 2);
				info.usedRegisters.Array = array = std::vector<UsedRegister>(defaultRegisterArrayCount);
			}
			else
			{
				assert(arrayLength * 2 >= arrayLength + numRegs);
				info.usedRegisters.Array.resize(arrayLength * 2);
				array = info.usedRegisters.Array;
			}
		}
		if (writeReg == reg)
		{
			array[validLen] = UsedRegister(reg, access);
			info.usedRegisters.ValidLength = validLen + 1;
		}
		else
		{
			assert(access == OpAccess::ReadWrite || access == OpAccess::ReadCondWrite);
			array[validLen] = UsedRegister(reg, OpAccess::Read);
			validLen++;
			auto lastAccess = access == OpAccess::ReadWrite ? OpAccess::Write : OpAccess::CondWrite;
			array[validLen] = UsedRegister(writeReg, lastAccess);
			info.usedRegisters.ValidLength = validLen + 1;
		}
	}

	const InstructionInfo& InstructionInfoFactory::GetInfo(const Instruction& instruction)
	{
		return Create(instruction, InstructionInfoOptions::None);
	}

	const InstructionInfo& InstructionInfoFactory::GetInfo(const Instruction& instruction, InstructionInfoOptions options)
	{
		return Create(instruction, options);
	}

	const InstructionInfo& InstructionInfoFactory::Create(const Instruction& instruction, InstructionInfoOptions options)
	{
		info.usedRegisters.ValidLength = 0;
		info.usedMemoryLocations.ValidLength = 0;
		auto data = InstrInfoTable::Data;
		auto index = (std::uint32_t)instruction.GetCode() << 1;
		auto flags1 = data[(int)index];
		auto flags2 = data[(int)index + 1];
		auto codeSize = instruction.GetCodeSize();
		Static::Assert((std::uint32_t)InstructionInfoOptions::NoMemoryUsage == (std::uint32_t)Flags::NoMemoryUsage ? 0 : -1);
		Static::Assert((std::uint32_t)InstructionInfoOptions::NoRegisterUsage == (std::uint32_t)Flags::NoRegisterUsage ? 0 : -1);
		auto flags = (Flags)options & (Flags::NoMemoryUsage | Flags::NoRegisterUsage);
		if (codeSize == CodeSize::Code64 || codeSize == CodeSize::Unknown)
			flags |= Flags::Is64Bit;
		if ((flags2 & ((std::uint32_t)InfoFlags2::EncodingMask << (int)InfoFlags2::EncodingShift)) != ((std::uint32_t)EncodingKind::Legacy << (int)InfoFlags2::EncodingShift))
			flags |= Flags::ZeroExtVecRegs;
		OpAccess op0Access;
		// If it fails, update InstrInfoTypesGen.GenerateOpInfoX()
		Static::Assert(InstrInfoConstants::OpInfo0_Count == 13 ? 0 : -1);
		auto op0Info = (OpInfo0)((flags1 >> (int)InfoFlags1::OpInfo0Shift) & (std::uint32_t)InfoFlags1::OpInfo0Mask);
		switch (op0Info)
		{
		default:
		case OpInfo0::None:
			op0Access = OpAccess::None;
			break;
		case OpInfo0::Read:
			op0Access = OpAccess::Read;
			break;
		case OpInfo0::Write:
			if (instruction.GetHasOpMask() && instruction.GetMergingMasking())
			{
				if (instruction.GetOp0Kind() != OpKind::Register)
					op0Access = OpAccess::CondWrite;
				else
					op0Access = OpAccess::ReadWrite;
			}
			else
				op0Access = OpAccess::Write;
			break;
		case OpInfo0::WriteVmm:
			// If it's opmask+merging ({k1}) and dest is xmm/ymm/zmm, then access is one of:
			//	k1			mem			xmm/ymm		zmm
			//	----------------------------------------
			//	all 1s		write		write		write		all bits are overwritten, upper bits in zmm (if xmm/ymm) are cleared
			//	all 0s		no access	read/write	no access	no elem is written, but xmm/ymm's upper bits (in zmm) are cleared so
			//													treat it as R lower bits + clear upper bits + W full reg
			//	else		cond-write	read/write	r-c-w		some elems are unchanged, the others are overwritten
			// If it's xmm/ymm, use RW, else use RCW. If it's mem, use CW
			if (instruction.GetHasOpMask() && instruction.GetMergingMasking())
			{
				if (instruction.GetOp0Kind() != OpKind::Register)
					op0Access = OpAccess::CondWrite;
				else
					op0Access = OpAccess::ReadCondWrite;
			}
			else
				op0Access = OpAccess::Write;
			break;
		case OpInfo0::WriteForce:
		case OpInfo0::WriteForceP1:
			op0Access = OpAccess::Write;
			break;
		case OpInfo0::CondWrite:
			op0Access = OpAccess::CondWrite;
			break;
		case OpInfo0::CondWrite32_ReadWrite64:
			if ((flags & Flags::Is64Bit) != 0)
				op0Access = OpAccess::ReadWrite;
			else
				op0Access = OpAccess::CondWrite;
			break;
		case OpInfo0::ReadWrite:
			op0Access = OpAccess::ReadWrite;
			break;
		case OpInfo0::ReadWriteVmm:
			// If it's opmask+merging ({k1}) and dest is xmm/ymm/zmm, then access is one of:
			//	k1			xmm/ymm		zmm
			//	-------------------------------
			//	all 1s		read/write	read/write	all bits are overwritten, upper bits in zmm (if xmm/ymm) are cleared
			//	all 0s		read/write	no access	no elem is written, but xmm/ymm's upper bits (in zmm) are cleared so
			//										treat it as R lower bits + clear upper bits + W full reg
			//	else		read/write	r-c-w		some elems are unchanged, the others are overwritten
			// If it's xmm/ymm, use RW, else use RCW
			if (instruction.GetHasOpMask() && instruction.GetMergingMasking())
				op0Access = OpAccess::ReadCondWrite;
			else
				op0Access = OpAccess::ReadWrite;
			break;
		case OpInfo0::ReadCondWrite:
			op0Access = OpAccess::ReadCondWrite;
			break;
		case OpInfo0::NoMemAccess:
			op0Access = OpAccess::NoMemAccess;
			break;
		case OpInfo0::WriteMem_ReadWriteReg:
			if (instruction.GetInternalOp0IsNotRegOrOp1IsNotReg())
				op0Access = OpAccess::Write;
			else
				op0Access = OpAccess::ReadWrite;
			break;
		}
		assert(instruction.GetOpCount() <= IcedConstants::MaxOpCount);
		info.opAccesses[0] = (byte)op0Access;
		auto op1Info = (OpInfo1)((flags1 >> (int)InfoFlags1::OpInfo1Shift) & (std::uint32_t)InfoFlags1::OpInfo1Mask);
		info.opAccesses[1] = (byte)OpAccesses::Op1[(int)op1Info];
		info.opAccesses[2] = (byte)OpAccesses::Op2[(int)((flags1 >> (int)InfoFlags1::OpInfo2Shift) & (std::uint32_t)InfoFlags1::OpInfo2Mask)];
		if ((flags1 & (((std::uint32_t)InfoFlags1::OpInfo3Mask) << (int)InfoFlags1::OpInfo3Shift)) != 0)
		{
			Static::Assert((int)InstrInfoConstants::OpInfo3_Count == 2 ? 0 : -1);
			info.opAccesses[3] = (byte)OpAccess::Read;
		}
		else
		{
			info.opAccesses[3] = (byte)OpAccess::None;
		}
		if ((flags1 & (((std::uint32_t)InfoFlags1::OpInfo4Mask) << (int)InfoFlags1::OpInfo4Shift)) != 0)
		{
			Static::Assert((int)InstrInfoConstants::OpInfo4_Count == 2 ? 0 : -1);
			info.opAccesses[4] = (byte)OpAccess::Read;
		}
		else
		{
			info.opAccesses[4] = (byte)OpAccess::None;
		}
		Static::Assert(IcedConstants::MaxOpCount == 5 ? 0 : -1);
		int opCount = instruction.GetOpCount();
		for (int i = 0; i < opCount; i++)
		{
			OpAccess access;
			access = (OpAccess)info.opAccesses[i];
			if (access == OpAccess::None)
				continue;
			switch (instruction.GetOpKind(i))
			{
			case OpKind::Register:
				if (access == OpAccess::NoMemAccess)
				{
					access = OpAccess::Read;
					info.opAccesses[i] = (byte)OpAccess::Read;
				}
				if ((flags & Flags::NoRegisterUsage) == 0)
				{
					if (i == 0 && op0Info == OpInfo0::WriteForceP1)
					{
						auto reg = instruction.GetOp0Register();
						AddRegister(flags, reg, access);
						if (Register::K0 <= reg && reg <= Register::K7)
							AddRegister(flags, (Register)(((reg - Register::K0) ^ 1) + Register::K0), access);
					}
					else if (i == 1 && op1Info == OpInfo1::ReadP3)
					{
						auto reg = instruction.GetOp1Register();
						if (Register::XMM0 <= reg && reg <= IcedConstants::VMM_last)
						{
							reg = (Register)(IcedConstants::VMM_first + ((reg - IcedConstants::VMM_first) & ~3));
							for (int j = 0; j < 4; j++)
								AddRegister(flags, (Register)(reg + j), access);
						}
					}
					else
						AddRegister(flags, instruction.GetOpRegister(i), access);
				}
				break;
			case OpKind::Memory:
				Static::Assert((std::uint32_t)InfoFlags1::IgnoresSegment == (1U << 31) ? 0 : -1);
				Static::Assert(Register::None == 0 ? 0 : -1);
				auto segReg = (Register)((std::uint32_t)instruction.GetMemorySegment() & ~(std::uint32_t)((int)flags1 >> 31));
				auto baseReg = instruction.GetMemoryBase();
				if (baseReg == Register::RIP)
				{
					if ((flags & Flags::NoMemoryUsage) == 0)
						AddMemory(segReg, Register::None, Register::None, 1, instruction.GetMemoryDisplacement64(), instruction.GetMemorySize(), access, CodeSize::Code64, 0);
					if ((flags & Flags::NoRegisterUsage) == 0 && segReg != Register::None)
						AddMemorySegmentRegister(flags, segReg, OpAccess::Read);
				}
				else if (baseReg == Register::EIP)
				{
					if ((flags & Flags::NoMemoryUsage) == 0)
						AddMemory(segReg, Register::None, Register::None, 1, instruction.GetMemoryDisplacement32(), instruction.GetMemorySize(), access, CodeSize::Code32, 0);
					if ((flags & Flags::NoRegisterUsage) == 0 && segReg != Register::None)
						AddMemorySegmentRegister(flags, segReg, OpAccess::Read);
				}
				else
				{
					int scale;
					Register indexReg;
					if ((flags1 & (std::uint32_t)InfoFlags1::IgnoresIndexVA) != 0)
					{
						indexReg = instruction.GetMemoryIndex();
						if ((flags & Flags::NoRegisterUsage) == 0 && indexReg != Register::None)
							AddRegister(flags, indexReg, OpAccess::Read);
						indexReg = Register::None;
						scale = 1;
					}
					else
					{
						indexReg = instruction.GetMemoryIndex();
						scale = instruction.GetMemoryIndexScale();
					}
					if ((flags & Flags::NoMemoryUsage) == 0)
					{
						auto addrSizeBytes = InstructionUtils::GetAddressSizeInBytes(baseReg, indexReg, instruction.GetMemoryDisplSize(), codeSize);
						auto switchTempauto_0 = addrSizeBytes;


						auto addrSize = (switchTempauto_0 == 2) ? CodeSize::Code16 : (switchTempauto_0 == 4) ? CodeSize::Code32 : (switchTempauto_0 == 8) ? CodeSize::Code64 : CodeSize::Unknown;
						int vsibSize = 0;
						bool vsib64;
						if (RegisterExtensions::IsVectorRegister(indexReg) && instruction.TryGetVsib64(vsib64))
							vsibSize = vsib64 ? 8 : 4;
						ulong displ;
						if (addrSizeBytes == 8)
							displ = instruction.GetMemoryDisplacement64();
						else
							displ = instruction.GetMemoryDisplacement32();
						AddMemory(segReg, baseReg, indexReg, scale, displ, instruction.GetMemorySize(), access, addrSize, vsibSize);
					}
					if ((flags & Flags::NoRegisterUsage) == 0)
					{
						if (segReg != Register::None)
							AddMemorySegmentRegister(flags, segReg, OpAccess::Read);
						if (baseReg != Register::None)
							AddRegister(flags, baseReg, OpAccess::Read);
						if (indexReg != Register::None)
							AddRegister(flags, indexReg, OpAccess::Read);
					}
				}
				break;
			}
		}
		auto impliedAccess = (ImpliedAccess)((flags1 >> (int)InfoFlags1::ImpliedAccessShift) & (std::uint32_t)InfoFlags1::ImpliedAccessMask);
		if (impliedAccess != ImpliedAccess::None)
			AddImpliedAccesses(impliedAccess, instruction, flags);
		if (instruction.GetHasOpMask() && (flags & Flags::NoRegisterUsage) == 0)
			AddRegister(flags, instruction.GetOpMask(), (flags1 & (std::uint32_t)InfoFlags1::OpMaskReadWrite) != 0 ? OpAccess::ReadWrite : OpAccess::Read);
		return info;
	}

}
