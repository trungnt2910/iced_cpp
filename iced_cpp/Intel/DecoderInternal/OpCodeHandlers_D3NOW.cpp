// C# helper headers
#include <csharp/classes.h>
#include <csharp/enum.h>



// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#include "OpCodeHandlers_D3NOW.h"
#include "../Static.h"
#include "../EncodingKind.g.h"
#include "../OpKind.g.h"
#include "../Register.g.h"
#include "../DecoderOptions.g.h"

namespace Iced::Intel::DecoderInternal
{

	std::vector<Code> OpCodeHandler_D3NOW::CodeValues = CreateCodeValues();

	std::vector<Code> OpCodeHandler_D3NOW::CreateCodeValues()
	{
		auto result = std::vector<Code>(0x100);
		Static::Assert(Code::INVALID == (Iced::Intel::Code)0 ? 0 : -1);
		// GENERATOR-BEGIN: D3nowCodeValues
		// ⚠️This was generated by GENERATOR!🦹‍♂️
		result[0xBF] = Code::D3NOW_Pavgusb_mm_mmm64;
		result[0xBB] = Code::D3NOW_Pswapd_mm_mmm64;
		result[0xB7] = Code::D3NOW_Pmulhrw_mm_mmm64;
		result[0xB6] = Code::D3NOW_Pfrcpit2_mm_mmm64;
		result[0xB4] = Code::D3NOW_Pfmul_mm_mmm64;
		result[0xB0] = Code::D3NOW_Pfcmpeq_mm_mmm64;
		result[0xAE] = Code::D3NOW_Pfacc_mm_mmm64;
		result[0xAA] = Code::D3NOW_Pfsubr_mm_mmm64;
		result[0xA7] = Code::D3NOW_Pfrsqit1_mm_mmm64;
		result[0xA6] = Code::D3NOW_Pfrcpit1_mm_mmm64;
		result[0xA4] = Code::D3NOW_Pfmax_mm_mmm64;
		result[0xA0] = Code::D3NOW_Pfcmpgt_mm_mmm64;
		result[0x9E] = Code::D3NOW_Pfadd_mm_mmm64;
		result[0x9A] = Code::D3NOW_Pfsub_mm_mmm64;
		result[0x97] = Code::D3NOW_Pfrsqrt_mm_mmm64;
		result[0x96] = Code::D3NOW_Pfrcp_mm_mmm64;
		result[0x94] = Code::D3NOW_Pfmin_mm_mmm64;
		result[0x90] = Code::D3NOW_Pfcmpge_mm_mmm64;
		result[0x8E] = Code::D3NOW_Pfpnacc_mm_mmm64;
		result[0x8A] = Code::D3NOW_Pfnacc_mm_mmm64;
		result[0x87] = Code::D3NOW_Pfrsqrtv_mm_mmm64;
		result[0x86] = Code::D3NOW_Pfrcpv_mm_mmm64;
		result[0x1D] = Code::D3NOW_Pf2id_mm_mmm64;
		result[0x1C] = Code::D3NOW_Pf2iw_mm_mmm64;
		result[0x0D] = Code::D3NOW_Pi2fd_mm_mmm64;
		result[0x0C] = Code::D3NOW_Pi2fw_mm_mmm64;
		// GENERATOR-END: D3nowCodeValues
		return result;
	}

	void OpCodeHandler_D3NOW::Decode(Decoder* decoder, Instruction& instruction)
	{
		auto& state = decoder->state;
		assert(state.GetEncoding() == EncodingKind::Legacy);
		Static::Assert(OpKind::Register == (Iced::Intel::OpKind)0 ? 0 : -1);
		//instruction.Op0Kind = OpKind.Register;
		instruction.SetOp0Register((Register)(static_cast<std::int32_t>(state.reg) + Register::MM0));
		if (state.mod == 3)
		{
			Static::Assert(OpKind::Register == (Iced::Intel::OpKind)0 ? 0 : -1);
			//instruction.Op1Kind = OpKind.Register;
			instruction.SetOp1Register((Register)(static_cast<std::int32_t>(state.rm) + Register::MM0));
		}
		else
		{
			instruction.SetOp1Kind(OpKind::Memory);
			decoder->ReadOpMem(instruction);
		}
		auto code = codeValues[static_cast<std::int32_t>(decoder->ReadByte())];
		switch (code)
		{
		case Code::D3NOW_Pfrcpv_mm_mmm64:
		case Code::D3NOW_Pfrsqrtv_mm_mmm64:
			if ((decoder->options & DecoderOptions::Cyrix) == 0 || decoder->GetBitness() == 64)
			{
				code = Code::INVALID;
			}
			break;
		}
		instruction.SetCode(code);
		if (code == Code::INVALID)
		{
			decoder->SetInvalidInstruction();
		}
	}
}
