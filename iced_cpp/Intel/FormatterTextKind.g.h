/* 
SPDX-License-Identifier: MIT
Copyright (C) 2018-present iced project and contributors
 */

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once

#if defined(GAS) || defined(INTEL) || defined(MASM) || defined(NASM) || defined(FAST_FMT)
#include <array>
#include <stdexcept>
#include <string>
#include "ToString.h"
#include "Internal/StringHelpers.h"
namespace Iced::Intel {
	enum class FormatterTextKind {
		/// <summary>Normal text</summary>
		Text  = 0,
		/// <summary>Assembler directive</summary>
		Directive  = 1,
		/// <summary>Any prefix</summary>
		Prefix  = 2,
		/// <summary>Any mnemonic</summary>
		Mnemonic  = 3,
		/// <summary>Any keyword</summary>
		Keyword  = 4,
		/// <summary>Any operator</summary>
		Operator  = 5,
		/// <summary>Any punctuation</summary>
		Punctuation  = 6,
		/// <summary>Number</summary>
		Number  = 7,
		/// <summary>Any register</summary>
		Register  = 8,
		/// <summary>A decorator, eg. <c>sae</c> in <c>{sae}</c></summary>
		Decorator  = 9,
		/// <summary>Selector value (eg. far <c>JMP</c>/<c>CALL</c>)</summary>
		SelectorValue  = 10,
		/// <summary>Label address (eg. <c>JE XXXXXX</c>)</summary>
		LabelAddress  = 11,
		/// <summary>Function address (eg. <c>CALL XXXXXX</c>)</summary>
		FunctionAddress  = 12,
		/// <summary>Data symbol</summary>
		Data  = 13,
		/// <summary>Label symbol</summary>
		Label  = 14,
		/// <summary>Function symbol</summary>
		Function  = 15,
	};
	constexpr int operator+(const FormatterTextKind& a, const FormatterTextKind& b) { return ((int)a + (int)b); }
	constexpr int operator+(const FormatterTextKind& a, const int& b) { return ((int)a + b); }
	constexpr int operator+(const int& a, const FormatterTextKind& b) { return (a + (int)b); }
	constexpr int operator-(const FormatterTextKind& a, const FormatterTextKind& b) { return ((int)a - (int)b); }
	constexpr int operator-(const FormatterTextKind& a, const int& b) { return ((int)a - b); }
	constexpr int operator-(const int& a, const FormatterTextKind& b) { return (a - (int)b); }
	constexpr FormatterTextKind operator++(FormatterTextKind& a, int) { auto temp = a; a = FormatterTextKind(a + 1); return temp; }
	constexpr FormatterTextKind& operator++(FormatterTextKind& a) { return a = FormatterTextKind(a + 1); }
	constexpr FormatterTextKind operator--(FormatterTextKind& a, int) { auto temp = a; a = FormatterTextKind(a - 1); return temp; }
	constexpr FormatterTextKind& operator--(FormatterTextKind& a) { return a = FormatterTextKind(a - 1); }
	constexpr bool operator==(const FormatterTextKind& a, const int& b) { return ((int)a == b); }
	constexpr bool operator==(const int& a, const FormatterTextKind& b) { return (a == (int)b); }
	constexpr bool operator>=(const FormatterTextKind& a, const int& b) { return ((int)a >= b); }
	constexpr bool operator>=(const int& a, const FormatterTextKind& b) { return (a >= (int)b); }
	constexpr bool operator<=(const FormatterTextKind& a, const int& b) { return ((int)a <= b); }
	constexpr bool operator<=(const int& a, const FormatterTextKind& b) { return (a <= (int)b); }
	constexpr bool operator>(const FormatterTextKind& a, const int& b) { return ((int)a > b); }
	constexpr bool operator>(const int& a, const FormatterTextKind& b) { return (a > (int)b); }
	constexpr bool operator<(const FormatterTextKind& a, const int& b) { return ((int)a < b); }
	constexpr bool operator<(const int& a, const FormatterTextKind& b) { return (a < (int)b); }
	constexpr bool operator!=(const FormatterTextKind& a, const int& b) { return ((int)a != b); }
	constexpr bool operator!=(const int& a, const FormatterTextKind& b) { return (a != (int)b); }
}
template <>
constexpr std::string Iced::Intel::ToString(const Iced::Intel::FormatterTextKind& e) {
	switch (e) {
		case Iced::Intel::FormatterTextKind::Text: return "Text";
		case Iced::Intel::FormatterTextKind::Directive: return "Directive";
		case Iced::Intel::FormatterTextKind::Prefix: return "Prefix";
		case Iced::Intel::FormatterTextKind::Mnemonic: return "Mnemonic";
		case Iced::Intel::FormatterTextKind::Keyword: return "Keyword";
		case Iced::Intel::FormatterTextKind::Operator: return "Operator";
		case Iced::Intel::FormatterTextKind::Punctuation: return "Punctuation";
		case Iced::Intel::FormatterTextKind::Number: return "Number";
		case Iced::Intel::FormatterTextKind::Register: return "Register";
		case Iced::Intel::FormatterTextKind::Decorator: return "Decorator";
		case Iced::Intel::FormatterTextKind::SelectorValue: return "SelectorValue";
		case Iced::Intel::FormatterTextKind::LabelAddress: return "LabelAddress";
		case Iced::Intel::FormatterTextKind::FunctionAddress: return "FunctionAddress";
		case Iced::Intel::FormatterTextKind::Data: return "Data";
		case Iced::Intel::FormatterTextKind::Label: return "Label";
		case Iced::Intel::FormatterTextKind::Function: return "Function";
		default: return Internal::StringHelpers::ToDec((int)e);
	}
}
#endif
