// C# helper headers

#include <csharp/enum.h>



// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#pragma once

#include "MemorySizeOptions.g.h"
#include "ThrowHelper.h"
#include <string>

// Code generated from Iced. Do not edit.
// Commit tag: badb6147c0994a4954fa27645aba2b02c2bb9502.
// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors
namespace Iced::Intel
{

	// GENERATOR-BEGIN: NumberBase
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	/// <summary>Number base</summary>
	enum class NumberBase
	{
		/// <summary>Hex numbers (base 16)</summary>
		Hexadecimal = 0,
		/// <summary>Decimal numbers (base 10)</summary>
		Decimal = 1,
		/// <summary>Octal numbers (base 8)</summary>
		Octal = 2,
		/// <summary>Binary numbers (base 2)</summary>
		Binary = 3
	};

	DEFINE_COMP(NumberBase)
		DEFINE_ARITH(NumberBase)

		// GENERATOR-END: NumberBase
		// GENERATOR-BEGIN: CC_b
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JB</c> / <c>JC</c> / <c>JNAE</c>)</summary>
		enum class CC_b : std::uint8_t
	{
		/// <summary><c>JB</c>, <c>CMOVB</c>, <c>SETB</c></summary>
		b = 0,
		/// <summary><c>JC</c>, <c>CMOVC</c>, <c>SETC</c></summary>
		c = 1,
		/// <summary><c>JNAE</c>, <c>CMOVNAE</c>, <c>SETNAE</c></summary>
		nae = 2
	};

	DEFINE_COMP(CC_b)
		DEFINE_ARITH(CC_b)

		// GENERATOR-END: CC_b
		// GENERATOR-BEGIN: CC_ae
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JAE</c> / <c>JNB</c> / <c>JNC</c>)</summary>
		enum class CC_ae : std::uint8_t
	{
		/// <summary><c>JAE</c>, <c>CMOVAE</c>, <c>SETAE</c></summary>
		ae = 0,
		/// <summary><c>JNB</c>, <c>CMOVNB</c>, <c>SETNB</c></summary>
		nb = 1,
		/// <summary><c>JNC</c>, <c>CMOVNC</c>, <c>SETNC</c></summary>
		nc = 2
	};

	DEFINE_COMP(CC_ae)
		DEFINE_ARITH(CC_ae)

		// GENERATOR-END: CC_ae
		// GENERATOR-BEGIN: CC_e
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JE</c> / <c>JZ</c>)</summary>
		enum class CC_e : std::uint8_t
	{
		/// <summary><c>JE</c>, <c>CMOVE</c>, <c>SETE</c>, <c>LOOPE</c>, <c>REPE</c></summary>
		e = 0,
		/// <summary><c>JZ</c>, <c>CMOVZ</c>, <c>SETZ</c>, <c>LOOPZ</c>, <c>REPZ</c></summary>
		z = 1
	};

	DEFINE_COMP(CC_e)
		DEFINE_ARITH(CC_e)

		// GENERATOR-END: CC_e
		// GENERATOR-BEGIN: CC_ne
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JNE</c> / <c>JNZ</c>)</summary>
		enum class CC_ne : std::uint8_t
	{
		/// <summary><c>JNE</c>, <c>CMOVNE</c>, <c>SETNE</c>, <c>LOOPNE</c>, <c>REPNE</c></summary>
		ne = 0,
		/// <summary><c>JNZ</c>, <c>CMOVNZ</c>, <c>SETNZ</c>, <c>LOOPNZ</c>, <c>REPNZ</c></summary>
		nz = 1
	};

	DEFINE_COMP(CC_ne)
		DEFINE_ARITH(CC_ne)

		// GENERATOR-END: CC_ne
		// GENERATOR-BEGIN: CC_be
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JBE</c> / <c>JNA</c>)</summary>
		enum class CC_be : std::uint8_t
	{
		/// <summary><c>JBE</c>, <c>CMOVBE</c>, <c>SETBE</c></summary>
		be = 0,
		/// <summary><c>JNA</c>, <c>CMOVNA</c>, <c>SETNA</c></summary>
		na = 1
	};

	DEFINE_COMP(CC_be)
		DEFINE_ARITH(CC_be)

		// GENERATOR-END: CC_be
		// GENERATOR-BEGIN: CC_a
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JA</c> / <c>JNBE</c>)</summary>
		enum class CC_a : std::uint8_t
	{
		/// <summary><c>JA</c>, <c>CMOVA</c>, <c>SETA</c></summary>
		a = 0,
		/// <summary><c>JNBE</c>, <c>CMOVNBE</c>, <c>SETNBE</c></summary>
		nbe = 1
	};

	DEFINE_COMP(CC_a)
		DEFINE_ARITH(CC_a)

		// GENERATOR-END: CC_a
		// GENERATOR-BEGIN: CC_p
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JP</c> / <c>JPE</c>)</summary>
		enum class CC_p : std::uint8_t
	{
		/// <summary><c>JP</c>, <c>CMOVP</c>, <c>SETP</c></summary>
		p = 0,
		/// <summary><c>JPE</c>, <c>CMOVPE</c>, <c>SETPE</c></summary>
		pe = 1
	};

	DEFINE_COMP(CC_p)
		DEFINE_ARITH(CC_p)

		// GENERATOR-END: CC_p
		// GENERATOR-BEGIN: CC_np
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JNP</c> / <c>JPO</c>)</summary>
		enum class CC_np : std::uint8_t
	{
		/// <summary><c>JNP</c>, <c>CMOVNP</c>, <c>SETNP</c></summary>
		np = 0,
		/// <summary><c>JPO</c>, <c>CMOVPO</c>, <c>SETPO</c></summary>
		po = 1
	};

	DEFINE_COMP(CC_np)
		DEFINE_ARITH(CC_np)

		// GENERATOR-END: CC_np
		// GENERATOR-BEGIN: CC_l
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JL</c> / <c>JNGE</c>)</summary>
		enum class CC_l : std::uint8_t
	{
		/// <summary><c>JL</c>, <c>CMOVL</c>, <c>SETL</c></summary>
		l = 0,
		/// <summary><c>JNGE</c>, <c>CMOVNGE</c>, <c>SETNGE</c></summary>
		nge = 1
	};

	DEFINE_COMP(CC_l)
		DEFINE_ARITH(CC_l)

		// GENERATOR-END: CC_l
		// GENERATOR-BEGIN: CC_ge
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JGE</c> / <c>JNL</c>)</summary>
		enum class CC_ge : std::uint8_t
	{
		/// <summary><c>JGE</c>, <c>CMOVGE</c>, <c>SETGE</c></summary>
		ge = 0,
		/// <summary><c>JNL</c>, <c>CMOVNL</c>, <c>SETNL</c></summary>
		nl = 1
	};

	DEFINE_COMP(CC_ge)
		DEFINE_ARITH(CC_ge)

		// GENERATOR-END: CC_ge
		// GENERATOR-BEGIN: CC_le
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JLE</c> / <c>JNG</c>)</summary>
		enum class CC_le : std::uint8_t
	{
		/// <summary><c>JLE</c>, <c>CMOVLE</c>, <c>SETLE</c></summary>
		le = 0,
		/// <summary><c>JNG</c>, <c>CMOVNG</c>, <c>SETNG</c></summary>
		ng = 1
	};

	DEFINE_COMP(CC_le)
		DEFINE_ARITH(CC_le)

		// GENERATOR-END: CC_le
		// GENERATOR-BEGIN: CC_g
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>Mnemonic condition code selector (eg. <c>JG</c> / <c>JNLE</c>)</summary>
		enum class CC_g : std::uint8_t
	{
		/// <summary><c>JG</c>, <c>CMOVG</c>, <c>SETG</c></summary>
		g = 0,
		/// <summary><c>JNLE</c>, <c>CMOVNLE</c>, <c>SETNLE</c></summary>
		nle = 1
	};

	DEFINE_COMP(CC_g)
		DEFINE_ARITH(CC_g)

		// GENERATOR-END: CC_g
	/// <summary>
	/// Formatter options
	/// </summary>
	class FormatterOptions final
	{
	private:
		std::int32_t FirstOperandCharIndex = 0;
		std::int32_t TabSize = 0;
		std::string HexPrefix;
		std::string HexSuffix;
		std::int32_t HexDigitGroupSize = 4;
		std::string DecimalPrefix;
		std::string DecimalSuffix;
		std::int32_t DecimalDigitGroupSize = 3;
		std::string OctalPrefix;
		std::string OctalSuffix;
		std::int32_t OctalDigitGroupSize = 4;
		std::string BinaryPrefix;
		std::string BinarySuffix;
		std::int32_t BinaryDigitGroupSize = 4;
		std::string DigitSeparator;

	private:
		enum class Flags1 : std::uint32_t
		{
			None = 0,
			UppercasePrefixes = 0x00000001,
			UppercaseMnemonics = 0x00000002,
			UppercaseRegisters = 0x00000004,
			UppercaseKeywords = 0x00000008,
			UppercaseDecorators = 0x00000010,
			UppercaseAll = 0x00000020,
			SpaceAfterOperandSeparator = 0x00000040,
			SpaceAfterMemoryBracket = 0x00000080,
			SpaceBetweenMemoryAddOperators = 0x00000100,
			SpaceBetweenMemoryMulOperators = 0x00000200,
			ScaleBeforeIndex = 0x00000400,
			AlwaysShowScale = 0x00000800,
			AlwaysShowSegmentRegister = 0x00001000,
			ShowZeroDisplacements = 0x00002000,
			LeadingZeros = 0x00004000,
			UppercaseHex = 0x00008000,
			SmallHexNumbersInDecimal = 0x00010000,
			AddLeadingZeroToHexNumbers = 0x00020000,
			BranchLeadingZeros = 0x00040000,
			SignedImmediateOperands = 0x00080000,
			SignedMemoryDisplacements = 0x00100000,
			DisplacementLeadingZeros = 0x00200000,
			RipRelativeAddresses = 0x00400000,
			ShowBranchSize = 0x00800000,
			UsePseudoOps = 0x01000000,
			ShowSymbolAddress = 0x02000000,
			GasNakedRegisters = 0x04000000,
			GasShowMnemonicSizeSuffix = 0x08000000,
			GasSpaceAfterMemoryOperandComma = 0x10000000,
			MasmAddDsPrefix32 = 0x20000000,
			MasmSymbolDisplInBrackets = 0x40000000,
			MasmDisplInBrackets = 0x80000000
		};
		DEFINE_FLAGS_FRIEND(Flags1)
			DEFINE_COMP_FRIEND(Flags1)
			DEFINE_ARITH_FRIEND(Flags1)

	private:
		enum class Flags2 : int
		{
			None = 0,
			NasmShowSignExtendedImmediateSize = 0x00000001,
			PreferST0 = 0x00000002,
			ShowUselessPrefixes = 0x00000004
		};
		DEFINE_FLAGS_FRIEND(Flags2)
			DEFINE_COMP_FRIEND(Flags2)
			DEFINE_ARITH_FRIEND(Flags2)

	private:
		Flags1 flags1 = static_cast<Flags1>(0);
		Flags2 flags2 = static_cast<Flags2>(0);
		/// <summary>
		/// Constructor
		/// </summary>
	public:
		constexpr FormatterOptions();
		/// <summary>
		/// Prefixes are uppercased
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>REP stosd</c>
		/// <br/>
		/// <see langword="false"/>: <c>rep stosd</c>
		/// </summary>
		constexpr bool GetUppercasePrefixes() const;
		constexpr void SetUppercasePrefixes(bool value);
		/// <summary>
		/// Mnemonics are uppercased
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>MOV rcx,rax</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov rcx,rax</c>
		/// </summary>
		constexpr bool GetUppercaseMnemonics() const;
		constexpr void SetUppercaseMnemonics(bool value);
		/// <summary>
		/// Registers are uppercased
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov RCX,[RAX+RDX*8]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov rcx,[rax+rdx*8]</c>
		/// </summary>
		constexpr bool GetUppercaseRegisters() const;
		constexpr void SetUppercaseRegisters(bool value);
		/// <summary>
		/// Keywords are uppercased (eg. <c>BYTE PTR</c>, <c>SHORT</c>)
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov BYTE PTR [rcx],12h</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov byte ptr [rcx],12h</c>
		/// </summary>
		constexpr bool GetUppercaseKeywords() const;
		constexpr void SetUppercaseKeywords(bool value);
		/// <summary>
		/// Uppercase decorators, eg. <c>{z}</c>, <c>{sae}</c>, <c>{rd-sae}</c> (but not opmask registers: <c>{k1}</c>)
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>vunpcklps xmm2{k5}{Z},xmm6,dword bcst [rax+4]</c>
		/// <br/>
		/// <see langword="false"/>: <c>vunpcklps xmm2{k5}{z},xmm6,dword bcst [rax+4]</c>
		/// </summary>
		constexpr bool GetUppercaseDecorators() const;
		constexpr void SetUppercaseDecorators(bool value);
		/// <summary>
		/// Everything is uppercased, except numbers and their prefixes/suffixes
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>MOV EAX,GS:[RCX*4+0ffh]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,gs:[rcx*4+0ffh]</c>
		/// </summary>
		constexpr bool GetUppercaseAll() const;
		constexpr void SetUppercaseAll(bool value);
		/// <summary>
		/// Character index (0-based) where the first operand is formatted. Can be set to 0 to format it immediately after the mnemonic.
		/// At least one space or tab is always added between the mnemonic and the first operand.
		/// <br/>
		/// Default: <c>0</c>
		/// <br/>
		/// <c>0</c>: <c>mov‚Ä¢rcx,rbp</c>
		/// <br/>
		/// <c>8</c>: <c>mov‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢rcx,rbp</c>
		/// <br/>
		/// </summary>
		constexpr std::int32_t GetFirstOperandCharIndex() const;
		constexpr void SetFirstOperandCharIndex(std::int32_t value);
		/// <summary>
		/// Size of a tab character or &lt;= 0 to use spaces
		/// <br/>
		/// Default: <c>0</c>
		/// </summary>
		constexpr std::int32_t GetTabSize() const;
		constexpr void SetTabSize(std::int32_t value);
		/// <summary>
		/// Add a space after the operand separator
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov rax, rcx</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov rax,rcx</c>
		/// </summary>
		constexpr bool GetSpaceAfterOperandSeparator() const;
		constexpr void SetSpaceAfterOperandSeparator(bool value);
		/// <summary>
		/// Add a space between the memory expression and the brackets
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,[ rcx+rdx ]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[rcx+rdx]</c>
		/// </summary>
		constexpr bool GetSpaceAfterMemoryBracket() const;
		constexpr void SetSpaceAfterMemoryBracket(bool value);
		/// <summary>
		/// Add spaces between memory operand <c>+</c> and <c>-</c> operators
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,[rcx + rdx*8 - 80h]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[rcx+rdx*8-80h]</c>
		/// </summary>
		constexpr bool GetSpaceBetweenMemoryAddOperators() const;
		constexpr void SetSpaceBetweenMemoryAddOperators(bool value);
		/// <summary>
		/// Add spaces between memory operand <c>*</c> operator
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,[rcx+rdx * 8-80h]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[rcx+rdx*8-80h]</c>
		/// </summary>
		constexpr bool GetSpaceBetweenMemoryMulOperators() const;
		constexpr void SetSpaceBetweenMemoryMulOperators(bool value);
		/// <summary>
		/// Show memory operand scale value before the index register
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,[8*rdx]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[rdx*8]</c>
		/// </summary>
		constexpr bool GetScaleBeforeIndex() const;
		constexpr void SetScaleBeforeIndex(bool value);
		/// <summary>
		/// Always show the scale value even if it's <c>*1</c>
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,[rbx+rcx*1]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[rbx+rcx]</c>
		/// </summary>
		constexpr bool GetAlwaysShowScale() const;
		constexpr void SetAlwaysShowScale(bool value);
		/// <summary>
		/// Always show the effective segment register. If the option is <see langword="false"/>, only show the segment register if
		/// there's a segment override prefix.
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,ds:[ecx]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[ecx]</c>
		/// </summary>
		constexpr bool GetAlwaysShowSegmentRegister() const;
		constexpr void SetAlwaysShowSegmentRegister(bool value);
		/// <summary>
		/// Show zero displacements
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,[rcx*2+0]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[rcx*2]</c>
		/// </summary>
		constexpr bool GetShowZeroDisplacements() const;
		constexpr void SetShowZeroDisplacements(bool value);
		/// <summary>
		/// Hex number prefix or <see langword="null"/>/empty string, eg. "0x"
		/// <br/>
		/// Default: <see langword="null"/> (masm/nasm/intel), <c>"0x"</c> (gas)
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public string? HexPrefix {get;set;}
		constexpr std::string GetHexPrefix() const;
		constexpr void SetHexPrefix(const std::string& value);
		/// <summary>
		/// Hex number suffix or <see langword="null"/>/empty string, eg. "h"
		/// <br/>
		/// Default: <c>"h"</c> (masm/nasm/intel), <see langword="null"/> (gas)
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public string? HexSuffix {get;set;}
		constexpr std::string GetHexSuffix() const;
		constexpr void SetHexSuffix(const std::string& value);
		/// <summary>
		/// Size of a digit group, see also <see cref="DigitSeparator"/>
		/// <br/>
		/// Default: <c>4</c>
		/// <br/>
		/// <c>0</c>: <c>0x12345678</c>
		/// <br/>
		/// <c>4</c>: <c>0x1234_5678</c>
		/// </summary>
		constexpr std::int32_t GetHexDigitGroupSize() const;
		constexpr void SetHexDigitGroupSize(std::int32_t value);
		/// <summary>
		/// Decimal number prefix or <see langword="null"/>/empty string
		/// <br/>
		/// Default: <see langword="null"/>
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public string? DecimalPrefix {get;set;}
		constexpr std::string GetDecimalPrefix() const;
		constexpr void SetDecimalPrefix(const std::string& value);
		/// <summary>
		/// Decimal number suffix or <see langword="null"/>/empty string
		/// <br/>
		/// Default: <see langword="null"/>
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public string? DecimalSuffix {get;set;}
		constexpr std::string GetDecimalSuffix() const;
		constexpr void SetDecimalSuffix(const std::string& value);
		/// <summary>
		/// Size of a digit group, see also <see cref="DigitSeparator"/>
		/// <br/>
		/// Default: <c>3</c>
		/// <br/>
		/// <c>0</c>: <c>12345678</c>
		/// <br/>
		/// <c>3</c>: <c>12_345_678</c>
		/// </summary>
		constexpr std::int32_t GetDecimalDigitGroupSize() const;
		constexpr void SetDecimalDigitGroupSize(std::int32_t value);
		/// <summary>
		/// Octal number prefix or <see langword="null"/>/empty string
		/// <br/>
		/// Default: <see langword="null"/> (masm/nasm/intel), <c>"0"</c> (gas)
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public string? OctalPrefix {get;set;}
		constexpr std::string GetOctalPrefix() const;
		constexpr void SetOctalPrefix(const std::string& value);
		/// <summary>
		/// Octal number suffix or <see langword="null"/>/empty string
		/// <br/>
		/// Default: <c>"o"</c> (masm/nasm/intel), <see langword="null"/> (gas)
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public string? OctalSuffix {get;set;}
		constexpr std::string GetOctalSuffix() const;
		constexpr void SetOctalSuffix(const std::string& value);
		/// <summary>
		/// Size of a digit group, see also <see cref="DigitSeparator"/>
		/// <br/>
		/// Default: <c>4</c>
		/// <br/>
		/// <c>0</c>: <c>12345670</c>
		/// <br/>
		/// <c>4</c>: <c>1234_5670</c>
		/// </summary>
		constexpr std::int32_t GetOctalDigitGroupSize() const;
		constexpr void SetOctalDigitGroupSize(std::int32_t value);
		/// <summary>
		/// Binary number prefix or <see langword="null"/>/empty string
		/// <br/>
		/// Default: <see langword="null"/> (masm/nasm/intel), <c>"0b"</c> (gas)
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public string? BinaryPrefix {get;set;}
		constexpr std::string GetBinaryPrefix() const;
		constexpr void SetBinaryPrefix(const std::string& value);
		/// <summary>
		/// Binary number suffix or <see langword="null"/>/empty string
		/// <br/>
		/// Default: <c>"b"</c> (masm/nasm/intel), <see langword="null"/> (gas)
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public string? BinarySuffix {get;set;}
		constexpr std::string GetBinarySuffix() const;
		constexpr void SetBinarySuffix(const std::string& value);
		/// <summary>
		/// Size of a digit group, see also <see cref="DigitSeparator"/>
		/// <br/>
		/// Default: <c>4</c>
		/// <br/>
		/// <c>0</c>: <c>11010111</c>
		/// <br/>
		/// <c>4</c>: <c>1101_0111</c>
		/// </summary>
		constexpr std::int32_t GetBinaryDigitGroupSize() const;
		constexpr void SetBinaryDigitGroupSize(std::int32_t value);
		/// <summary>
		/// Digit separator or <see langword="null"/>/empty string. See also eg. <see cref="HexDigitGroupSize"/>.
		/// <br/>
		/// Default: <see langword="null"/>
		/// <br/>
		/// <c>""</c>: <c>0x12345678</c>
		/// <br/>
		/// <c>"_"</c>: <c>0x1234_5678</c>
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public string? DigitSeparator {get;set;}
		constexpr std::string GetDigitSeparator() const;
		constexpr void SetDigitSeparator(const std::string& value);
		/// <summary>
		/// Add leading zeros to hexadecimal/octal/binary numbers.
		/// This option has no effect on branch targets and displacements, use <see cref="BranchLeadingZeros"/>
		/// and <see cref="DisplacementLeadingZeros"/>.
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>0x0000000A</c>/<c>0000000Ah</c>
		/// <br/>
		/// <see langword="false"/>: <c>0xA</c>/<c>0Ah</c>
		/// </summary>
		constexpr bool GetLeadingZeros() const;
		constexpr void SetLeadingZeros(bool value);
		/// <summary>
		/// Add leading zeros to hexadecimal/octal/binary numbers.
		/// This option has no effect on branch targets and displacements, use <see cref="BranchLeadingZeros"/>
		/// and <see cref="DisplacementLeadingZeros"/>.
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>0x0000000A</c>/<c>0000000Ah</c>
		/// <br/>
		/// <see langword="false"/>: <c>0xA</c>/<c>0Ah</c>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public bool LeadingZeroes
		constexpr bool GetLeadingZeroes() const;
		constexpr void SetLeadingZeroes(bool value);
		/// <summary>
		/// Use uppercase hex digits
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>0xFF</c>
		/// <br/>
		/// <see langword="false"/>: <c>0xff</c>
		/// </summary>
		constexpr bool GetUppercaseHex() const;
		constexpr void SetUppercaseHex(bool value);
		/// <summary>
		/// Small hex numbers (-9 .. 9) are shown in decimal
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>9</c>
		/// <br/>
		/// <see langword="false"/>: <c>0x9</c>
		/// </summary>
		constexpr bool GetSmallHexNumbersInDecimal() const;
		constexpr void SetSmallHexNumbersInDecimal(bool value);
		/// <summary>
		/// Add a leading zero to hex numbers if there's no prefix and the number starts with hex digits <c>A-F</c>
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>0FFh</c>
		/// <br/>
		/// <see langword="false"/>: <c>FFh</c>
		/// </summary>
		constexpr bool GetAddLeadingZeroToHexNumbers() const;
		constexpr void SetAddLeadingZeroToHexNumbers(bool value);
		/// <summary>
		/// Number base
		/// <br/>
		/// Default: <see cref="NumberBase.Hexadecimal"/>
		/// </summary>
		constexpr Iced::Intel::NumberBase GetNumberBase() const;
		constexpr void SetNumberBase(Iced::Intel::NumberBase value);
	private:
		Iced::Intel::NumberBase numberBase = NumberBase::Hexadecimal;
		/// <summary>
		/// Add leading zeros to branch offsets. Used by <c>CALL NEAR</c>, <c>CALL FAR</c>, <c>JMP NEAR</c>, <c>JMP FAR</c>, <c>Jcc</c>, <c>LOOP</c>, <c>LOOPcc</c>, <c>XBEGIN</c>
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>je 00000123h</c>
		/// <br/>
		/// <see langword="false"/>: <c>je 123h</c>
		/// </summary>
	public:
		constexpr bool GetBranchLeadingZeros() const;
		constexpr void SetBranchLeadingZeros(bool value);
		/// <summary>
		/// Add leading zeros to branch offsets. Used by <c>CALL NEAR</c>, <c>CALL FAR</c>, <c>JMP NEAR</c>, <c>JMP FAR</c>, <c>Jcc</c>, <c>LOOP</c>, <c>LOOPcc</c>, <c>XBEGIN</c>
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>je 00000123h</c>
		/// <br/>
		/// <see langword="false"/>: <c>je 123h</c>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public bool BranchLeadingZeroes
		constexpr bool GetBranchLeadingZeroes() const;
		constexpr void SetBranchLeadingZeroes(bool value);
		/// <summary>
		/// Show immediate operands as signed numbers
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,-1</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,FFFFFFFF</c>
		/// </summary>
		constexpr bool GetSignedImmediateOperands() const;
		constexpr void SetSignedImmediateOperands(bool value);
		/// <summary>
		/// Displacements are signed numbers
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov al,[eax-2000h]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov al,[eax+0FFFFE000h]</c>
		/// </summary>
		constexpr bool GetSignedMemoryDisplacements() const;
		constexpr void SetSignedMemoryDisplacements(bool value);
		/// <summary>
		/// Add leading zeros to displacements
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov al,[eax+00000012h]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov al,[eax+12h]</c>
		/// </summary>
		constexpr bool GetDisplacementLeadingZeros() const;
		constexpr void SetDisplacementLeadingZeros(bool value);
		/// <summary>
		/// Add leading zeros to displacements
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov al,[eax+00000012h]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov al,[eax+12h]</c>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)] public bool DisplacementLeadingZeroes
		constexpr bool GetDisplacementLeadingZeroes() const;
		constexpr void SetDisplacementLeadingZeroes(bool value);
		/// <summary>
		/// Options that control if the memory size (eg. <c>DWORD PTR</c>) is shown or not.
		/// This is ignored by the gas (AT&amp;T) formatter.
		/// <br/>
		/// Default: <see cref="Intel.MemorySizeOptions.Default"/>
		/// </summary>
		constexpr Iced::Intel::MemorySizeOptions GetMemorySizeOptions() const;
		constexpr void SetMemorySizeOptions(Iced::Intel::MemorySizeOptions value);
	private:
		Iced::Intel::MemorySizeOptions memorySizeOptions = MemorySizeOptions::Default;
		/// <summary>
		/// Show <c>RIP+displ</c> or the virtual address
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,[rip+12345678h]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[1029384756AFBECDh]</c>
		/// </summary>
	public:
		constexpr bool GetRipRelativeAddresses() const;
		constexpr void SetRipRelativeAddresses(bool value);
		/// <summary>
		/// Show <c>NEAR</c>, <c>SHORT</c>, etc if it's a branch instruction
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>je short 1234h</c>
		/// <br/>
		/// <see langword="false"/>: <c>je 1234h</c>
		/// </summary>
		constexpr bool GetShowBranchSize() const;
		constexpr void SetShowBranchSize(bool value);
		/// <summary>
		/// Use pseudo instructions
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>vcmpnltsd xmm2,xmm6,xmm3</c>
		/// <br/>
		/// <see langword="false"/>: <c>vcmpsd xmm2,xmm6,xmm3,5</c>
		/// </summary>
		constexpr bool GetUsePseudoOps() const;
		constexpr void SetUsePseudoOps(bool value);
		/// <summary>
		/// Show the original value after the symbol name
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,[myfield (12345678)]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[myfield]</c>
		/// </summary>
		constexpr bool GetShowSymbolAddress() const;
		constexpr void SetShowSymbolAddress(bool value);
		/// <summary>
		/// (gas only): If <see langword="true"/>, the formatter doesn't add <c>%</c> to registers
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,ecx</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov %eax,%ecx</c>
		/// </summary>
		constexpr bool GetGasNakedRegisters() const;
		constexpr void SetGasNakedRegisters(bool value);
		/// <summary>
		/// (gas only): Shows the mnemonic size suffix even when not needed
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>movl %eax,%ecx</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov %eax,%ecx</c>
		/// </summary>
		constexpr bool GetGasShowMnemonicSizeSuffix() const;
		constexpr void SetGasShowMnemonicSizeSuffix(bool value);
		/// <summary>
		/// (gas only): Add a space after the comma if it's a memory operand
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>(%eax, %ecx, 2)</c>
		/// <br/>
		/// <see langword="false"/>: <c>(%eax,%ecx,2)</c>
		/// </summary>
		constexpr bool GetGasSpaceAfterMemoryOperandComma() const;
		constexpr void SetGasSpaceAfterMemoryOperandComma(bool value);
		/// <summary>
		/// (masm only): Add a <c>DS</c> segment override even if it's not present. Used if it's 16/32-bit code and mem op is a displ
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>mov eax,ds:[12345678]</c>
		/// <br/>
		/// <see langword="false"/>: <c>mov eax,[12345678]</c>
		/// </summary>
		constexpr bool GetMasmAddDsPrefix32() const;
		constexpr void SetMasmAddDsPrefix32(bool value);
		/// <summary>
		/// (masm only): Show symbols in brackets
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>[ecx+symbol]</c> / <c>[symbol]</c>
		/// <br/>
		/// <see langword="false"/>: <c>symbol[ecx]</c> / <c>symbol</c>
		/// </summary>
		constexpr bool GetMasmSymbolDisplInBrackets() const;
		constexpr void SetMasmSymbolDisplInBrackets(bool value);
		/// <summary>
		/// (masm only): Show displacements in brackets
		/// <br/>
		/// Default: <see langword="true"/>
		/// <br/>
		/// <see langword="true"/>: <c>[ecx+1234h]</c>
		/// <br/>
		/// <see langword="false"/>: <c>1234h[ecx]</c>
		/// </summary>
		constexpr bool GetMasmDisplInBrackets() const;
		constexpr void SetMasmDisplInBrackets(bool value);
		/// <summary>
		/// (nasm only): Shows <c>BYTE</c>, <c>WORD</c>, <c>DWORD</c> or <c>QWORD</c> if it's a sign extended immediate operand value
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>or rcx,byte -1</c>
		/// <br/>
		/// <see langword="false"/>: <c>or rcx,-1</c>
		/// </summary>
		constexpr bool GetNasmShowSignExtendedImmediateSize() const;
		constexpr void SetNasmShowSignExtendedImmediateSize(bool value);
		/// <summary>
		/// Use <c>st(0)</c> instead of <c>st</c> if <c>st</c> can be used. Ignored by the nasm formatter.
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>fadd st(0),st(3)</c>
		/// <br/>
		/// <see langword="false"/>: <c>fadd st,st(3)</c>
		/// </summary>
		constexpr bool GetPreferST0() const;
		constexpr void SetPreferST0(bool value);
		/// <summary>
		/// Show useless prefixes. If it has useless prefixes, it could be data and not code.
		/// <br/>
		/// Default: <see langword="false"/>
		/// <br/>
		/// <see langword="true"/>: <c>es rep add eax,ecx</c>
		/// <br/>
		/// <see langword="false"/>: <c>add eax,ecx</c>
		/// </summary>
		constexpr bool GetShowUselessPrefixes() const;
		constexpr void SetShowUselessPrefixes(bool value);
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JB</c> / <c>JC</c> / <c>JNAE</c>)
		/// <br/>
		/// Default: <c>JB</c>, <c>CMOVB</c>, <c>SETB</c>
		/// </summary>
		constexpr Iced::Intel::CC_b GetCCB() const;
		constexpr void SetCCB(Iced::Intel::CC_b value);
	private:
		Iced::Intel::CC_b cc_b = CC_b::b;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JAE</c> / <c>JNB</c> / <c>JNC</c>)
		/// <br/>
		/// Default: <c>JAE</c>, <c>CMOVAE</c>, <c>SETAE</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_ae GetCCAe() const;
		constexpr void SetCCAe(Iced::Intel::CC_ae value);
	private:
		Iced::Intel::CC_ae cc_ae = CC_ae::ae;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JE</c> / <c>JZ</c>)
		/// <br/>
		/// Default: <c>JE</c>, <c>CMOVE</c>, <c>SETE</c>, <c>LOOPE</c>, <c>REPE</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_e GetCCE() const;
		constexpr void SetCCE(Iced::Intel::CC_e value);
	private:
		Iced::Intel::CC_e cc_e = CC_e::e;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JNE</c> / <c>JNZ</c>)
		/// <br/>
		/// Default: <c>JNE</c>, <c>CMOVNE</c>, <c>SETNE</c>, <c>LOOPNE</c>, <c>REPNE</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_ne GetCCNe() const;
		constexpr void SetCCNe(Iced::Intel::CC_ne value);
	private:
		Iced::Intel::CC_ne cc_ne = CC_ne::ne;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JBE</c> / <c>JNA</c>)
		/// <br/>
		/// Default: <c>JBE</c>, <c>CMOVBE</c>, <c>SETBE</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_be GetCCBe() const;
		constexpr void SetCCBe(Iced::Intel::CC_be value);
	private:
		Iced::Intel::CC_be cc_be = CC_be::be;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JA</c> / <c>JNBE</c>)
		/// <br/>
		/// Default: <c>JA</c>, <c>CMOVA</c>, <c>SETA</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_a GetCCA() const;
		constexpr void SetCCA(Iced::Intel::CC_a value);
	private:
		Iced::Intel::CC_a cc_a = CC_a::a;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JP</c> / <c>JPE</c>)
		/// <br/>
		/// Default: <c>JP</c>, <c>CMOVP</c>, <c>SETP</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_p GetCCP() const;
		constexpr void SetCCP(Iced::Intel::CC_p value);
	private:
		Iced::Intel::CC_p cc_p = CC_p::p;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JNP</c> / <c>JPO</c>)
		/// <br/>
		/// Default: <c>JNP</c>, <c>CMOVNP</c>, <c>SETNP</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_np GetCCNp() const;
		constexpr void SetCCNp(Iced::Intel::CC_np value);
	private:
		Iced::Intel::CC_np cc_np = CC_np::np;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JL</c> / <c>JNGE</c>)
		/// <br/>
		/// Default: <c>JL</c>, <c>CMOVL</c>, <c>SETL</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_l GetCCL() const;
		constexpr void SetCCL(Iced::Intel::CC_l value);
	private:
		Iced::Intel::CC_l cc_l = CC_l::l;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JGE</c> / <c>JNL</c>)
		/// <br/>
		/// Default: <c>JGE</c>, <c>CMOVGE</c>, <c>SETGE</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_ge GetCCGe() const;
		constexpr void SetCCGe(Iced::Intel::CC_ge value);
	private:
		Iced::Intel::CC_ge cc_ge = CC_ge::ge;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JLE</c> / <c>JNG</c>)
		/// <br/>
		/// Default: <c>JLE</c>, <c>CMOVLE</c>, <c>SETLE</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_le GetCCLe() const;
		constexpr void SetCCLe(Iced::Intel::CC_le value);
	private:
		Iced::Intel::CC_le cc_le = CC_le::le;
		/// <summary>
		/// Mnemonic condition code selector (eg. <c>JG</c> / <c>JNLE</c>)
		/// <br/>
		/// Default: <c>JG</c>, <c>CMOVG</c>, <c>SETG</c>
		/// </summary>
	public:
		constexpr Iced::Intel::CC_g GetCCG() const;
		constexpr void SetCCG(Iced::Intel::CC_g value);
	private:
		Iced::Intel::CC_g cc_g = CC_g::g;
		/// <summary>
		/// Creates GNU assembler (AT&amp;T) formatter options
		/// </summary>
		/// <returns></returns>
	public:
		constexpr static FormatterOptions CreateGas();
		/// <summary>
		/// Creates Intel (XED) formatter options
		/// </summary>
		/// <returns></returns>
		constexpr static FormatterOptions CreateIntel();
		/// <summary>
		/// Creates masm formatter options
		/// </summary>
		/// <returns></returns>
		constexpr static FormatterOptions CreateMasm();
		/// <summary>
		/// Creates nasm formatter options
		/// </summary>
		/// <returns></returns>
		constexpr static FormatterOptions CreateNasm();
	};
}

namespace Iced::Intel
{

	constexpr FormatterOptions::FormatterOptions()
	{
		flags1 = Flags1::UppercaseHex | Flags1::SmallHexNumbersInDecimal | Flags1::AddLeadingZeroToHexNumbers | Flags1::BranchLeadingZeros | Flags1::SignedMemoryDisplacements | Flags1::ShowBranchSize | Flags1::UsePseudoOps | Flags1::MasmAddDsPrefix32 | Flags1::MasmSymbolDisplInBrackets | Flags1::MasmDisplInBrackets;
		flags2 = Flags2::None;
	}

	constexpr bool FormatterOptions::GetUppercasePrefixes() const
	{
		return (flags1 & Flags1::UppercasePrefixes) != 0;
	}

	constexpr void FormatterOptions::SetUppercasePrefixes(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::UppercasePrefixes;
		}
		else
		{
			flags1 &= ~Flags1::UppercasePrefixes;
		}
	}

	constexpr bool FormatterOptions::GetUppercaseMnemonics() const
	{
		return (flags1 & Flags1::UppercaseMnemonics) != 0;
	}

	constexpr void FormatterOptions::SetUppercaseMnemonics(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::UppercaseMnemonics;
		}
		else
		{
			flags1 &= ~Flags1::UppercaseMnemonics;
		}
	}

	constexpr bool FormatterOptions::GetUppercaseRegisters() const
	{
		return (flags1 & Flags1::UppercaseRegisters) != 0;
	}

	constexpr void FormatterOptions::SetUppercaseRegisters(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::UppercaseRegisters;
		}
		else
		{
			flags1 &= ~Flags1::UppercaseRegisters;
		}
	}

	constexpr bool FormatterOptions::GetUppercaseKeywords() const
	{
		return (flags1 & Flags1::UppercaseKeywords) != 0;
	}

	constexpr void FormatterOptions::SetUppercaseKeywords(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::UppercaseKeywords;
		}
		else
		{
			flags1 &= ~Flags1::UppercaseKeywords;
		}
	}

	constexpr bool FormatterOptions::GetUppercaseDecorators() const
	{
		return (flags1 & Flags1::UppercaseDecorators) != 0;
	}

	constexpr void FormatterOptions::SetUppercaseDecorators(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::UppercaseDecorators;
		}
		else
		{
			flags1 &= ~Flags1::UppercaseDecorators;
		}
	}

	constexpr bool FormatterOptions::GetUppercaseAll() const
	{
		return (flags1 & Flags1::UppercaseAll) != 0;
	}

	constexpr void FormatterOptions::SetUppercaseAll(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::UppercaseAll;
		}
		else
		{
			flags1 &= ~Flags1::UppercaseAll;
		}
	}

	constexpr std::int32_t FormatterOptions::GetFirstOperandCharIndex() const
	{
		return FirstOperandCharIndex;
	}

	constexpr void FormatterOptions::SetFirstOperandCharIndex(std::int32_t value)
	{
		FirstOperandCharIndex = value;
	}

	constexpr std::int32_t FormatterOptions::GetTabSize() const
	{
		return TabSize;
	}

	constexpr void FormatterOptions::SetTabSize(std::int32_t value)
	{
		TabSize = value;
	}

	constexpr bool FormatterOptions::GetSpaceAfterOperandSeparator() const
	{
		return (flags1 & Flags1::SpaceAfterOperandSeparator) != 0;
	}

	constexpr void FormatterOptions::SetSpaceAfterOperandSeparator(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::SpaceAfterOperandSeparator;
		}
		else
		{
			flags1 &= ~Flags1::SpaceAfterOperandSeparator;
		}
	}

	constexpr bool FormatterOptions::GetSpaceAfterMemoryBracket() const
	{
		return (flags1 & Flags1::SpaceAfterMemoryBracket) != 0;
	}

	constexpr void FormatterOptions::SetSpaceAfterMemoryBracket(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::SpaceAfterMemoryBracket;
		}
		else
		{
			flags1 &= ~Flags1::SpaceAfterMemoryBracket;
		}
	}

	constexpr bool FormatterOptions::GetSpaceBetweenMemoryAddOperators() const
	{
		return (flags1 & Flags1::SpaceBetweenMemoryAddOperators) != 0;
	}

	constexpr void FormatterOptions::SetSpaceBetweenMemoryAddOperators(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::SpaceBetweenMemoryAddOperators;
		}
		else
		{
			flags1 &= ~Flags1::SpaceBetweenMemoryAddOperators;
		}
	}

	constexpr bool FormatterOptions::GetSpaceBetweenMemoryMulOperators() const
	{
		return (flags1 & Flags1::SpaceBetweenMemoryMulOperators) != 0;
	}

	constexpr void FormatterOptions::SetSpaceBetweenMemoryMulOperators(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::SpaceBetweenMemoryMulOperators;
		}
		else
		{
			flags1 &= ~Flags1::SpaceBetweenMemoryMulOperators;
		}
	}

	constexpr bool FormatterOptions::GetScaleBeforeIndex() const
	{
		return (flags1 & Flags1::ScaleBeforeIndex) != 0;
	}

	constexpr void FormatterOptions::SetScaleBeforeIndex(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::ScaleBeforeIndex;
		}
		else
		{
			flags1 &= ~Flags1::ScaleBeforeIndex;
		}
	}

	constexpr bool FormatterOptions::GetAlwaysShowScale() const
	{
		return (flags1 & Flags1::AlwaysShowScale) != 0;
	}

	constexpr void FormatterOptions::SetAlwaysShowScale(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::AlwaysShowScale;
		}
		else
		{
			flags1 &= ~Flags1::AlwaysShowScale;
		}
	}

	constexpr bool FormatterOptions::GetAlwaysShowSegmentRegister() const
	{
		return (flags1 & Flags1::AlwaysShowSegmentRegister) != 0;
	}

	constexpr void FormatterOptions::SetAlwaysShowSegmentRegister(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::AlwaysShowSegmentRegister;
		}
		else
		{
			flags1 &= ~Flags1::AlwaysShowSegmentRegister;
		}
	}

	constexpr bool FormatterOptions::GetShowZeroDisplacements() const
	{
		return (flags1 & Flags1::ShowZeroDisplacements) != 0;
	}

	constexpr void FormatterOptions::SetShowZeroDisplacements(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::ShowZeroDisplacements;
		}
		else
		{
			flags1 &= ~Flags1::ShowZeroDisplacements;
		}
	}

	constexpr std::string FormatterOptions::GetHexPrefix() const
	{
		return HexPrefix;
	}

	constexpr void FormatterOptions::SetHexPrefix(const std::string& value)
	{
		HexPrefix = value;
	}

	constexpr std::string FormatterOptions::GetHexSuffix() const
	{
		return HexSuffix;
	}

	constexpr void FormatterOptions::SetHexSuffix(const std::string& value)
	{
		HexSuffix = value;
	}

	constexpr std::int32_t FormatterOptions::GetHexDigitGroupSize() const
	{
		return HexDigitGroupSize;
	}

	constexpr void FormatterOptions::SetHexDigitGroupSize(std::int32_t value)
	{
		HexDigitGroupSize = value;
	}

	constexpr std::string FormatterOptions::GetDecimalPrefix() const
	{
		return DecimalPrefix;
	}

	constexpr void FormatterOptions::SetDecimalPrefix(const std::string& value)
	{
		DecimalPrefix = value;
	}

	constexpr std::string FormatterOptions::GetDecimalSuffix() const
	{
		return DecimalSuffix;
	}

	constexpr void FormatterOptions::SetDecimalSuffix(const std::string& value)
	{
		DecimalSuffix = value;
	}

	constexpr std::int32_t FormatterOptions::GetDecimalDigitGroupSize() const
	{
		return DecimalDigitGroupSize;
	}

	constexpr void FormatterOptions::SetDecimalDigitGroupSize(std::int32_t value)
	{
		DecimalDigitGroupSize = value;
	}

	constexpr std::string FormatterOptions::GetOctalPrefix() const
	{
		return OctalPrefix;
	}

	constexpr void FormatterOptions::SetOctalPrefix(const std::string& value)
	{
		OctalPrefix = value;
	}

	constexpr std::string FormatterOptions::GetOctalSuffix() const
	{
		return OctalSuffix;
	}

	constexpr void FormatterOptions::SetOctalSuffix(const std::string& value)
	{
		OctalSuffix = value;
	}

	constexpr std::int32_t FormatterOptions::GetOctalDigitGroupSize() const
	{
		return OctalDigitGroupSize;
	}

	constexpr void FormatterOptions::SetOctalDigitGroupSize(std::int32_t value)
	{
		OctalDigitGroupSize = value;
	}

	constexpr std::string FormatterOptions::GetBinaryPrefix() const
	{
		return BinaryPrefix;
	}

	constexpr void FormatterOptions::SetBinaryPrefix(const std::string& value)
	{
		BinaryPrefix = value;
	}

	constexpr std::string FormatterOptions::GetBinarySuffix() const
	{
		return BinarySuffix;
	}

	constexpr void FormatterOptions::SetBinarySuffix(const std::string& value)
	{
		BinarySuffix = value;
	}

	constexpr std::int32_t FormatterOptions::GetBinaryDigitGroupSize() const
	{
		return BinaryDigitGroupSize;
	}

	constexpr void FormatterOptions::SetBinaryDigitGroupSize(std::int32_t value)
	{
		BinaryDigitGroupSize = value;
	}

	constexpr std::string FormatterOptions::GetDigitSeparator() const
	{
		return DigitSeparator;
	}

	constexpr void FormatterOptions::SetDigitSeparator(const std::string& value)
	{
		DigitSeparator = value;
	}

	constexpr bool FormatterOptions::GetLeadingZeros() const
	{
		return (flags1 & Flags1::LeadingZeros) != 0;
	}

	constexpr void FormatterOptions::SetLeadingZeros(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::LeadingZeros;
		}
		else
		{
			flags1 &= ~Flags1::LeadingZeros;
		}
	}

	constexpr bool FormatterOptions::GetLeadingZeroes() const
	{
		return GetLeadingZeros();
	}

	constexpr void FormatterOptions::SetLeadingZeroes(bool value)
	{
		SetLeadingZeros(value);
	}

	constexpr bool FormatterOptions::GetUppercaseHex() const
	{
		return (flags1 & Flags1::UppercaseHex) != 0;
	}

	constexpr void FormatterOptions::SetUppercaseHex(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::UppercaseHex;
		}
		else
		{
			flags1 &= ~Flags1::UppercaseHex;
		}
	}

	constexpr bool FormatterOptions::GetSmallHexNumbersInDecimal() const
	{
		return (flags1 & Flags1::SmallHexNumbersInDecimal) != 0;
	}

	constexpr void FormatterOptions::SetSmallHexNumbersInDecimal(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::SmallHexNumbersInDecimal;
		}
		else
		{
			flags1 &= ~Flags1::SmallHexNumbersInDecimal;
		}
	}

	constexpr bool FormatterOptions::GetAddLeadingZeroToHexNumbers() const
	{
		return (flags1 & Flags1::AddLeadingZeroToHexNumbers) != 0;
	}

	constexpr void FormatterOptions::SetAddLeadingZeroToHexNumbers(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::AddLeadingZeroToHexNumbers;
		}
		else
		{
			flags1 &= ~Flags1::AddLeadingZeroToHexNumbers;
		}
	}

	constexpr Iced::Intel::NumberBase FormatterOptions::GetNumberBase() const
	{
		return numberBase;
	}

	constexpr void FormatterOptions::SetNumberBase(Iced::Intel::NumberBase value)
	{
		if (static_cast<std::uint32_t>(value) > static_cast<std::uint32_t>(NumberBase::Binary))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		numberBase = value;
	}

	constexpr bool FormatterOptions::GetBranchLeadingZeros() const
	{
		return (flags1 & Flags1::BranchLeadingZeros) != 0;
	}

	constexpr void FormatterOptions::SetBranchLeadingZeros(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::BranchLeadingZeros;
		}
		else
		{
			flags1 &= ~Flags1::BranchLeadingZeros;
		}
	}

	constexpr bool FormatterOptions::GetBranchLeadingZeroes() const
	{
		return GetBranchLeadingZeros();
	}

	constexpr void FormatterOptions::SetBranchLeadingZeroes(bool value)
	{
		SetBranchLeadingZeros(value);
	}

	constexpr bool FormatterOptions::GetSignedImmediateOperands() const
	{
		return (flags1 & Flags1::SignedImmediateOperands) != 0;
	}

	constexpr void FormatterOptions::SetSignedImmediateOperands(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::SignedImmediateOperands;
		}
		else
		{
			flags1 &= ~Flags1::SignedImmediateOperands;
		}
	}

	constexpr bool FormatterOptions::GetSignedMemoryDisplacements() const
	{
		return (flags1 & Flags1::SignedMemoryDisplacements) != 0;
	}

	constexpr void FormatterOptions::SetSignedMemoryDisplacements(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::SignedMemoryDisplacements;
		}
		else
		{
			flags1 &= ~Flags1::SignedMemoryDisplacements;
		}
	}

	constexpr bool FormatterOptions::GetDisplacementLeadingZeros() const
	{
		return (flags1 & Flags1::DisplacementLeadingZeros) != 0;
	}

	constexpr void FormatterOptions::SetDisplacementLeadingZeros(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::DisplacementLeadingZeros;
		}
		else
		{
			flags1 &= ~Flags1::DisplacementLeadingZeros;
		}
	}

	constexpr bool FormatterOptions::GetDisplacementLeadingZeroes() const
	{
		return GetDisplacementLeadingZeros();
	}

	constexpr void FormatterOptions::SetDisplacementLeadingZeroes(bool value)
	{
		SetDisplacementLeadingZeros(value);
	}

	constexpr Iced::Intel::MemorySizeOptions FormatterOptions::GetMemorySizeOptions() const
	{
		return memorySizeOptions;
	}

	constexpr void FormatterOptions::SetMemorySizeOptions(Iced::Intel::MemorySizeOptions value)
	{
		if (static_cast<std::uint32_t>(value) > static_cast<std::uint32_t>(MemorySizeOptions::Never))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		memorySizeOptions = value;
	}

	constexpr bool FormatterOptions::GetRipRelativeAddresses() const
	{
		return (flags1 & Flags1::RipRelativeAddresses) != 0;
	}

	constexpr void FormatterOptions::SetRipRelativeAddresses(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::RipRelativeAddresses;
		}
		else
		{
			flags1 &= ~Flags1::RipRelativeAddresses;
		}
	}

	constexpr bool FormatterOptions::GetShowBranchSize() const
	{
		return (flags1 & Flags1::ShowBranchSize) != 0;
	}

	constexpr void FormatterOptions::SetShowBranchSize(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::ShowBranchSize;
		}
		else
		{
			flags1 &= ~Flags1::ShowBranchSize;
		}
	}

	constexpr bool FormatterOptions::GetUsePseudoOps() const
	{
		return (flags1 & Flags1::UsePseudoOps) != 0;
	}

	constexpr void FormatterOptions::SetUsePseudoOps(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::UsePseudoOps;
		}
		else
		{
			flags1 &= ~Flags1::UsePseudoOps;
		}
	}

	constexpr bool FormatterOptions::GetShowSymbolAddress() const
	{
		return (flags1 & Flags1::ShowSymbolAddress) != 0;
	}

	constexpr void FormatterOptions::SetShowSymbolAddress(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::ShowSymbolAddress;
		}
		else
		{
			flags1 &= ~Flags1::ShowSymbolAddress;
		}
	}

	constexpr bool FormatterOptions::GetGasNakedRegisters() const
	{
		return (flags1 & Flags1::GasNakedRegisters) != 0;
	}

	constexpr void FormatterOptions::SetGasNakedRegisters(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::GasNakedRegisters;
		}
		else
		{
			flags1 &= ~Flags1::GasNakedRegisters;
		}
	}

	constexpr bool FormatterOptions::GetGasShowMnemonicSizeSuffix() const
	{
		return (flags1 & Flags1::GasShowMnemonicSizeSuffix) != 0;
	}

	constexpr void FormatterOptions::SetGasShowMnemonicSizeSuffix(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::GasShowMnemonicSizeSuffix;
		}
		else
		{
			flags1 &= ~Flags1::GasShowMnemonicSizeSuffix;
		}
	}

	constexpr bool FormatterOptions::GetGasSpaceAfterMemoryOperandComma() const
	{
		return (flags1 & Flags1::GasSpaceAfterMemoryOperandComma) != 0;
	}

	constexpr void FormatterOptions::SetGasSpaceAfterMemoryOperandComma(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::GasSpaceAfterMemoryOperandComma;
		}
		else
		{
			flags1 &= ~Flags1::GasSpaceAfterMemoryOperandComma;
		}
	}

	constexpr bool FormatterOptions::GetMasmAddDsPrefix32() const
	{
		return (flags1 & Flags1::MasmAddDsPrefix32) != 0;
	}

	constexpr void FormatterOptions::SetMasmAddDsPrefix32(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::MasmAddDsPrefix32;
		}
		else
		{
			flags1 &= ~Flags1::MasmAddDsPrefix32;
		}
	}

	constexpr bool FormatterOptions::GetMasmSymbolDisplInBrackets() const
	{
		return (flags1 & Flags1::MasmSymbolDisplInBrackets) != 0;
	}

	constexpr void FormatterOptions::SetMasmSymbolDisplInBrackets(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::MasmSymbolDisplInBrackets;
		}
		else
		{
			flags1 &= ~Flags1::MasmSymbolDisplInBrackets;
		}
	}

	constexpr bool FormatterOptions::GetMasmDisplInBrackets() const
	{
		return (flags1 & Flags1::MasmDisplInBrackets) != 0;
	}

	constexpr void FormatterOptions::SetMasmDisplInBrackets(bool value)
	{
		if (value)
		{
			flags1 |= Flags1::MasmDisplInBrackets;
		}
		else
		{
			flags1 &= ~Flags1::MasmDisplInBrackets;
		}
	}

	constexpr bool FormatterOptions::GetNasmShowSignExtendedImmediateSize() const
	{
		return (flags2 & Flags2::NasmShowSignExtendedImmediateSize) != 0;
	}

	constexpr void FormatterOptions::SetNasmShowSignExtendedImmediateSize(bool value)
	{
		if (value)
		{
			flags2 |= Flags2::NasmShowSignExtendedImmediateSize;
		}
		else
		{
			flags2 &= ~Flags2::NasmShowSignExtendedImmediateSize;
		}
	}

	constexpr bool FormatterOptions::GetPreferST0() const
	{
		return (flags2 & Flags2::PreferST0) != 0;
	}

	constexpr void FormatterOptions::SetPreferST0(bool value)
	{
		if (value)
		{
			flags2 |= Flags2::PreferST0;
		}
		else
		{
			flags2 &= ~Flags2::PreferST0;
		}
	}

	constexpr bool FormatterOptions::GetShowUselessPrefixes() const
	{
		return (flags2 & Flags2::ShowUselessPrefixes) != 0;
	}

	constexpr void FormatterOptions::SetShowUselessPrefixes(bool value)
	{
		if (value)
		{
			flags2 |= Flags2::ShowUselessPrefixes;
		}
		else
		{
			flags2 &= ~Flags2::ShowUselessPrefixes;
		}
	}

	constexpr Iced::Intel::CC_b FormatterOptions::GetCCB() const
	{
		return cc_b;
	}

	constexpr void FormatterOptions::SetCCB(Iced::Intel::CC_b value)
	{
		if (value >= static_cast<Iced::Intel::CC_b>(3))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_b = value;
	}

	constexpr Iced::Intel::CC_ae FormatterOptions::GetCCAe() const
	{
		return cc_ae;
	}

	constexpr void FormatterOptions::SetCCAe(Iced::Intel::CC_ae value)
	{
		if (value >= static_cast<Iced::Intel::CC_ae>(3))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_ae = value;
	}

	constexpr Iced::Intel::CC_e FormatterOptions::GetCCE() const
	{
		return cc_e;
	}

	constexpr void FormatterOptions::SetCCE(Iced::Intel::CC_e value)
	{
		if (value >= static_cast<Iced::Intel::CC_e>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_e = value;
	}

	constexpr Iced::Intel::CC_ne FormatterOptions::GetCCNe() const
	{
		return cc_ne;
	}

	constexpr void FormatterOptions::SetCCNe(Iced::Intel::CC_ne value)
	{
		if (value >= static_cast<Iced::Intel::CC_ne>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_ne = value;
	}

	constexpr Iced::Intel::CC_be FormatterOptions::GetCCBe() const
	{
		return cc_be;
	}

	constexpr void FormatterOptions::SetCCBe(Iced::Intel::CC_be value)
	{
		if (value >= static_cast<Iced::Intel::CC_be>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_be = value;
	}

	constexpr Iced::Intel::CC_a FormatterOptions::GetCCA() const
	{
		return cc_a;
	}

	constexpr void FormatterOptions::SetCCA(Iced::Intel::CC_a value)
	{
		if (value >= static_cast<Iced::Intel::CC_a>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_a = value;
	}

	constexpr Iced::Intel::CC_p FormatterOptions::GetCCP() const
	{
		return cc_p;
	}

	constexpr void FormatterOptions::SetCCP(Iced::Intel::CC_p value)
	{
		if (value >= static_cast<Iced::Intel::CC_p>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_p = value;
	}

	constexpr Iced::Intel::CC_np FormatterOptions::GetCCNp() const
	{
		return cc_np;
	}

	constexpr void FormatterOptions::SetCCNp(Iced::Intel::CC_np value)
	{
		if (value >= static_cast<Iced::Intel::CC_np>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_np = value;
	}

	constexpr Iced::Intel::CC_l FormatterOptions::GetCCL() const
	{
		return cc_l;
	}

	constexpr void FormatterOptions::SetCCL(Iced::Intel::CC_l value)
	{
		if (value >= static_cast<Iced::Intel::CC_l>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_l = value;
	}

	constexpr Iced::Intel::CC_ge FormatterOptions::GetCCGe() const
	{
		return cc_ge;
	}

	constexpr void FormatterOptions::SetCCGe(Iced::Intel::CC_ge value)
	{
		if (value >= static_cast<Iced::Intel::CC_ge>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_ge = value;
	}

	constexpr Iced::Intel::CC_le FormatterOptions::GetCCLe() const
	{
		return cc_le;
	}

	constexpr void FormatterOptions::SetCCLe(Iced::Intel::CC_le value)
	{
		if (value >= static_cast<Iced::Intel::CC_le>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_le = value;
	}

	constexpr Iced::Intel::CC_g FormatterOptions::GetCCG() const
	{
		return cc_g;
	}

	constexpr void FormatterOptions::SetCCG(Iced::Intel::CC_g value)
	{
		if (value >= static_cast<Iced::Intel::CC_g>(2))
		{
			ThrowHelper::ThrowArgumentOutOfRangeException_value();
		}
		cc_g = value;
	}

	constexpr FormatterOptions FormatterOptions::CreateGas()
	{
		FormatterOptions tempVar = FormatterOptions();
		tempVar.SetHexPrefix("0x");
		tempVar.SetOctalPrefix("0");
		tempVar.SetBinaryPrefix("0b");
		return tempVar;
	}

	constexpr FormatterOptions FormatterOptions::CreateIntel()
	{
		FormatterOptions tempVar = FormatterOptions();
		tempVar.SetHexSuffix("h");
		tempVar.SetOctalSuffix("o");
		tempVar.SetBinarySuffix("b");
		return tempVar;
	}

	constexpr FormatterOptions FormatterOptions::CreateMasm()
	{
		FormatterOptions tempVar = FormatterOptions();
		tempVar.SetHexSuffix("h");
		tempVar.SetOctalSuffix("o");
		tempVar.SetBinarySuffix("b");
		return tempVar;
	}

	constexpr FormatterOptions FormatterOptions::CreateNasm()
	{
		FormatterOptions tempVar = FormatterOptions();
		tempVar.SetHexSuffix("h");
		tempVar.SetOctalSuffix("o");
		tempVar.SetBinarySuffix("b");
		return tempVar;
	}
}