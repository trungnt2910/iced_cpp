// C# helper headers




// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#include "MemorySizes.h"
#include "../Iced.Intel.IcedConstants.h"

using namespace Iced::Intel::FormatterInternal;

namespace Iced::Intel::NasmFormatterInternal
{

	MemorySizes::Info::Info(FormatterString keyword, FormatterString bcstTo)
	{
		this->keyword = keyword;
		this->bcstTo = bcstTo;
	}

	std::vector<MemorySizes::Info> MemorySizes::AllMemorySizes = GetMemorySizes();

	std::vector<MemorySizes::Info> MemorySizes::GetMemorySizes()
	{
		// GENERATOR-BEGIN: ConstData
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		auto byte = FormatterString("byte");
		auto dword = FormatterString("dword");
		auto far = FormatterString("far");
		auto fpuenv14 = FormatterString("fpuenv14");
		auto fpuenv28 = FormatterString("fpuenv28");
		auto fpustate108 = FormatterString("fpustate108");
		auto fpustate94 = FormatterString("fpustate94");
		auto oword = FormatterString("oword");
		auto qword = FormatterString("qword");
		auto tword = FormatterString("tword");
		auto word = FormatterString("word");
		auto yword = FormatterString("yword");
		auto zword = FormatterString("zword");
		auto mem384 = FormatterString("mem384");
		auto empty = FormatterString("");
		auto b1to2 = FormatterString("1to2");
		auto b1to4 = FormatterString("1to4");
		auto b1to8 = FormatterString("1to8");
		auto b1to16 = FormatterString("1to16");
		auto b1to32 = FormatterString("1to32");
		// GENERATOR-END: ConstData
		std::vector<std::uint8_t> bcstToData = { 0x01, 0x01, 0x01, 0x02, 0x01, 0x03, 0x03, 0x02, 0x02, 0x01, 0x01, 0x01, 0x03, 0x02, 0x01, 0x02, 0x01, 0x01, 0x02, 0x02, 0x04, 0x04, 0x03, 0x03, 0x02, 0x02, 0x02, 0x04, 0x03, 0x02, 0x03, 0x02, 0x02, 0x03, 0x03, 0x05, 0x05, 0x04, 0x04, 0x03, 0x03, 0x03, 0x05, 0x04, 0x03, 0x04, 0x04, 0x03, 0x03, 0x04 };
		std::vector<std::uint8_t> data = { 0x00, 0x01, 0x0B, 0x02, 0x09, 0x09, 0x08, 0x0C, 0x0D, 0x01, 0x0B, 0x02, 0x09, 0x08, 0x0C, 0x0D, 0x03, 0x03, 0x03, 0x0B, 0x02, 0x09, 0x00, 0x00, 0x09, 0x08, 0x00, 0x00, 0x0B, 0x02, 0x09, 0x0A, 0x08, 0x0B, 0x04, 0x05, 0x07, 0x06, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x0D, 0x00, 0x0A, 0x0E, 0x0D, 0x0B, 0x0B, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0B, 0x02, 0x02, 0x0B, 0x02, 0x0B, 0x0B, 0x02, 0x02, 0x09, 0x09, 0x09, 0x0B, 0x02, 0x09, 0x02, 0x09, 0x09, 0x02, 0x02, 0x0B, 0x0B, 0x02, 0x02, 0x09, 0x09, 0x09, 0x0B, 0x02, 0x09, 0x02, 0x09, 0x09, 0x02, 0x02, 0x0B, 0x0B, 0x02, 0x02, 0x09, 0x09, 0x09, 0x0B, 0x02, 0x09, 0x02, 0x02, 0x09, 0x09, 0x02 };
		auto infos = std::vector<Info>(IcedConstants::MemorySizeEnumCount);
		for (std::int32_t i = 0; i < infos.size(); i++)
		{
			auto d = data[i];
			auto switchTempVar_0 = d;
			// GENERATOR-BEGIN: MemoryKeywordsSwitch
			// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
			// GENERATOR-END: MemoryKeywordsSwitch

	 //C# TO C++ CONVERTER TODO TASK: Throw expressions are not converted by C# to C++ Converter:
	 //ORIGINAL LINE: var keyword = (switchTempVar_0 == 0x00) ? empty : (switchTempVar_0 == 0x01) ? @byte : (switchTempVar_0 == 0x02) ? dword : (switchTempVar_0 == 0x03) ? far : (switchTempVar_0 == 0x04) ? fpuenv14 : (switchTempVar_0 == 0x05) ? fpuenv28 : (switchTempVar_0 == 0x06) ? fpustate108 : (switchTempVar_0 == 0x07) ? fpustate94 : (switchTempVar_0 == 0x08) ? oword : (switchTempVar_0 == 0x09) ? qword : (switchTempVar_0 == 0x0A) ? tword : (switchTempVar_0 == 0x0B) ? word : (switchTempVar_0 == 0x0C) ? yword : (switchTempVar_0 == 0x0D) ? zword : (switchTempVar_0 == 0x0E) ? mem384 : throw new InvalidOperationException();
			auto keyword = (switchTempVar_0 == 0x00) ? empty : (switchTempVar_0 == 0x01) ? byte : (switchTempVar_0 == 0x02) ? dword : (switchTempVar_0 == 0x03) ? far : (switchTempVar_0 == 0x04) ? fpuenv14 : (switchTempVar_0 == 0x05) ? fpuenv28 : (switchTempVar_0 == 0x06) ? fpustate108 : (switchTempVar_0 == 0x07) ? fpustate94 : (switchTempVar_0 == 0x08) ? oword : (switchTempVar_0 == 0x09) ? qword : (switchTempVar_0 == 0x0A) ? tword : (switchTempVar_0 == 0x0B) ? word : (switchTempVar_0 == 0x0C) ? yword : (switchTempVar_0 == 0x0D) ? zword : (switchTempVar_0 == 0x0E) ? mem384 : throw std::runtime_error("unexpected");
			FormatterString bcstTo;
			if (i < static_cast<std::int32_t>(IcedConstants::FirstBroadcastMemorySize))
			{
				bcstTo = empty;
			}
			else
			{
				auto switchTempVar_1 = (bcstToData[i - static_cast<std::int32_t>(IcedConstants::FirstBroadcastMemorySize)]);
				// GENERATOR-BEGIN: BroadcastToKindSwitch
				// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
				// GENERATOR-END: BroadcastToKindSwitch

		//C# TO C++ CONVERTER TODO TASK: Throw expressions are not converted by C# to C++ Converter:
		//ORIGINAL LINE: bcstTo = (switchTempVar_1 == 0x00) ? empty : (switchTempVar_1 == 0x01) ? b1to2 : (switchTempVar_1 == 0x02) ? b1to4 : (switchTempVar_1 == 0x03) ? b1to8 : (switchTempVar_1 == 0x04) ? b1to16 : (switchTempVar_1 == 0x05) ? b1to32 : throw new InvalidOperationException();
				bcstTo = (switchTempVar_1 == 0x00) ? empty : (switchTempVar_1 == 0x01) ? b1to2 : (switchTempVar_1 == 0x02) ? b1to4 : (switchTempVar_1 == 0x03) ? b1to8 : (switchTempVar_1 == 0x04) ? b1to16 : (switchTempVar_1 == 0x05) ? b1to32 : throw std::runtime_error("unexpected");
			}
			infos[i] = Info(keyword, bcstTo);
		}
		return infos;
	}
}
