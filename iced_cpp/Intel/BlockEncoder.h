// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

#if defined(ENCODER) && defined(BLOCK_ENCODER)
#pragma once

#include "CodeWriter.h"
#include "Iced.Intel.Instruction.h"
#include "ConstantOffsets.h"
#include "BlockEncoderInternal/Block.h"
#include "Encoder.h"
#include "BlockEncoderInternal/Instr.h"
#include "BlockEncoderInternal/TargetInstr.h"
#include "Iced.Intel.IcedConstants.h"
#include <string>
#include <unordered_map>
#include <vector>
#include <limits>
#include <stdexcept>
#include <cassert>

namespace Iced::Intel::BlockEncoderInternal { class Block; class Instr; class TargetInstr; }

namespace Iced::Intel
{
	// GENERATOR-BEGIN: RelocKind
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	enum class RelocKind {
		/// <summary>64-bit offset. Only used if it&apos;s 64-bit code.</summary>
		Offset64  = 0,
	};
	constexpr int operator+(const RelocKind& a, const RelocKind& b) { return ((int)a + (int)b); }
	constexpr int operator+(const RelocKind& a, const int& b) { return ((int)a + b); }
	constexpr int operator+(const int& a, const RelocKind& b) { return (a + (int)b); }
	constexpr int operator-(const RelocKind& a, const RelocKind& b) { return ((int)a - (int)b); }
	constexpr int operator-(const RelocKind& a, const int& b) { return ((int)a - b); }
	constexpr int operator-(const int& a, const RelocKind& b) { return (a - (int)b); }
	constexpr RelocKind operator++(RelocKind& a, int) { auto temp = a; a = RelocKind(a + 1); return temp; }
	constexpr RelocKind& operator++(RelocKind& a) { return a = RelocKind(a + 1); }
	constexpr RelocKind operator--(RelocKind& a, int) { auto temp = a; a = RelocKind(a - 1); return temp; }
	constexpr RelocKind& operator--(RelocKind& a) { return a = RelocKind(a - 1); }
	constexpr bool operator==(const RelocKind& a, const int& b) { return ((int)a == b); }
	constexpr bool operator==(const int& a, const RelocKind& b) { return (a == (int)b); }
	constexpr bool operator>=(const RelocKind& a, const int& b) { return ((int)a >= b); }
	constexpr bool operator>=(const int& a, const RelocKind& b) { return (a >= (int)b); }
	constexpr bool operator<=(const RelocKind& a, const int& b) { return ((int)a <= b); }
	constexpr bool operator<=(const int& a, const RelocKind& b) { return (a <= (int)b); }
	constexpr bool operator>(const RelocKind& a, const int& b) { return ((int)a > b); }
	constexpr bool operator>(const int& a, const RelocKind& b) { return (a > (int)b); }
	constexpr bool operator<(const RelocKind& a, const int& b) { return ((int)a < b); }
	constexpr bool operator<(const int& a, const RelocKind& b) { return (a < (int)b); }
	constexpr bool operator!=(const RelocKind& a, const int& b) { return ((int)a != b); }
	constexpr bool operator!=(const int& a, const RelocKind& b) { return (a != (int)b); }
	// GENERATOR-END: RelocKind
	/// <summary>
	/// Relocation info
	/// </summary>
	class RelocInfo
	{
		/// <summary>
		/// Address
		/// </summary>
	public:
		std::uint64_t Address = 0;
		/// <summary>
		/// Relocation kind
		/// </summary>
		RelocKind Kind = static_cast<RelocKind>(0);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="kind">Relocation kind</param>
		/// <param name="address">Address</param>
		constexpr RelocInfo(RelocKind kind, std::uint64_t address)
			: Address(address), Kind(kind)
		{
		}

		constexpr RelocInfo() = default;
	};
	/// <summary>
	/// Contains a list of instructions that should be encoded by <see cref="BlockEncoder"/>
	/// </summary>
	class InstructionBlock
	{
		/// <summary>
		/// Code writer
		/// </summary>
	public:
		CodeWriter* CodeWriter;
		/// <summary>
		/// All instructions
		/// </summary>
		std::vector<Instruction> Instructions;
		/// <summary>
		/// Base IP of all encoded instructions
		/// </summary>
		std::uint64_t RIP = 0;
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="codeWriter">Code writer</param>
		/// <param name="instructions">Instructions</param>
		/// <param name="rip">Base IP of all encoded instructions</param>
		constexpr InstructionBlock(class CodeWriter* codeWriter, const std::vector<Instruction>& instructions, std::uint64_t rip)
			: CodeWriter(codeWriter), Instructions(instructions), RIP(rip)
		{
		}

		constexpr InstructionBlock() = default;
	};
	/// <summary>
	/// <see cref="BlockEncoder"/> result if it was successful
	/// </summary>
	class BlockEncoderResult
	{
		/// <summary>
		/// Base IP of all encoded instructions
		/// </summary>
	public:
		std::uint64_t RIP = 0;
		/// <summary>
		/// If <see cref="BlockEncoderOptions.ReturnRelocInfos"/> option was enabled:
		/// <br/>
		/// All <see cref="RelocInfo"/>s
		/// </summary>
		std::vector<RelocInfo> RelocInfos;
		/// <summary>
		/// If <see cref="BlockEncoderOptions.ReturnNewInstructionOffsets"/> option was enabled:
		/// <br/>
		/// Offsets of the instructions relative to the base IP. If the instruction was rewritten to a new instruction
		/// (eg. <c>JE TARGET_TOO_FAR_AWAY</c> -> <c>JNE SHORT SKIP ; JMP QWORD PTR [MEM]</c>), the value <see cref="uint.MaxValue"/> is stored in that array element.
		/// </summary>
		std::vector<std::uint32_t> NewInstructionOffsets;
		/// <summary>
		/// If <see cref="BlockEncoderOptions.ReturnConstantOffsets"/> option was enabled:
		/// <br/>
		/// Offsets of all constants in the new encoded instructions. If the instruction was rewritten,
		/// the 'default' value is stored in the corresponding array element.
		/// </summary>
		std::vector<ConstantOffsets> ConstantOffsets;

		constexpr BlockEncoderResult(std::uint64_t rip, const std::vector<RelocInfo>& relocInfos, const std::vector<std::uint32_t>& newInstructionOffsets, const std::vector<class ConstantOffsets>& constantOffsets)
			: RIP(rip), RelocInfos(relocInfos), NewInstructionOffsets(newInstructionOffsets), ConstantOffsets(constantOffsets)
		{
		}

		constexpr BlockEncoderResult() = default;
	};
	// GENERATOR-BEGIN: BlockEncoderOptions
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	enum class BlockEncoderOptions {
		/// <summary>No option is set</summary>
		None  = 0x00000000,
		/// <summary>By default, branches get updated if the target is too far away, eg. <c>Jcc SHORT</c> -&gt; <c>Jcc NEAR</c> or if 64-bit mode, <c>Jcc + JMP [RIP+mem]</c>. If this option is enabled, no branches are fixed.</summary>
		DontFixBranches  = 0x00000001,
		/// <summary>The <see cref="BlockEncoder"/> should return <see cref="RelocInfo"/>s</summary>
		ReturnRelocInfos  = 0x00000002,
		/// <summary>The <see cref="BlockEncoder"/> should return new instruction offsets</summary>
		ReturnNewInstructionOffsets  = 0x00000004,
		/// <summary>The <see cref="BlockEncoder"/> should return <see cref="ConstantOffsets"/></summary>
		ReturnConstantOffsets  = 0x00000008,
	};
	constexpr BlockEncoderOptions& operator^=(BlockEncoderOptions& a, const BlockEncoderOptions& b) { return a = (BlockEncoderOptions)((int)a ^ (int)b); }
	constexpr BlockEncoderOptions operator^(const BlockEncoderOptions& a, const BlockEncoderOptions& b) { return (BlockEncoderOptions)((int)a ^ (int)b); }
	constexpr BlockEncoderOptions& operator|=(BlockEncoderOptions& a, const BlockEncoderOptions& b) { return a = (BlockEncoderOptions)((int)a | (int)b); }
	constexpr BlockEncoderOptions operator|(const BlockEncoderOptions& a, const BlockEncoderOptions& b) { return (BlockEncoderOptions)((int)a | (int)b); }
	constexpr BlockEncoderOptions& operator&=(BlockEncoderOptions& a, const BlockEncoderOptions& b) { return a = (BlockEncoderOptions)((int)a & (int)b); }
	constexpr BlockEncoderOptions operator&(const BlockEncoderOptions& a, const BlockEncoderOptions& b) { return (BlockEncoderOptions)((int)a & (int)b); }
	constexpr BlockEncoderOptions operator~(const BlockEncoderOptions& a) { return (BlockEncoderOptions)(~((int)a)); }
	constexpr int operator+(const BlockEncoderOptions& a, const BlockEncoderOptions& b) { return ((int)a + (int)b); }
	constexpr int operator+(const BlockEncoderOptions& a, const int& b) { return ((int)a + b); }
	constexpr int operator+(const int& a, const BlockEncoderOptions& b) { return (a + (int)b); }
	constexpr int operator-(const BlockEncoderOptions& a, const BlockEncoderOptions& b) { return ((int)a - (int)b); }
	constexpr int operator-(const BlockEncoderOptions& a, const int& b) { return ((int)a - b); }
	constexpr int operator-(const int& a, const BlockEncoderOptions& b) { return (a - (int)b); }
	constexpr BlockEncoderOptions operator++(BlockEncoderOptions& a, int) { auto temp = a; a = BlockEncoderOptions(a + 1); return temp; }
	constexpr BlockEncoderOptions& operator++(BlockEncoderOptions& a) { return a = BlockEncoderOptions(a + 1); }
	constexpr BlockEncoderOptions operator--(BlockEncoderOptions& a, int) { auto temp = a; a = BlockEncoderOptions(a - 1); return temp; }
	constexpr BlockEncoderOptions& operator--(BlockEncoderOptions& a) { return a = BlockEncoderOptions(a - 1); }
	constexpr bool operator==(const BlockEncoderOptions& a, const int& b) { return ((int)a == b); }
	constexpr bool operator==(const int& a, const BlockEncoderOptions& b) { return (a == (int)b); }
	constexpr bool operator>=(const BlockEncoderOptions& a, const int& b) { return ((int)a >= b); }
	constexpr bool operator>=(const int& a, const BlockEncoderOptions& b) { return (a >= (int)b); }
	constexpr bool operator<=(const BlockEncoderOptions& a, const int& b) { return ((int)a <= b); }
	constexpr bool operator<=(const int& a, const BlockEncoderOptions& b) { return (a <= (int)b); }
	constexpr bool operator>(const BlockEncoderOptions& a, const int& b) { return ((int)a > b); }
	constexpr bool operator>(const int& a, const BlockEncoderOptions& b) { return (a > (int)b); }
	constexpr bool operator<(const BlockEncoderOptions& a, const int& b) { return ((int)a < b); }
	constexpr bool operator<(const int& a, const BlockEncoderOptions& b) { return (a < (int)b); }
	constexpr bool operator!=(const BlockEncoderOptions& a, const int& b) { return ((int)a != b); }
	constexpr bool operator!=(const int& a, const BlockEncoderOptions& b) { return (a != (int)b); }
	// GENERATOR-END: BlockEncoderOptions
	/// <summary>
	/// Encodes instructions. It can be used to move instructions from one location to another location.
	/// </summary>
	class BlockEncoder final
	{
	private:
		std::int32_t bitness = 0;
		BlockEncoderOptions options = static_cast<BlockEncoderOptions>(0);
		std::vector<std::shared_ptr<Iced::Intel::BlockEncoderInternal::Block>> blocks;
		Encoder nullEncoder;
		std::unordered_map<std::uint64_t, std::shared_ptr<Iced::Intel::BlockEncoderInternal::Instr>> toInstr;
	public:
		constexpr std::int32_t GetBitness() const;
		constexpr bool GetFixBranches() const;
	private:
		constexpr bool GetReturnRelocInfos() const
		{
			return (options & BlockEncoderOptions::ReturnRelocInfos) != 0;
		};
		constexpr bool GetReturnNewInstructionOffsets() const
		{
			return (options & BlockEncoderOptions::ReturnNewInstructionOffsets) != 0;
		};
		constexpr bool GetReturnConstantOffsets() const
		{
			return (options & BlockEncoderOptions::ReturnConstantOffsets) != 0;
		};
	private:
		class NullCodeWriter;
		class NullCodeWriterInternal : public CodeWriter
		{
		private:
			friend class NullCodeWriter;
			constexpr NullCodeWriterInternal() = default;
			constexpr void WriteByte(std::uint8_t value) override
			{
			}
		};
		class NullCodeWriter final: public NullCodeWriterInternal
		{
		private:
			inline static constexpr NullCodeWriterInternal instance = NullCodeWriterInternal();
		public:
			inline static constexpr CodeWriter* Instance = (CodeWriter*)&instance;
			constexpr NullCodeWriter() = default;
		};
	private:
		BlockEncoder(std::int32_t bitness, const std::vector<InstructionBlock>& instrBlocks, BlockEncoderOptions options);
		/// <summary>
		/// Encodes instructions. Any number of branches can be part of this block.
		/// You can use this function to move instructions from one location to another location.
		/// If the target of a branch is too far away, it'll be rewritten to a longer branch.
		/// You can disable this by passing in <see cref="BlockEncoderOptions.DontFixBranches"/>.
		/// If the block has any <c>RIP</c>-relative memory operands, make sure the data isn't too
		/// far away from the new location of the encoded instructions. Every OS should have
		/// some API to allocate memory close (+/-2GB) to the original code location.
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="block">All instructions</param>
		/// <param name="errorMessage">Updated with an error message if the method failed</param>
		/// <param name="result">Result if this method returns <see langword="true"/></param>
		/// <param name="options">Encoder options</param>
		/// <returns></returns>
	public:
		static bool TryEncode(std::int32_t bitness, InstructionBlock block, std::string& errorMessage, BlockEncoderResult& result, BlockEncoderOptions options = BlockEncoderOptions::None);
		/// <summary>
		/// Encodes instructions. Any number of branches can be part of this block.
		/// You can use this function to move instructions from one location to another location.
		/// If the target of a branch is too far away, it'll be rewritten to a longer branch.
		/// You can disable this by passing in <see cref="BlockEncoderOptions.DontFixBranches"/>.
		/// If the block has any <c>RIP</c>-relative memory operands, make sure the data isn't too
		/// far away from the new location of the encoded instructions. Every OS should have
		/// some API to allocate memory close (+/-2GB) to the original code location.
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="blocks">All instructions</param>
		/// <param name="errorMessage">Updated with an error message if the method failed</param>
		/// <param name="result">Result if this method returns <see langword="true"/></param>
		/// <param name="options">Encoder options</param>
		/// <returns></returns>
		static bool TryEncode(std::int32_t bitness, const std::vector<InstructionBlock>& blocks, std::string& errorMessage, std::vector<BlockEncoderResult>& result, BlockEncoderOptions options = BlockEncoderOptions::None);
	private:
		bool Encode(std::string& errorMessage, std::vector<BlockEncoderResult>& result);
	public:
		Iced::Intel::BlockEncoderInternal::TargetInstr GetTarget(std::uint64_t address);
		std::uint32_t GetInstructionSize(const Instruction& instruction, std::uint64_t ip);
	};

	constexpr std::int32_t BlockEncoder::GetBitness() const
	{
		return bitness;
	}

	constexpr bool BlockEncoder::GetFixBranches() const
	{
		return (options & BlockEncoderOptions::DontFixBranches) == 0;
	}
}
#endif
