// C# helper headers
#include <csharp/classes.h>
#include <csharp/enum.h>



// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#pragma once

#include "CodeWriter.h"
#include "Iced.Intel.Instruction.h"
#include "ConstantOffsets.h"
#include "BlockEncoderInternal/Block.h"
#include "Encoder.h"
#include "BlockEncoderInternal/Instr.h"
#include "BlockEncoderInternal/TargetInstr.h"
#include <string>
#include <unordered_map>
#include <vector>
#include <limits>
#include <stdexcept>
#include <format>
#include <csharp/exceptionhelper.h>
#include <cassert>

namespace Iced::Intel::BlockEncoderInternal { class Block; class Instr; class TargetInstr; }

// Code generated from Iced. Do not edit.
// Commit tag: badb6147c0994a4954fa27645aba2b02c2bb9502.
// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors
namespace Iced::Intel
{
	// GENERATOR-BEGIN: RelocKind
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	/// <summary>Relocation kind</summary>
	enum class RelocKind
	{
		/// <summary>64-bit offset. Only used if it&apos;s 64-bit code.</summary>
		Offset64 = 0
	};

	DEFINE_COMP(RelocKind)
		DEFINE_ARITH(RelocKind)

		// GENERATOR-END: RelocKind
		/// <summary>
		/// Relocation info
		/// </summary>
		class RelocInfo
	{
		/// <summary>
		/// Address
		/// </summary>
	public:
		std::uint64_t Address = 0;
		/// <summary>
		/// Relocation kind
		/// </summary>
		RelocKind Kind = static_cast<RelocKind>(0);
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="kind">Relocation kind</param>
		/// <param name="address">Address</param>
		RelocInfo(RelocKind kind, std::uint64_t address);

		RelocInfo() = default;
	};
	/// <summary>
	/// Contains a list of instructions that should be encoded by <see cref="BlockEncoder"/>
	/// </summary>
	class InstructionBlock
	{
		/// <summary>
		/// Code writer
		/// </summary>
	public:
		CodeWriter* CodeWriter;
		/// <summary>
		/// All instructions
		/// </summary>
		std::vector<Instruction> Instructions;
		/// <summary>
		/// Base IP of all encoded instructions
		/// </summary>
		std::uint64_t RIP = 0;
		/// <summary>
		/// Constructor
		/// </summary>
		/// <param name="codeWriter">Code writer</param>
		/// <param name="instructions">Instructions</param>
		/// <param name="rip">Base IP of all encoded instructions</param>
		InstructionBlock(class CodeWriter* codeWriter, const std::vector<Instruction>& instructions, std::uint64_t rip);

		InstructionBlock() = default;
	};
	/// <summary>
	/// <see cref="BlockEncoder"/> result if it was successful
	/// </summary>
	class BlockEncoderResult
	{
		/// <summary>
		/// Base IP of all encoded instructions
		/// </summary>
	public:
		std::uint64_t RIP = 0;
		/// <summary>
		/// If <see cref="BlockEncoderOptions.ReturnRelocInfos"/> option was enabled:
		/// <br/>
		/// All <see cref="RelocInfo"/>s
		/// </summary>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public List<RelocInfo>? RelocInfos;
		std::vector<RelocInfo> RelocInfos;
		/// <summary>
		/// If <see cref="BlockEncoderOptions.ReturnNewInstructionOffsets"/> option was enabled:
		/// <br/>
		/// Offsets of the instructions relative to the base IP. If the instruction was rewritten to a new instruction
		/// (eg. <c>JE TARGET_TOO_FAR_AWAY</c> -> <c>JNE SHORT SKIP ; JMP QWORD PTR [MEM]</c>), the value <see cref="uint.MaxValue"/> is stored in that array element.
		/// </summary>
		std::vector<std::uint32_t> NewInstructionOffsets;
		/// <summary>
		/// If <see cref="BlockEncoderOptions.ReturnConstantOffsets"/> option was enabled:
		/// <br/>
		/// Offsets of all constants in the new encoded instructions. If the instruction was rewritten,
		/// the 'default' value is stored in the corresponding array element.
		/// </summary>
		std::vector<ConstantOffsets> ConstantOffsets;
		//C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
		//ORIGINAL LINE: internal BlockEncoderResult(ulong rip, List<RelocInfo>? relocInfos, uint[]? newInstructionOffsets, ConstantOffsets[]? constantOffsets)
		BlockEncoderResult(std::uint64_t rip, const std::vector<RelocInfo>& relocInfos, const std::vector<std::uint32_t>& newInstructionOffsets, const std::vector<class ConstantOffsets>& constantOffsets);

		BlockEncoderResult() = default;
	};
	// GENERATOR-BEGIN: BlockEncoderOptions
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	/// <summary><see cref="BlockEncoder"/> options</summary>
	enum class BlockEncoderOptions
	{
		/// <summary>No option is set</summary>
		None = 0x00000000,
		/// <summary>By default, branches get updated if the target is too far away, eg. <c>Jcc SHORT</c> -&gt; <c>Jcc NEAR</c> or if 64-bit mode, <c>Jcc + JMP [RIP+mem]</c>. If this option is enabled, no branches are fixed.</summary>
		DontFixBranches = 0x00000001,
		/// <summary>The <see cref="BlockEncoder"/> should return <see cref="RelocInfo"/>s</summary>
		ReturnRelocInfos = 0x00000002,
		/// <summary>The <see cref="BlockEncoder"/> should return new instruction offsets</summary>
		ReturnNewInstructionOffsets = 0x00000004,
		/// <summary>The <see cref="BlockEncoder"/> should return <see cref="ConstantOffsets"/></summary>
		ReturnConstantOffsets = 0x00000008
	};
	DEFINE_FLAGS(BlockEncoderOptions)
		DEFINE_COMP(BlockEncoderOptions)
		DEFINE_ARITH(BlockEncoderOptions)

		// GENERATOR-END: BlockEncoderOptions
		/// <summary>
		/// Encodes instructions. It can be used to move instructions from one location to another location.
		/// </summary>
		class BlockEncoder final
	{
		/* readonly */
	private:
		std::int32_t bitness = 0;
		/* readonly */
		BlockEncoderOptions options = static_cast<BlockEncoderOptions>(0);
		/* readonly */
		std::vector<std::shared_ptr<Iced::Intel::BlockEncoderInternal::Block>> blocks;
		/* readonly */
		Encoder nullEncoder;
		/* readonly */
		std::unordered_map<std::uint64_t, std::shared_ptr<Iced::Intel::BlockEncoderInternal::Instr>> toInstr;
	public:
		std::int32_t GetBitness() const;
		bool GetFixBranches() const;
	private:
		bool GetReturnRelocInfos() const
		{
			return (options & BlockEncoderOptions::ReturnRelocInfos) != 0;
		};
		bool GetReturnNewInstructionOffsets() const
		{
			return (options & BlockEncoderOptions::ReturnNewInstructionOffsets) != 0;
		};
		bool GetReturnConstantOffsets() const
		{
			return (options & BlockEncoderOptions::ReturnConstantOffsets) != 0;
		};
	private:
		class NullCodeWriter final : public CodeWriter
		{
		public:
			static NullCodeWriter* Instance;
		private:
			NullCodeWriter();
		public:
			void WriteByte(std::uint8_t value) override;
		};
	private:
		BlockEncoder(std::int32_t bitness, const std::vector<InstructionBlock>& instrBlocks, BlockEncoderOptions options);
		/// <summary>
		/// Encodes instructions. Any number of branches can be part of this block.
		/// You can use this function to move instructions from one location to another location.
		/// If the target of a branch is too far away, it'll be rewritten to a longer branch.
		/// You can disable this by passing in <see cref="BlockEncoderOptions.DontFixBranches"/>.
		/// If the block has any <c>RIP</c>-relative memory operands, make sure the data isn't too
		/// far away from the new location of the encoded instructions. Every OS should have
		/// some API to allocate memory close (+/-2GB) to the original code location.
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="block">All instructions</param>
		/// <param name="errorMessage">Updated with an error message if the method failed</param>
		/// <param name="result">Result if this method returns <see langword="true"/></param>
		/// <param name="options">Encoder options</param>
		/// <returns></returns>
	public:
		//C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
		//ORIGINAL LINE: public static bool TryEncode(int bitness, InstructionBlock block, [NotNullWhen(false)] out string? errorMessage, out BlockEncoderResult result, BlockEncoderOptions options = BlockEncoderOptions.None)
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		static bool TryEncode(std::int32_t bitness, InstructionBlock block, std::string& errorMessage, BlockEncoderResult& result, BlockEncoderOptions options = BlockEncoderOptions::None);
		/// <summary>
		/// Encodes instructions. Any number of branches can be part of this block.
		/// You can use this function to move instructions from one location to another location.
		/// If the target of a branch is too far away, it'll be rewritten to a longer branch.
		/// You can disable this by passing in <see cref="BlockEncoderOptions.DontFixBranches"/>.
		/// If the block has any <c>RIP</c>-relative memory operands, make sure the data isn't too
		/// far away from the new location of the encoded instructions. Every OS should have
		/// some API to allocate memory close (+/-2GB) to the original code location.
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="blocks">All instructions</param>
		/// <param name="errorMessage">Updated with an error message if the method failed</param>
		/// <param name="result">Result if this method returns <see langword="true"/></param>
		/// <param name="options">Encoder options</param>
		/// <returns></returns>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public static bool TryEncode(int bitness, InstructionBlock[] blocks, [NotNullWhen(false)] out string? errorMessage, [NotNullWhen(true)] out BlockEncoderResult[]? result, BlockEncoderOptions options = BlockEncoderOptions.None)
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		static bool TryEncode(std::int32_t bitness, const std::vector<InstructionBlock>& blocks, std::string& errorMessage, std::vector<BlockEncoderResult> &result, BlockEncoderOptions options = BlockEncoderOptions::None);
	private:
		//C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
		//ORIGINAL LINE: bool Encode([NotNullWhen(false)] out string? errorMessage, [NotNullWhen(true)] out BlockEncoderResult[]? result)
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		bool Encode(std::string& errorMessage, std::vector<BlockEncoderResult> &result);
	public:
		Iced::Intel::BlockEncoderInternal::TargetInstr GetTarget(std::uint64_t address);
		std::uint32_t GetInstructionSize(const Instruction& instruction, std::uint64_t ip);
	};
}
