// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

#if defined(GAS) || defined(INTEL) || defined(MASM) || defined(NASM)
#pragma once

#include "../Code.g.h"
#include "../CodeSize.g.h"
#include "../Register.g.h"
#include "../Iced.Intel.Instruction.h"
#include "../FormatterOutput.h"
#include "../FormatterOptions.h"
#include "../Static.h"
#include "../CodeExtensions.h"
#include "../FormatterTextKind.g.h"

#include <array>
#include <string>
#include <string_view>
#include <cassert>

namespace Iced::Intel::FormatterInternal
{
	// GENERATOR-BEGIN: FormatterFlowControl
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	enum class FormatterFlowControl {
		AlwaysShortBranch ,
		ShortBranch ,
		NearBranch ,
		NearCall ,
		FarBranch ,
		FarCall ,
		Xbegin ,
	};
	constexpr int operator+(const FormatterFlowControl& a, const FormatterFlowControl& b) { return ((int)a + (int)b); }
	constexpr int operator+(const FormatterFlowControl& a, const int& b) { return ((int)a + b); }
	constexpr int operator+(const int& a, const FormatterFlowControl& b) { return (a + (int)b); }
	constexpr int operator-(const FormatterFlowControl& a, const FormatterFlowControl& b) { return ((int)a - (int)b); }
	constexpr int operator-(const FormatterFlowControl& a, const int& b) { return ((int)a - b); }
	constexpr int operator-(const int& a, const FormatterFlowControl& b) { return (a - (int)b); }
	constexpr FormatterFlowControl operator++(FormatterFlowControl& a, int) { auto temp = a; a = FormatterFlowControl(a + 1); return temp; }
	constexpr FormatterFlowControl& operator++(FormatterFlowControl& a) { return a = FormatterFlowControl(a + 1); }
	constexpr FormatterFlowControl operator--(FormatterFlowControl& a, int) { auto temp = a; a = FormatterFlowControl(a - 1); return temp; }
	constexpr FormatterFlowControl& operator--(FormatterFlowControl& a) { return a = FormatterFlowControl(a - 1); }
	constexpr bool operator==(const FormatterFlowControl& a, const int& b) { return ((int)a == b); }
	constexpr bool operator==(const int& a, const FormatterFlowControl& b) { return (a == (int)b); }
	constexpr bool operator>=(const FormatterFlowControl& a, const int& b) { return ((int)a >= b); }
	constexpr bool operator>=(const int& a, const FormatterFlowControl& b) { return (a >= (int)b); }
	constexpr bool operator<=(const FormatterFlowControl& a, const int& b) { return ((int)a <= b); }
	constexpr bool operator<=(const int& a, const FormatterFlowControl& b) { return (a <= (int)b); }
	constexpr bool operator>(const FormatterFlowControl& a, const int& b) { return ((int)a > b); }
	constexpr bool operator>(const int& a, const FormatterFlowControl& b) { return (a > (int)b); }
	constexpr bool operator<(const FormatterFlowControl& a, const int& b) { return ((int)a < b); }
	constexpr bool operator<(const int& a, const FormatterFlowControl& b) { return (a < (int)b); }
	constexpr bool operator!=(const FormatterFlowControl& a, const int& b) { return ((int)a != b); }
	constexpr bool operator!=(const int& a, const FormatterFlowControl& b) { return (a != (int)b); }
	// GENERATOR-END: FormatterFlowControl

	namespace
	{
		template <std::size_t N>
		constexpr auto CreateString(char ch)
		{
			auto result = std::array<char, N + 1>();
			result[N] = '\0';

			for (int i = 0; i < N; ++i)
			{
				result[i] = ch;
			}

			return result;
		}

		template <std::size_t N>
		constexpr auto CreateStrings(const std::array<char, N + 1>& arr)
		{
			auto result = std::array<std::string_view, N>();
			for (std::size_t i = 0, j = N - 1; i < N; ++i, --j)
			{
				result[i] = std::string_view(arr.data() + j);
			}

			return result;
		}
	}

	class FormatterUtils final
	{
#include "FormatterUtils.All.h"
	private:
		inline static constexpr std::array spaceString = CreateString<20>(' ');
		inline static constexpr std::array tabString = CreateString<6>('\t');

		inline static constexpr std::array spaceStrings = CreateStrings<20>(spaceString);
		inline static constexpr std::array tabStrings = CreateStrings<6>(tabString);

	public:
		static constexpr void AddTabs(FormatterOutput& output, std::int32_t column, std::int32_t firstOperandCharIndex, std::int32_t tabSize);
	private:
		template <std::size_t N>
		static constexpr void AddStrings(FormatterOutput& output, const std::array<std::string_view, N>& strings, std::int32_t count);
	public:
		static constexpr bool IsCall(FormatterFlowControl kind);
		static constexpr FormatterFlowControl GetFlowControl(const Instruction& instruction);
		static constexpr bool ShowRepOrRepePrefix(Code code, const FormatterOptions& options);
		static constexpr bool ShowRepnePrefix(Code code, const FormatterOptions& options);
		static constexpr PrefixKind GetSegmentRegisterPrefixKind(Register register_);
		static constexpr bool ShowIndexScale(const Instruction& instruction, const FormatterOptions& options);
		static constexpr bool ShowSegmentPrefix(Register defaultSegReg, const Instruction& instruction, const FormatterOptions& options);
		static constexpr bool CanShowRoundingControl(const Instruction& instruction, const FormatterOptions& options);
	};
}

namespace Iced::Intel::FormatterInternal
{
	constexpr void FormatterUtils::AddTabs(FormatterOutput& output, std::int32_t column, std::int32_t firstOperandCharIndex, std::int32_t tabSize)
	{
		constexpr std::int32_t max_firstOperandCharIndex = 256;
		if (firstOperandCharIndex < 0)
		{
			firstOperandCharIndex = 0;
		}
		else if (firstOperandCharIndex > max_firstOperandCharIndex)
		{
			firstOperandCharIndex = max_firstOperandCharIndex;
		}
		if (tabSize <= 0)
		{
			std::int32_t charsLeft = firstOperandCharIndex - column;
			if (charsLeft <= 0)
			{
				charsLeft = 1;
			}
			AddStrings(output, spaceStrings, charsLeft);
		}
		else
		{
			std::int32_t endCol = firstOperandCharIndex;
			if (endCol <= column)
			{
				endCol = column + 1;
			}
			std::int32_t endColRoundedDown = endCol / tabSize * tabSize;
			bool addedTabs = endColRoundedDown > column;
			if (addedTabs)
			{
				std::int32_t tabs = (endColRoundedDown - (column / tabSize * tabSize)) / tabSize;
				AddStrings(output, tabStrings, tabs);
				column = endColRoundedDown;
			}
			std::int32_t spaces = firstOperandCharIndex - column;
			if (spaces > 0)
			{
				AddStrings(output, spaceStrings, spaces);
			}
			else if (!addedTabs)
			{
				AddStrings(output, spaceStrings, 1);
			}
		}
	}

	template <std::size_t N>
	constexpr void FormatterUtils::AddStrings(FormatterOutput& output, const std::array<std::string_view, N>& strings, std::int32_t count)
	{
		while (count > 0)
		{
			std::int32_t n = count;
			if (n >= strings.size())
			{
				n = (std::int32_t)strings.size();
			}
			output.Write(strings[n - 1], FormatterTextKind::Text);
			count -= n;
		}
	}

	constexpr bool FormatterUtils::IsCall(FormatterFlowControl kind)
	{
		return kind == FormatterFlowControl::NearCall || kind == FormatterFlowControl::FarCall;
	}

	constexpr FormatterFlowControl FormatterUtils::GetFlowControl(const Instruction& instruction)
	{
		switch (instruction.GetCode())
		{
			// GENERATOR-BEGIN: FormatterFlowControlSwitch
			// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		case Code::Jo_rel8_16:
		case Code::Jo_rel8_32:
		case Code::Jo_rel8_64:
		case Code::Jno_rel8_16:
		case Code::Jno_rel8_32:
		case Code::Jno_rel8_64:
		case Code::Jb_rel8_16:
		case Code::Jb_rel8_32:
		case Code::Jb_rel8_64:
		case Code::Jae_rel8_16:
		case Code::Jae_rel8_32:
		case Code::Jae_rel8_64:
		case Code::Je_rel8_16:
		case Code::Je_rel8_32:
		case Code::Je_rel8_64:
		case Code::Jne_rel8_16:
		case Code::Jne_rel8_32:
		case Code::Jne_rel8_64:
		case Code::Jbe_rel8_16:
		case Code::Jbe_rel8_32:
		case Code::Jbe_rel8_64:
		case Code::Ja_rel8_16:
		case Code::Ja_rel8_32:
		case Code::Ja_rel8_64:
		case Code::Js_rel8_16:
		case Code::Js_rel8_32:
		case Code::Js_rel8_64:
		case Code::Jns_rel8_16:
		case Code::Jns_rel8_32:
		case Code::Jns_rel8_64:
		case Code::Jp_rel8_16:
		case Code::Jp_rel8_32:
		case Code::Jp_rel8_64:
		case Code::Jnp_rel8_16:
		case Code::Jnp_rel8_32:
		case Code::Jnp_rel8_64:
		case Code::Jl_rel8_16:
		case Code::Jl_rel8_32:
		case Code::Jl_rel8_64:
		case Code::Jge_rel8_16:
		case Code::Jge_rel8_32:
		case Code::Jge_rel8_64:
		case Code::Jle_rel8_16:
		case Code::Jle_rel8_32:
		case Code::Jle_rel8_64:
		case Code::Jg_rel8_16:
		case Code::Jg_rel8_32:
		case Code::Jg_rel8_64:
		case Code::Jmp_rel8_16:
		case Code::Jmp_rel8_32:
		case Code::Jmp_rel8_64:
		case Code::VEX_KNC_Jkzd_kr_rel8_64:
		case Code::VEX_KNC_Jknzd_kr_rel8_64:
			return FormatterFlowControl::ShortBranch;
		case Code::Loopne_rel8_16_CX:
		case Code::Loopne_rel8_32_CX:
		case Code::Loopne_rel8_16_ECX:
		case Code::Loopne_rel8_32_ECX:
		case Code::Loopne_rel8_64_ECX:
		case Code::Loopne_rel8_16_RCX:
		case Code::Loopne_rel8_64_RCX:
		case Code::Loope_rel8_16_CX:
		case Code::Loope_rel8_32_CX:
		case Code::Loope_rel8_16_ECX:
		case Code::Loope_rel8_32_ECX:
		case Code::Loope_rel8_64_ECX:
		case Code::Loope_rel8_16_RCX:
		case Code::Loope_rel8_64_RCX:
		case Code::Loop_rel8_16_CX:
		case Code::Loop_rel8_32_CX:
		case Code::Loop_rel8_16_ECX:
		case Code::Loop_rel8_32_ECX:
		case Code::Loop_rel8_64_ECX:
		case Code::Loop_rel8_16_RCX:
		case Code::Loop_rel8_64_RCX:
		case Code::Jcxz_rel8_16:
		case Code::Jcxz_rel8_32:
		case Code::Jecxz_rel8_16:
		case Code::Jecxz_rel8_32:
		case Code::Jecxz_rel8_64:
		case Code::Jrcxz_rel8_16:
		case Code::Jrcxz_rel8_64:
			return FormatterFlowControl::AlwaysShortBranch;
		case Code::Call_rel16:
		case Code::Call_rel32_32:
		case Code::Call_rel32_64:
			return FormatterFlowControl::NearCall;
		case Code::Jmp_rel16:
		case Code::Jmp_rel32_32:
		case Code::Jmp_rel32_64:
		case Code::Jo_rel16:
		case Code::Jo_rel32_32:
		case Code::Jo_rel32_64:
		case Code::Jno_rel16:
		case Code::Jno_rel32_32:
		case Code::Jno_rel32_64:
		case Code::Jb_rel16:
		case Code::Jb_rel32_32:
		case Code::Jb_rel32_64:
		case Code::Jae_rel16:
		case Code::Jae_rel32_32:
		case Code::Jae_rel32_64:
		case Code::Je_rel16:
		case Code::Je_rel32_32:
		case Code::Je_rel32_64:
		case Code::Jne_rel16:
		case Code::Jne_rel32_32:
		case Code::Jne_rel32_64:
		case Code::Jbe_rel16:
		case Code::Jbe_rel32_32:
		case Code::Jbe_rel32_64:
		case Code::Ja_rel16:
		case Code::Ja_rel32_32:
		case Code::Ja_rel32_64:
		case Code::Js_rel16:
		case Code::Js_rel32_32:
		case Code::Js_rel32_64:
		case Code::Jns_rel16:
		case Code::Jns_rel32_32:
		case Code::Jns_rel32_64:
		case Code::Jp_rel16:
		case Code::Jp_rel32_32:
		case Code::Jp_rel32_64:
		case Code::Jnp_rel16:
		case Code::Jnp_rel32_32:
		case Code::Jnp_rel32_64:
		case Code::Jl_rel16:
		case Code::Jl_rel32_32:
		case Code::Jl_rel32_64:
		case Code::Jge_rel16:
		case Code::Jge_rel32_32:
		case Code::Jge_rel32_64:
		case Code::Jle_rel16:
		case Code::Jle_rel32_32:
		case Code::Jle_rel32_64:
		case Code::Jg_rel16:
		case Code::Jg_rel32_32:
		case Code::Jg_rel32_64:
		case Code::Jmpe_disp16:
		case Code::Jmpe_disp32:
		case Code::VEX_KNC_Jkzd_kr_rel32_64:
		case Code::VEX_KNC_Jknzd_kr_rel32_64:
			return FormatterFlowControl::NearBranch;
		case Code::Call_ptr1616:
		case Code::Call_ptr1632:
			return FormatterFlowControl::FarCall;
		case Code::Jmp_ptr1616:
		case Code::Jmp_ptr1632:
			return FormatterFlowControl::FarBranch;
		case Code::Xbegin_rel16:
		case Code::Xbegin_rel32:
			return FormatterFlowControl::Xbegin;
			// GENERATOR-END: FormatterFlowControlSwitch
		default:
			throw std::runtime_error("invalid operation");
		}
	}

	constexpr bool FormatterUtils::ShowRepOrRepePrefix(Code code, const FormatterOptions& options)
	{
		return ShowRepOrRepePrefix(code, options.GetShowUselessPrefixes());
	}

	constexpr bool FormatterUtils::ShowRepnePrefix(Code code, const FormatterOptions& options)
	{
		return ShowRepnePrefix(code, options.GetShowUselessPrefixes());
	}

	constexpr Iced::Intel::PrefixKind FormatterUtils::GetSegmentRegisterPrefixKind(Register register_)
	{
		assert(register_ == Register::ES || register_ == Register::CS || register_ == Register::SS || register_ == Register::DS || register_ == Register::FS || register_ == Register::GS);
		Static::Assert(PrefixKind::ES + 1 == PrefixKind::CS ? 0 : -1);
		Static::Assert(PrefixKind::ES + 2 == PrefixKind::SS ? 0 : -1);
		Static::Assert(PrefixKind::ES + 3 == PrefixKind::DS ? 0 : -1);
		Static::Assert(PrefixKind::ES + 4 == PrefixKind::FS ? 0 : -1);
		Static::Assert(PrefixKind::ES + 5 == PrefixKind::GS ? 0 : -1);
		return (PrefixKind)((register_ - Register::ES) + PrefixKind::ES);
	}

	constexpr bool FormatterUtils::ShowIndexScale(const Instruction& instruction, const FormatterOptions& options)
	{
		return options.GetShowUselessPrefixes() || !Iced::Intel::CodeExtensions::IgnoresIndex(instruction.GetCode());
	}

	constexpr bool FormatterUtils::ShowSegmentPrefix(Register defaultSegReg, const Instruction& instruction, const FormatterOptions& options)
	{
		return ShowSegmentPrefix(defaultSegReg, instruction, options.GetShowUselessPrefixes());
	}

	constexpr bool FormatterUtils::CanShowRoundingControl(const Instruction& instruction, const FormatterOptions& options)
	{
		switch (instruction.GetCode())
		{
		case Code::EVEX_Vcvtsi2sd_xmm_xmm_rm32_er:
		case Code::EVEX_Vcvtusi2sd_xmm_xmm_rm32_er:
		case Code::EVEX_Vcvtdq2pd_zmm_k1z_ymmm256b32_er:
		case Code::EVEX_Vcvtudq2pd_zmm_k1z_ymmm256b32_er:
			return options.GetShowUselessPrefixes();
		default:
			return true;
		}
	}
}
#elif defined(FAST_FMT)
#pragma once

#include "../Code.g.h"
#include "../CodeSize.g.h"
#include "../Register.g.h"
#include "../Iced.Intel.Instruction.h"
#include "../FormatterOutput.h"
#include "../FormatterOptions.h"
#include "../Static.h"
#include "../CodeExtensions.h"
#include "../FormatterTextKind.g.h"

#include <array>
#include <string>
#include <string_view>
#include <cassert>

namespace Iced::Intel::FormatterInternal
{
	class FormatterUtils final
	{
#include "FormatterUtils.All.h"
	}
}
#endif
