/* 
SPDX-License-Identifier: MIT
Copyright (C) 2018-present iced project and contributors
 */

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once

#if defined(DECODER) || defined(ENCODER) || defined(INSTR_INFO) || (defined(ENCODER) && defined(OPCODE_INFO))
#include <array>
#include <stdexcept>
#include <string>
#include "ToString.h"
#include "Internal/StringHelpers.h"
namespace Iced::Intel {
	enum class EncodingKind {
		/// <summary>Legacy encoding</summary>
		Legacy  = 0,
		/// <summary>VEX encoding</summary>
		VEX  = 1,
		/// <summary>EVEX encoding</summary>
		EVEX  = 2,
		/// <summary>XOP encoding</summary>
		XOP  = 3,
		/// <summary>3DNow! encoding</summary>
		D3NOW  = 4,
		/// <summary>MVEX encoding</summary>
		MVEX  = 5,
	};
	constexpr int operator+(const EncodingKind& a, const EncodingKind& b) { return ((int)a + (int)b); }
	constexpr int operator+(const EncodingKind& a, const int& b) { return ((int)a + b); }
	constexpr int operator+(const int& a, const EncodingKind& b) { return (a + (int)b); }
	constexpr int operator-(const EncodingKind& a, const EncodingKind& b) { return ((int)a - (int)b); }
	constexpr int operator-(const EncodingKind& a, const int& b) { return ((int)a - b); }
	constexpr int operator-(const int& a, const EncodingKind& b) { return (a - (int)b); }
	constexpr EncodingKind operator++(EncodingKind& a, int) { auto temp = a; a = EncodingKind(a + 1); return temp; }
	constexpr EncodingKind& operator++(EncodingKind& a) { return a = EncodingKind(a + 1); }
	constexpr EncodingKind operator--(EncodingKind& a, int) { auto temp = a; a = EncodingKind(a - 1); return temp; }
	constexpr EncodingKind& operator--(EncodingKind& a) { return a = EncodingKind(a - 1); }
	constexpr bool operator==(const EncodingKind& a, const int& b) { return ((int)a == b); }
	constexpr bool operator==(const int& a, const EncodingKind& b) { return (a == (int)b); }
	constexpr bool operator>=(const EncodingKind& a, const int& b) { return ((int)a >= b); }
	constexpr bool operator>=(const int& a, const EncodingKind& b) { return (a >= (int)b); }
	constexpr bool operator<=(const EncodingKind& a, const int& b) { return ((int)a <= b); }
	constexpr bool operator<=(const int& a, const EncodingKind& b) { return (a <= (int)b); }
	constexpr bool operator>(const EncodingKind& a, const int& b) { return ((int)a > b); }
	constexpr bool operator>(const int& a, const EncodingKind& b) { return (a > (int)b); }
	constexpr bool operator<(const EncodingKind& a, const int& b) { return ((int)a < b); }
	constexpr bool operator<(const int& a, const EncodingKind& b) { return (a < (int)b); }
	constexpr bool operator!=(const EncodingKind& a, const int& b) { return ((int)a != b); }
	constexpr bool operator!=(const int& a, const EncodingKind& b) { return (a != (int)b); }
}
template <>
constexpr std::string Iced::Intel::ToString(const Iced::Intel::EncodingKind& e) {
	switch (e) {
		case Iced::Intel::EncodingKind::Legacy: return "Legacy";
		case Iced::Intel::EncodingKind::VEX: return "VEX";
		case Iced::Intel::EncodingKind::EVEX: return "EVEX";
		case Iced::Intel::EncodingKind::XOP: return "XOP";
		case Iced::Intel::EncodingKind::D3NOW: return "D3NOW";
		case Iced::Intel::EncodingKind::MVEX: return "MVEX";
		default: return Internal::StringHelpers::ToDec((int)e);
	}
}
#endif
