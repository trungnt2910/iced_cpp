// C# helper headers
#include <csharp/classes.h>
#include <csharp/enum.h>



// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#pragma once

#include "../Iced.Intel.IcedConstants.h"
#include "../Mnemonic.g.h"
#include "../FormatterInternal/FormatterString.h"
#include "InstrOpInfoFlags.g.h"
#include "../Register.g.h"
#include "../OpAccess.g.h"
#include "../Iced.Intel.Instruction.h"
#include "../FormatterOptions.h"
#include "../CodeSize.g.h"
#include "../Code.g.h"
#include <string>
#include <vector>
#include <csharp/exceptionhelper.h>
#include <cassert>

// Code generated from Iced. Do not edit.
// Commit tag: badb6147c0994a4954fa27645aba2b02c2bb9502.
// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors
using namespace Iced::Intel::FormatterInternal;
namespace Iced::Intel::MasmFormatterInternal
{
	// GENERATOR-BEGIN: InstrOpKind
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	enum class InstrOpKind : std::uint8_t
	{
		Register,
		NearBranch16,
		NearBranch32,
		NearBranch64,
		FarBranch16,
		FarBranch32,
		Immediate8,
		Immediate8_2nd,
		Immediate16,
		Immediate32,
		Immediate64,
		Immediate8to16,
		Immediate8to32,
		Immediate8to64,
		Immediate32to64,
		MemorySegSI,
		MemorySegESI,
		MemorySegRSI,
		MemorySegDI,
		MemorySegEDI,
		MemorySegRDI,
		MemoryESDI,
		MemoryESEDI,
		MemoryESRDI,
		Memory,
		ExtraImmediate8_Value3,
		DeclareByte,
		DeclareWord,
		DeclareDword,
		DeclareQword
	};

	DEFINE_COMP(InstrOpKind)
		DEFINE_ARITH(InstrOpKind)

		// GENERATOR-END: InstrOpKind
		class InstrOpInfo
	{
	public:
		static constexpr std::int32_t TEST_RegisterBits = IcedConstants::RegisterBits;
		FormatterString Mnemonic;
		InstrOpInfoFlags Flags = static_cast<InstrOpInfoFlags>(0);
		std::uint8_t OpCount = 0;
		InstrOpKind Op0Kind = static_cast<InstrOpKind>(0);
		InstrOpKind Op1Kind = static_cast<InstrOpKind>(0);
		InstrOpKind Op2Kind = static_cast<InstrOpKind>(0);
		InstrOpKind Op3Kind = static_cast<InstrOpKind>(0);
		InstrOpKind Op4Kind = static_cast<InstrOpKind>(0);
		std::uint8_t Op0Register = 0;
		std::uint8_t Op1Register = 0;
		std::uint8_t Op2Register = 0;
		std::uint8_t Op3Register = 0;
		std::uint8_t Op4Register = 0;
		std::int8_t Op0Index = 0;
		std::int8_t Op1Index = 0;
		std::int8_t Op2Index = 0;
		std::int8_t Op3Index = 0;
		std::int8_t Op4Index = 0;
		Register GetOpRegister(std::int32_t operand) const;
		InstrOpKind GetOpKind(std::int32_t operand) const;
		std::int32_t GetInstructionIndex(std::int32_t operand) const;
		bool TryGetOpAccess(std::int32_t operand, OpAccess& access);
		std::int32_t GetOperandIndex(std::int32_t instructionOperand) const;
		InstrOpInfo(FormatterString mnemonic, const Instruction& instruction, InstrOpInfoFlags flags);

		InstrOpInfo() = default;
	};
	class InstrInfo
	{
	public:
		static constexpr std::int32_t OpAccess_INVALID = -1;
		static constexpr std::int32_t OpAccess_None = -static_cast<std::int32_t>(OpAccess::None + 2);
		static constexpr std::int32_t OpAccess_Read = -static_cast<std::int32_t>(OpAccess::Read + 2);
		static constexpr std::int32_t OpAccess_CondRead = -static_cast<std::int32_t>(OpAccess::CondRead + 2);
		static constexpr std::int32_t OpAccess_Write = -static_cast<std::int32_t>(OpAccess::Write + 2);
		static constexpr std::int32_t OpAccess_CondWrite = -static_cast<std::int32_t>(OpAccess::CondWrite + 2);
		static constexpr std::int32_t OpAccess_ReadWrite = -static_cast<std::int32_t>(OpAccess::ReadWrite + 2);
		static constexpr std::int32_t OpAccess_ReadCondWrite = -static_cast<std::int32_t>(OpAccess::ReadCondWrite + 2);
		static constexpr std::int32_t OpAccess_NoMemAccess = -static_cast<std::int32_t>(OpAccess::NoMemAccess + 2);
		virtual void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) = 0;
	protected:
		static std::int32_t GetBitness(CodeSize codeSize);
	};
	class SimpleInstrInfo final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		InstrOpInfoFlags flags = static_cast<InstrOpInfoFlags>(0);
	public:
		SimpleInstrInfo(const std::string& mnemonic);
		SimpleInstrInfo(const std::string& mnemonic, InstrOpInfoFlags flags);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_cc final : public InstrInfo
	{
		/* readonly */
	private:
		std::int32_t ccIndex = 0;
		/* readonly */
		std::vector<FormatterString> mnemonics;
		/* readonly */
		InstrOpInfoFlags flags = static_cast<InstrOpInfoFlags>(0);
	public:
		SimpleInstrInfo_cc(std::int32_t ccIndex, const std::vector<std::string>& mnemonics);
		SimpleInstrInfo_cc(std::int32_t ccIndex, const std::vector<std::string>& mnemonics, InstrOpInfoFlags flags);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_memsize final : public InstrInfo
	{
		/* readonly */
	private:
		std::int32_t bitness = 0;
		/* readonly */
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_memsize(std::int32_t bitness, const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_AamAad final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_AamAad(const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_Int3 final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_Int3(const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_YD final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic_args;
		/* readonly */
		FormatterString mnemonic_no_args;
		static constexpr InstrOpInfoFlags flags = InstrOpInfoFlags::ShowNoMemSize_ForceSize | InstrOpInfoFlags::ShowMinMemSize_ForceSize;
	public:
		SimpleInstrInfo_YD(const std::string& mnemonic_args, const std::string& mnemonic_no_args);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_DX final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic_args;
		/* readonly */
		FormatterString mnemonic_no_args;
		static constexpr InstrOpInfoFlags flags = InstrOpInfoFlags::ShowNoMemSize_ForceSize | InstrOpInfoFlags::ShowMinMemSize_ForceSize;
	public:
		SimpleInstrInfo_DX(const std::string& mnemonic_args, const std::string& mnemonic_no_args);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_YX final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic_args;
		/* readonly */
		FormatterString mnemonic_no_args;
		static constexpr InstrOpInfoFlags flags = InstrOpInfoFlags::ShowNoMemSize_ForceSize | InstrOpInfoFlags::ShowMinMemSize_ForceSize;
	public:
		SimpleInstrInfo_YX(const std::string& mnemonic_args, const std::string& mnemonic_no_args);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_XY final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic_args;
		/* readonly */
		FormatterString mnemonic_no_args;
		static constexpr InstrOpInfoFlags flags = InstrOpInfoFlags::ShowNoMemSize_ForceSize | InstrOpInfoFlags::ShowMinMemSize_ForceSize;
	public:
		SimpleInstrInfo_XY(const std::string& mnemonic_args, const std::string& mnemonic_no_args);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_YA final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic_args;
		/* readonly */
		FormatterString mnemonic_no_args;
		static constexpr InstrOpInfoFlags flags = InstrOpInfoFlags::ShowNoMemSize_ForceSize | InstrOpInfoFlags::ShowMinMemSize_ForceSize;
	public:
		SimpleInstrInfo_YA(const std::string& mnemonic_args, const std::string& mnemonic_no_args);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_AX final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic_args;
		/* readonly */
		FormatterString mnemonic_no_args;
		static constexpr InstrOpInfoFlags flags = InstrOpInfoFlags::ShowNoMemSize_ForceSize | InstrOpInfoFlags::ShowMinMemSize_ForceSize;
	public:
		SimpleInstrInfo_AX(const std::string& mnemonic_args, const std::string& mnemonic_no_args);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_AY final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic_args;
		/* readonly */
		FormatterString mnemonic_no_args;
		static constexpr InstrOpInfoFlags flags = InstrOpInfoFlags::ShowNoMemSize_ForceSize | InstrOpInfoFlags::ShowMinMemSize_ForceSize;
	public:
		SimpleInstrInfo_AY(const std::string& mnemonic_args, const std::string& mnemonic_no_args);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_XLAT final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic_args;
		/* readonly */
		FormatterString mnemonic_no_args;
	public:
		SimpleInstrInfo_XLAT(const std::string& mnemonic_args, const std::string& mnemonic_no_args);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_nop final : public InstrInfo
	{
		/* readonly */
	private:
		std::int32_t bitness = 0;
		/* readonly */
		FormatterString mnemonic;
		/* readonly */
		Register register_ = static_cast<Register>(0);
	public:
		SimpleInstrInfo_nop(std::int32_t bitness, const std::string& mnemonic, Register register_);
	private:
		static FormatterString str_xchg;
	public:
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_STIG1 final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		bool pseudoOp = false;
	public:
		SimpleInstrInfo_STIG1(const std::string& mnemonic, bool pseudoOp);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_STi_ST final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		bool pseudoOp = false;
	public:
		SimpleInstrInfo_STi_ST(const std::string& mnemonic, bool pseudoOp);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_ST_STi final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_ST_STi(const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_monitor final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		Register register1 = static_cast<Register>(0);
		/* readonly */
		Register register2 = static_cast<Register>(0);
		/* readonly */
		Register register3 = static_cast<Register>(0);
	public:
		SimpleInstrInfo_monitor(const std::string& mnemonic, Register register1, Register register2, Register register3);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_mwait final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_mwait(const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_mwaitx final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_mwaitx(const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_maskmovq final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		InstrOpInfoFlags flags = static_cast<InstrOpInfoFlags>(0);
	public:
		SimpleInstrInfo_maskmovq(const std::string& mnemonic, InstrOpInfoFlags flags);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_pblendvb final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_pblendvb(const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_reverse final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_reverse(const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_OpSize final : public InstrInfo
	{
		/* readonly */
	private:
		CodeSize codeSize = static_cast<CodeSize>(0);
		/* readonly */
		std::vector<FormatterString> mnemonics;
	public:
		SimpleInstrInfo_OpSize(CodeSize codeSize, const std::string& mnemonic, const std::string& mnemonic16, const std::string& mnemonic32, const std::string& mnemonic64);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_OpSize_cc final : public InstrInfo
	{
		/* readonly */
	private:
		CodeSize codeSize = static_cast<CodeSize>(0);
		/* readonly */
		std::int32_t ccIndex = 0;
		/* readonly */
		std::vector<FormatterString> mnemonics;
		/* readonly */
		std::vector<FormatterString> mnemonics_other;
	public:
		SimpleInstrInfo_OpSize_cc(CodeSize codeSize, std::int32_t ccIndex, const std::vector<std::string>& mnemonics, const std::vector<std::string>& mnemonics_other);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_OpSize2 final : public InstrInfo
	{
		/* readonly */
	private:
		std::vector<FormatterString> mnemonics;
		/* readonly */
		bool canUseBnd = false;
	public:
		SimpleInstrInfo_OpSize2(const std::string& mnemonic, const std::string& mnemonic16, const std::string& mnemonic32, const std::string& mnemonic64, bool canUseBnd);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_fword final : public InstrInfo
	{
		/* readonly */
	private:
		CodeSize codeSize = static_cast<CodeSize>(0);
		/* readonly */
		InstrOpInfoFlags flags = static_cast<InstrOpInfoFlags>(0);
		/* readonly */
		FormatterString mnemonic;
		/* readonly */
		FormatterString mnemonic2;
	public:
		SimpleInstrInfo_fword(CodeSize codeSize, InstrOpInfoFlags flags, const std::string& mnemonic, const std::string& mnemonic2);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_jcc final : public InstrInfo
	{
		/* readonly */
	private:
		std::int32_t ccIndex = 0;
		/* readonly */
		std::vector<FormatterString> mnemonics;
	public:
		SimpleInstrInfo_jcc(std::int32_t ccIndex, const std::vector<std::string>& mnemonics);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_bnd final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		InstrOpInfoFlags flags = static_cast<InstrOpInfoFlags>(0);
	public:
		SimpleInstrInfo_bnd(const std::string& mnemonic, InstrOpInfoFlags flags);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_pops final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		std::vector<FormatterString> pseudo_ops;
		/* readonly */
		InstrOpInfoFlags flags = static_cast<InstrOpInfoFlags>(0);
	public:
		SimpleInstrInfo_pops(const std::string& mnemonic, const std::vector<FormatterString>& pseudo_ops);
		SimpleInstrInfo_pops(const std::string& mnemonic, const std::vector<FormatterString>& pseudo_ops, InstrOpInfoFlags flags);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
		static void RemoveLastOp(InstrOpInfo& info);
	};
	class SimpleInstrInfo_pclmulqdq final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		std::vector<FormatterString> pseudo_ops;
	public:
		SimpleInstrInfo_pclmulqdq(const std::string& mnemonic, const std::vector<FormatterString>& pseudo_ops);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_imul final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_imul(const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_Reg16 final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		InstrOpInfoFlags flags = static_cast<InstrOpInfoFlags>(0);
	public:
		SimpleInstrInfo_Reg16(const std::string& mnemonic, InstrOpInfoFlags flags);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_Reg32 final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		InstrOpInfoFlags flags = static_cast<InstrOpInfoFlags>(0);
	public:
		SimpleInstrInfo_Reg32(const std::string& mnemonic, InstrOpInfoFlags flags);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_reg final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		Register register_ = static_cast<Register>(0);
	public:
		SimpleInstrInfo_reg(const std::string& mnemonic, Register register_);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_invlpga final : public InstrInfo
	{
		/* readonly */
	private:
		std::int32_t bitness = 0;
		/* readonly */
		FormatterString mnemonic;
	public:
		SimpleInstrInfo_invlpga(std::int32_t bitness, const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
	class SimpleInstrInfo_DeclareData final : public InstrInfo
	{
		/* readonly */
	private:
		FormatterString mnemonic;
		/* readonly */
		InstrOpKind opKind = static_cast<InstrOpKind>(0);
	public:
		SimpleInstrInfo_DeclareData(Code code, const std::string& mnemonic);
		void GetOpInfo(const FormatterOptions& options, const Instruction& instruction, InstrOpInfo& info) override;
	};
}
