/* 
SPDX-License-Identifier: MIT
Copyright (C) 2018-present iced project and contributors
 */

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once

#if defined(DECODER)
#include <array>
#include <cstdint>
#include <stdexcept>
#include <string>
#include "ToString.h"
#include "Internal/StringHelpers.h"
namespace Iced::Intel {
	enum class DecoderOptions : std::uint32_t {
		/// <summary>No option is enabled</summary>
		None  = 0x00000000,
		/// <summary>Disable some checks for invalid encodings of instructions, eg. most instructions can&apos;t use a <c>LOCK</c> prefix so if one is found, they&apos;re decoded as <see cref="Code.INVALID"/> unless this option is enabled.</summary>
		NoInvalidCheck  = 0x00000001,
		/// <summary>AMD decoder: allow 16-bit branch/ret instructions in 64-bit mode, no <c>o64 CALL/JMP FAR [mem], o64 LSS/LFS/LGS</c>, <c>UD0</c> has no modr/m byte, decode <c>LOCK MOV CR</c>. The AMD decoder can still decode Intel instructions.</summary>
		AMD  = 0x00000002,
		/// <summary>Decode opcodes <c>0F0D</c> and <c>0F18-0F1F</c> as reserved-nop instructions (eg. <see cref="Code.Reservednop_rm32_r32_0F1D"/>)</summary>
		ForceReservedNop  = 0x00000004,
		/// <summary>Decode <c>UMOV</c> instructions</summary>
		Umov  = 0x00000008,
		/// <summary>Decode <c>XBTS</c>/<c>IBTS</c></summary>
		Xbts  = 0x00000010,
		/// <summary>Decode <c>0FA6</c>/<c>0FA7</c> as <c>CMPXCHG</c></summary>
		Cmpxchg486A  = 0x00000020,
		/// <summary>Decode some old removed FPU instructions (eg. <c>FRSTPM</c>)</summary>
		OldFpu  = 0x00000040,
		/// <summary>Decode <c>PCOMMIT</c></summary>
		Pcommit  = 0x00000080,
		/// <summary>Decode 286 <c>STOREALL</c>/<c>LOADALL</c> (<c>0F04</c> and <c>0F05</c>)</summary>
		Loadall286  = 0x00000100,
		/// <summary>Decode 386 <c>LOADALL</c></summary>
		Loadall386  = 0x00000200,
		/// <summary>Decode <c>CL1INVMB</c></summary>
		Cl1invmb  = 0x00000400,
		/// <summary>Decode <c>MOV r32,tr</c> and <c>MOV tr,r32</c></summary>
		MovTr  = 0x00000800,
		/// <summary>Decode <c>JMPE</c> instructions</summary>
		Jmpe  = 0x00001000,
		/// <summary>Don&apos;t decode <c>PAUSE</c>, decode <c>NOP</c> instead</summary>
		NoPause  = 0x00002000,
		/// <summary>Don&apos;t decode <c>WBNOINVD</c>, decode <c>WBINVD</c> instead</summary>
		NoWbnoinvd  = 0x00004000,
		/// <summary>Decode undocumented Intel <c>RDUDBG</c> and <c>WRUDBG</c> instructions</summary>
		Udbg  = 0x00008000,
		/// <summary>Don&apos;t decode <c>TZCNT</c>, decode <c>BSF</c> instead</summary>
		NoMPFX_0FBC  = 0x00010000,
		/// <summary>Don&apos;t decode <c>LZCNT</c>, decode <c>BSR</c> instead</summary>
		NoMPFX_0FBD  = 0x00020000,
		/// <summary>Don&apos;t decode <c>LAHF</c> and <c>SAHF</c> in 64-bit mode</summary>
		NoLahfSahf64  = 0x00040000,
		/// <summary>Decode <c>MPX</c> instructions</summary>
		MPX  = 0x00080000,
		/// <summary>Decode most Cyrix instructions: <c>FPU</c>, <c>EMMI</c>, <c>SMM</c>, <c>DDI</c></summary>
		Cyrix  = 0x00100000,
		/// <summary>Decode Cyrix <c>SMINT 0F7E</c> (Cyrix 6x86 or earlier)</summary>
		Cyrix_SMINT_0F7E  = 0x00200000,
		/// <summary>Decode Cyrix <c>DMI</c> instructions (AMD Geode GX/LX)</summary>
		Cyrix_DMI  = 0x00400000,
		/// <summary>Decode Centaur <c>ALTINST</c></summary>
		ALTINST  = 0x00800000,
		/// <summary>Decode Intel Knights Corner instructions</summary>
		KNC  = 0x01000000,
	};
	constexpr DecoderOptions& operator^=(DecoderOptions& a, const DecoderOptions& b) { return a = (DecoderOptions)((std::uint32_t)a ^ (std::uint32_t)b); }
	constexpr DecoderOptions operator^(const DecoderOptions& a, const DecoderOptions& b) { return (DecoderOptions)((std::uint32_t)a ^ (std::uint32_t)b); }
	constexpr DecoderOptions& operator|=(DecoderOptions& a, const DecoderOptions& b) { return a = (DecoderOptions)((std::uint32_t)a | (std::uint32_t)b); }
	constexpr DecoderOptions operator|(const DecoderOptions& a, const DecoderOptions& b) { return (DecoderOptions)((std::uint32_t)a | (std::uint32_t)b); }
	constexpr DecoderOptions& operator&=(DecoderOptions& a, const DecoderOptions& b) { return a = (DecoderOptions)((std::uint32_t)a & (std::uint32_t)b); }
	constexpr DecoderOptions operator&(const DecoderOptions& a, const DecoderOptions& b) { return (DecoderOptions)((std::uint32_t)a & (std::uint32_t)b); }
	constexpr DecoderOptions operator~(const DecoderOptions& a) { return (DecoderOptions)(~((std::uint32_t)a)); }
	constexpr std::uint32_t operator+(const DecoderOptions& a, const DecoderOptions& b) { return ((std::uint32_t)a + (std::uint32_t)b); }
	constexpr std::uint32_t operator+(const DecoderOptions& a, const std::uint32_t& b) { return ((std::uint32_t)a + b); }
	constexpr std::uint32_t operator+(const std::uint32_t& a, const DecoderOptions& b) { return (a + (std::uint32_t)b); }
	constexpr std::uint32_t operator-(const DecoderOptions& a, const DecoderOptions& b) { return ((std::uint32_t)a - (std::uint32_t)b); }
	constexpr std::uint32_t operator-(const DecoderOptions& a, const std::uint32_t& b) { return ((std::uint32_t)a - b); }
	constexpr std::uint32_t operator-(const std::uint32_t& a, const DecoderOptions& b) { return (a - (std::uint32_t)b); }
	constexpr DecoderOptions operator++(DecoderOptions& a, int) { auto temp = a; a = DecoderOptions(a + 1); return temp; }
	constexpr DecoderOptions& operator++(DecoderOptions& a) { return a = DecoderOptions(a + 1); }
	constexpr DecoderOptions operator--(DecoderOptions& a, int) { auto temp = a; a = DecoderOptions(a - 1); return temp; }
	constexpr DecoderOptions& operator--(DecoderOptions& a) { return a = DecoderOptions(a - 1); }
	constexpr bool operator==(const DecoderOptions& a, const std::uint32_t& b) { return ((std::uint32_t)a == b); }
	constexpr bool operator==(const std::uint32_t& a, const DecoderOptions& b) { return (a == (std::uint32_t)b); }
	constexpr bool operator>=(const DecoderOptions& a, const std::uint32_t& b) { return ((std::uint32_t)a >= b); }
	constexpr bool operator>=(const std::uint32_t& a, const DecoderOptions& b) { return (a >= (std::uint32_t)b); }
	constexpr bool operator<=(const DecoderOptions& a, const std::uint32_t& b) { return ((std::uint32_t)a <= b); }
	constexpr bool operator<=(const std::uint32_t& a, const DecoderOptions& b) { return (a <= (std::uint32_t)b); }
	constexpr bool operator>(const DecoderOptions& a, const std::uint32_t& b) { return ((std::uint32_t)a > b); }
	constexpr bool operator>(const std::uint32_t& a, const DecoderOptions& b) { return (a > (std::uint32_t)b); }
	constexpr bool operator<(const DecoderOptions& a, const std::uint32_t& b) { return ((std::uint32_t)a < b); }
	constexpr bool operator<(const std::uint32_t& a, const DecoderOptions& b) { return (a < (std::uint32_t)b); }
	constexpr bool operator!=(const DecoderOptions& a, const std::uint32_t& b) { return ((std::uint32_t)a != b); }
	constexpr bool operator!=(const std::uint32_t& a, const DecoderOptions& b) { return (a != (std::uint32_t)b); }
}
template <>
constexpr std::string Iced::Intel::ToString(const Iced::Intel::DecoderOptions& e) {
	std::string result;
	auto temp = e;
	if (temp == Iced::Intel::DecoderOptions::None) {
		return "None";
	}
	if ((temp & Iced::Intel::DecoderOptions::NoInvalidCheck) == Iced::Intel::DecoderOptions::NoInvalidCheck) {
		temp ^= Iced::Intel::DecoderOptions::NoInvalidCheck;
		result += "NoInvalidCheck, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::AMD) == Iced::Intel::DecoderOptions::AMD) {
		temp ^= Iced::Intel::DecoderOptions::AMD;
		result += "AMD, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::ForceReservedNop) == Iced::Intel::DecoderOptions::ForceReservedNop) {
		temp ^= Iced::Intel::DecoderOptions::ForceReservedNop;
		result += "ForceReservedNop, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Umov) == Iced::Intel::DecoderOptions::Umov) {
		temp ^= Iced::Intel::DecoderOptions::Umov;
		result += "Umov, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Xbts) == Iced::Intel::DecoderOptions::Xbts) {
		temp ^= Iced::Intel::DecoderOptions::Xbts;
		result += "Xbts, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Cmpxchg486A) == Iced::Intel::DecoderOptions::Cmpxchg486A) {
		temp ^= Iced::Intel::DecoderOptions::Cmpxchg486A;
		result += "Cmpxchg486A, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::OldFpu) == Iced::Intel::DecoderOptions::OldFpu) {
		temp ^= Iced::Intel::DecoderOptions::OldFpu;
		result += "OldFpu, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Pcommit) == Iced::Intel::DecoderOptions::Pcommit) {
		temp ^= Iced::Intel::DecoderOptions::Pcommit;
		result += "Pcommit, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Loadall286) == Iced::Intel::DecoderOptions::Loadall286) {
		temp ^= Iced::Intel::DecoderOptions::Loadall286;
		result += "Loadall286, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Loadall386) == Iced::Intel::DecoderOptions::Loadall386) {
		temp ^= Iced::Intel::DecoderOptions::Loadall386;
		result += "Loadall386, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Cl1invmb) == Iced::Intel::DecoderOptions::Cl1invmb) {
		temp ^= Iced::Intel::DecoderOptions::Cl1invmb;
		result += "Cl1invmb, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::MovTr) == Iced::Intel::DecoderOptions::MovTr) {
		temp ^= Iced::Intel::DecoderOptions::MovTr;
		result += "MovTr, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Jmpe) == Iced::Intel::DecoderOptions::Jmpe) {
		temp ^= Iced::Intel::DecoderOptions::Jmpe;
		result += "Jmpe, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::NoPause) == Iced::Intel::DecoderOptions::NoPause) {
		temp ^= Iced::Intel::DecoderOptions::NoPause;
		result += "NoPause, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::NoWbnoinvd) == Iced::Intel::DecoderOptions::NoWbnoinvd) {
		temp ^= Iced::Intel::DecoderOptions::NoWbnoinvd;
		result += "NoWbnoinvd, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Udbg) == Iced::Intel::DecoderOptions::Udbg) {
		temp ^= Iced::Intel::DecoderOptions::Udbg;
		result += "Udbg, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::NoMPFX_0FBC) == Iced::Intel::DecoderOptions::NoMPFX_0FBC) {
		temp ^= Iced::Intel::DecoderOptions::NoMPFX_0FBC;
		result += "NoMPFX_0FBC, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::NoMPFX_0FBD) == Iced::Intel::DecoderOptions::NoMPFX_0FBD) {
		temp ^= Iced::Intel::DecoderOptions::NoMPFX_0FBD;
		result += "NoMPFX_0FBD, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::NoLahfSahf64) == Iced::Intel::DecoderOptions::NoLahfSahf64) {
		temp ^= Iced::Intel::DecoderOptions::NoLahfSahf64;
		result += "NoLahfSahf64, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::MPX) == Iced::Intel::DecoderOptions::MPX) {
		temp ^= Iced::Intel::DecoderOptions::MPX;
		result += "MPX, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Cyrix) == Iced::Intel::DecoderOptions::Cyrix) {
		temp ^= Iced::Intel::DecoderOptions::Cyrix;
		result += "Cyrix, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Cyrix_SMINT_0F7E) == Iced::Intel::DecoderOptions::Cyrix_SMINT_0F7E) {
		temp ^= Iced::Intel::DecoderOptions::Cyrix_SMINT_0F7E;
		result += "Cyrix_SMINT_0F7E, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::Cyrix_DMI) == Iced::Intel::DecoderOptions::Cyrix_DMI) {
		temp ^= Iced::Intel::DecoderOptions::Cyrix_DMI;
		result += "Cyrix_DMI, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::ALTINST) == Iced::Intel::DecoderOptions::ALTINST) {
		temp ^= Iced::Intel::DecoderOptions::ALTINST;
		result += "ALTINST, ";
	}
	if ((temp & Iced::Intel::DecoderOptions::KNC) == Iced::Intel::DecoderOptions::KNC) {
		temp ^= Iced::Intel::DecoderOptions::KNC;
		result += "KNC, ";
	}
	if (temp != 0 || result.empty()) return Internal::StringHelpers::ToDec((std::uint32_t)e);
	return result.substr(0, result.size() - 2);
}
#endif
