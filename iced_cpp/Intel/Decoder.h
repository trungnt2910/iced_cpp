// C# helper headers
#include <csharp/classes.h>
#include <csharp/enum.h>



// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#pragma once

#include "Iced.Intel.Instruction.h"
#include "CodeReader.h"
#include "DecoderInternal/OpCodeHandlers.h"
#include "DecoderOptions.g.h"
#include "CodeSize.g.h"
#include "MandatoryPrefixByte.g.h"
#include "EncodingKind.g.h"
#include "DecoderError.g.h"
#include "Register.g.h"
#include "TupleType.g.h"
#include "ConstantOffsets.h"
#include <vector>
#include <limits>
#include <stdexcept>
#include <any>
#include <csharp/exceptionhelper.h>
#include <cassert>

namespace Iced::Intel::DecoderInternal { class OpCodeHandler; }

// Code generated from Iced. Do not edit.
// Commit tag: badb6147c0994a4954fa27645aba2b02c2bb9502.
// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors
namespace Iced::Intel
{
	// GENERATOR-BEGIN: OpSize
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	enum class OpSize : std::uint8_t
	{
		Size16,
		Size32,
		Size64
	};

	DEFINE_COMP(OpSize)
		DEFINE_ARITH(OpSize)

		// GENERATOR-END: OpSize
		// GENERATOR-BEGIN: StateFlags
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		enum class StateFlags : std::uint32_t
	{
		IpRel64 = 0x00000001,
		IpRel32 = 0x00000002,
		HasRex = 0x00000008,
		b = 0x00000010,
		z = 0x00000020,
		IsInvalid = 0x00000040,
		W = 0x00000080,
		NoImm = 0x00000100,
		Addr64 = 0x00000200,
		BranchImm8 = 0x00000400,
		Xbegin = 0x00000800,
		Lock = 0x00001000,
		AllowLock = 0x00002000,
		NoMoreBytes = 0x00004000,
		Has66 = 0x00008000,
		MvexSssMask = 0x00000007,
		MvexSssShift = 0x00000010,
		MvexEH = 0x00080000,
		EncodingMask = 0x00000007,
		EncodingShift = 0x0000001D
	};
	DEFINE_FLAGS(StateFlags)
		DEFINE_COMP(StateFlags)
		DEFINE_ARITH(StateFlags)

		// GENERATOR-END: StateFlags
		/// <summary>
		/// Decodes 16/32/64-bit x86 instructions
		/// </summary>
		class Decoder final : public std::vector<Instruction>
	{
	private:
		class RegInfo2;
		using OpCodeHandler = DecoderInternal::OpCodeHandler;
	private:
		std::int32_t Bitness = 0;

		std::uint64_t instructionPointer = 0;
		/* readonly */
		CodeReader* reader;
		/* readonly */
		std::vector<Decoder::RegInfo2> memRegs16;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_MAP0;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_VEX_MAP0;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_VEX_0F;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_VEX_0F38;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_VEX_0F3A;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_EVEX_0F;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_EVEX_0F38;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_EVEX_0F3A;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_EVEX_MAP5;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_EVEX_MAP6;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_XOP_MAP8;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_XOP_MAP9;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_XOP_MAP10;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_MVEX_0F;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_MVEX_0F38;
		/* readonly */
		std::vector<std::shared_ptr<OpCodeHandler>> handlers_MVEX_0F3A;
	public:
		class State
		{
		public:
			std::uint32_t modrm = 0, mod = 0, reg = 0, rm = 0;
			std::uint32_t instructionLength = 0;
			std::uint32_t extraRegisterBase = 0; // R << 3
			std::uint32_t extraIndexRegisterBase = 0; // X << 3
			std::uint32_t extraBaseRegisterBase = 0; // B << 3
			std::uint32_t extraIndexRegisterBaseVSIB = 0;
			StateFlags flags = static_cast<StateFlags>(0);
			MandatoryPrefixByte mandatoryPrefix = static_cast<MandatoryPrefixByte>(0);
			std::uint32_t vvvv = 0; // V`vvvv. Not stored in inverted form. If 16/32-bit mode, bits [4:3] are cleared
			std::uint32_t vvvv_invalidCheck = 0; // vvvv bits, even in 16/32-bit mode.
			std::uint32_t aaa = 0;
			std::uint32_t extraRegisterBaseEVEX = 0; // EVEX/MVEX.R' << 4
			std::uint32_t extraBaseRegisterBaseEVEX = 0; // EVEX/MVEX.XB << 3
			std::uint32_t vectorLength = 0;
			OpSize operandSize = static_cast<OpSize>(0);
			OpSize addressSize = static_cast<OpSize>(0);
			// 0=ES/CS/SS/DS, 1=FS/GS
			std::uint8_t segmentPrio = 0;
			EncodingKind GetEncoding() const;
			std::int32_t GetSss() const;
		};
	public:
		State state;
		std::uint32_t displIndex = 0;
		DecoderOptions options = static_cast<DecoderOptions>(0);
		std::uint32_t invalidCheckMask = 0; // All 1s if we should check for invalid instructions, else 0
		std::uint32_t is64bMode_and_W = 0; // StateFlags.W if 64-bit mode, 0 if 16/32-bit mode
		std::uint32_t reg15Mask = 0; // 7 in 16/32-bit mode, 15 in 64-bit mode
		/* readonly */
	private:
		std::uint32_t mask64b = 0;
	public:
		CodeSize defaultCodeSize = static_cast<CodeSize>(0);
		OpSize defaultOperandSize = static_cast<OpSize>(0);
		/* readonly */
	private:
		OpSize defaultAddressSize = static_cast<OpSize>(0);
	public:
		OpSize defaultInvertedOperandSize = static_cast<OpSize>(0);
		OpSize defaultInvertedAddressSize = static_cast<OpSize>(0);
		bool is64bMode = false;
		/// <summary>
		/// Current <c>IP</c>/<c>EIP</c>/<c>RIP</c> value.<br/>
		/// <br/>
		/// Writing to this property only updates the IP value, it does not change a <see cref="CodeReader"/>'s byte position.
		/// You can use <see cref="ByteArrayCodeReader.Position"/> to change its position.
		/// </summary>
	public:
		std::uint64_t GetIP() const;
		void SetIP(std::uint64_t value);
		/// <summary>
		/// Gets the bitness (16, 32 or 64)
		/// </summary>
		std::int32_t GetBitness() const;
	private:
		class StaticConstructor
		{
		public:
			StaticConstructor();
		};

	private:
		static Decoder::StaticConstructor staticConstructor;

		Decoder(CodeReader* reader, std::uint64_t ip, DecoderOptions options, std::int32_t bitness);
		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="reader">Code reader</param>
		/// <param name="ip"><c>RIP</c> value</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
	public:
		static Decoder Create(std::int32_t bitness, CodeReader* reader, std::uint64_t ip, DecoderOptions options = DecoderOptions::None);
		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="data">Data to decode</param>
		/// <param name="ip"><c>RIP</c> value</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		static Decoder Create(std::int32_t bitness, std::vector<std::uint8_t>& data, std::uint64_t ip, DecoderOptions options = DecoderOptions::None);
		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="reader">Code reader</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		static Decoder Create(std::int32_t bitness, CodeReader* reader, DecoderOptions options = DecoderOptions::None);
		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="data">Data to decode</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		static Decoder Create(std::int32_t bitness, std::vector<std::uint8_t>& data, DecoderOptions options = DecoderOptions::None);
		std::uint32_t ReadByte();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal uint ReadUInt16()
		std::uint32_t ReadUInt16();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal uint ReadUInt32()
		std::uint32_t ReadUInt32();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal ulong ReadUInt64()
		std::uint64_t ReadUInt64();
		/// <summary>
		/// Gets the last decoder error. Unless you need to know the reason it failed,
		/// it's better to check <see cref="Instruction.IsInvalid"/>.
		/// </summary>
		DecoderError GetLastError() const;
		/// <summary>
		/// Decodes the next instruction, see also <see cref="Decode(out Instruction)"/> which is faster
		/// if you already have an <see cref="Instruction"/> local, array element or field.
		/// <br/>
		/// See also <see cref="LastError"/>
		/// </summary>
		/// <returns></returns>
		Instruction Decode();
		/// <summary>
		/// Decodes the next instruction, see also <see cref="LastError"/>
		/// </summary>
		/// <param name="instruction">Decoded instruction</param>
		void Decode(Instruction& instruction);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void ResetRexPrefixState()
		void ResetRexPrefixState();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void CallOpCodeHandlerXXTable(ref Instruction instruction)
		void CallOpCodeHandlerXXTable(Instruction& instruction);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal uint GetCurrentInstructionPointer32()
		std::uint32_t GetCurrentInstructionPointer32();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal ulong GetCurrentInstructionPointer64()
		std::uint64_t GetCurrentInstructionPointer64();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void ClearMandatoryPrefix(ref Instruction instruction)
		void ClearMandatoryPrefix(Instruction& instruction);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void SetXacquireXrelease(ref Instruction instruction)
		void SetXacquireXrelease(Instruction& instruction);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void ClearMandatoryPrefixF3(ref Instruction instruction)
		void ClearMandatoryPrefixF3(Instruction& instruction);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void ClearMandatoryPrefixF2(ref Instruction instruction)
		void ClearMandatoryPrefixF2(Instruction& instruction);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void SetInvalidInstruction()
		void SetInvalidInstruction();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void DecodeTable(OpCodeHandler[] table, ref Instruction instruction)
		void DecodeTable(std::vector<std::shared_ptr<OpCodeHandler>>& table, Instruction& instruction);
	private:
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] void DecodeTable(OpCodeHandler handler, ref Instruction instruction)
		void DecodeTable(std::shared_ptr<OpCodeHandler> handler, Instruction& instruction);
	public:
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void ReadModRM()
		void ReadModRM();
		void VEX2(Instruction& instruction);
		void VEX3(Instruction& instruction);
		void XOP(Instruction& instruction);
		void EVEX_MVEX(Instruction& instruction);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal Register ReadOpSegReg()
		Register ReadOpSegReg();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal bool ReadOpMem(ref Instruction instruction)
		bool ReadOpMem(Instruction& instruction);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void ReadOpMemSib(ref Instruction instruction)
		void ReadOpMemSib(Instruction& instruction);
		// All MPX instructions in 64-bit mode force 64-bit addressing, and
		// all MPX instructions in 16/32-bit mode require 32-bit addressing
		// (see SDM Vol 1, 17.5.1 Intel MPX and Operating Modes)
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void ReadOpMem_MPX(ref Instruction instruction)
		void ReadOpMem_MPX(Instruction& instruction);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void ReadOpMem(ref Instruction instruction, TupleType tupleType)
		void ReadOpMem(Instruction& instruction, TupleType tupleType);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void ReadOpMem_VSIB(ref Instruction instruction, Register vsibIndex, TupleType tupleType)
		void ReadOpMem_VSIB(Instruction& instruction, Register vsibIndex, TupleType tupleType);
		/* readonly */
	private:
		class RegInfo2
		{
		public:
			Register baseReg = static_cast<Register>(0);
			Register indexReg = static_cast<Register>(0);
			RegInfo2(Register baseReg, Register indexReg);
			void Deconstruct(Register& baseReg, Register& indexReg);

			RegInfo2() = default;
		};
	private:
		static std::vector<RegInfo2> s_memRegs16;
		void ReadOpMem16(Instruction& instruction, TupleType tupleType);
		// Returns true if the SIB byte was read
		bool ReadOpMem32Or64(Instruction& instruction, Register baseReg, Register indexReg, TupleType tupleType, bool isVsib);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] uint GetDisp8N(TupleType tupleType)
		std::uint32_t GetDisp8N(TupleType tupleType);
		/// <summary>
		/// Gets the offsets of the constants (memory displacement and immediate) in the decoded instruction.
		/// The caller can check if there are any relocations at those addresses.
		/// </summary>
		/// <param name="instruction">The latest instruction that was decoded by this decoder</param>
		/// <returns></returns>
	public:
		ConstantOffsets GetConstantOffsets(const Instruction& instruction);
	};
}
