// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors

#if defined(DECODER)
#pragma once

#include "Iced.Intel.Instruction.h"
#include "CodeReader.h"
#include "DecoderInternal/OpCodeHandlers.defs.h"
#include "DecoderOptions.g.h"
#include "CodeSize.g.h"
#include "MandatoryPrefixByte.g.h"
#include "EncodingKind.g.h"
#include "DecoderError.g.h"
#include "Register.g.h"
#include "TupleType.g.h"
#include "ConstantOffsets.h"
#include <vector>
#include <limits>
#include <span>
#include <stdexcept>

namespace Iced::Intel
{
	// GENERATOR-BEGIN: OpSize
	// ⚠️This was generated by GENERATOR!🦹‍♂️
	enum class OpSize : std::uint8_t {
		Size16 ,
		Size32 ,
		Size64 ,
	};
	constexpr std::uint8_t operator+(const OpSize& a, const OpSize& b) { return ((std::uint8_t)a + (std::uint8_t)b); }
	constexpr std::uint8_t operator+(const OpSize& a, const std::uint8_t& b) { return ((std::uint8_t)a + b); }
	constexpr std::uint8_t operator+(const std::uint8_t& a, const OpSize& b) { return (a + (std::uint8_t)b); }
	constexpr std::uint8_t operator-(const OpSize& a, const OpSize& b) { return ((std::uint8_t)a - (std::uint8_t)b); }
	constexpr std::uint8_t operator-(const OpSize& a, const std::uint8_t& b) { return ((std::uint8_t)a - b); }
	constexpr std::uint8_t operator-(const std::uint8_t& a, const OpSize& b) { return (a - (std::uint8_t)b); }
	constexpr OpSize operator++(OpSize& a, int) { auto temp = a; a = OpSize(a + 1); return temp; }
	constexpr OpSize& operator++(OpSize& a) { return a = OpSize(a + 1); }
	constexpr OpSize operator--(OpSize& a, int) { auto temp = a; a = OpSize(a - 1); return temp; }
	constexpr OpSize& operator--(OpSize& a) { return a = OpSize(a - 1); }
	constexpr bool operator==(const OpSize& a, const std::uint8_t& b) { return ((std::uint8_t)a == b); }
	constexpr bool operator==(const std::uint8_t& a, const OpSize& b) { return (a == (std::uint8_t)b); }
	constexpr bool operator>=(const OpSize& a, const std::uint8_t& b) { return ((std::uint8_t)a >= b); }
	constexpr bool operator>=(const std::uint8_t& a, const OpSize& b) { return (a >= (std::uint8_t)b); }
	constexpr bool operator<=(const OpSize& a, const std::uint8_t& b) { return ((std::uint8_t)a <= b); }
	constexpr bool operator<=(const std::uint8_t& a, const OpSize& b) { return (a <= (std::uint8_t)b); }
	constexpr bool operator>(const OpSize& a, const std::uint8_t& b) { return ((std::uint8_t)a > b); }
	constexpr bool operator>(const std::uint8_t& a, const OpSize& b) { return (a > (std::uint8_t)b); }
	constexpr bool operator<(const OpSize& a, const std::uint8_t& b) { return ((std::uint8_t)a < b); }
	constexpr bool operator<(const std::uint8_t& a, const OpSize& b) { return (a < (std::uint8_t)b); }
	constexpr bool operator!=(const OpSize& a, const std::uint8_t& b) { return ((std::uint8_t)a != b); }
	constexpr bool operator!=(const std::uint8_t& a, const OpSize& b) { return (a != (std::uint8_t)b); }
	// GENERATOR-END: OpSize
	// GENERATOR-BEGIN: StateFlags
	// ⚠️This was generated by GENERATOR!🦹‍♂️
	enum class StateFlags : std::uint32_t {
		IpRel64  = 0x00000001,
		IpRel32  = 0x00000002,
		HasRex  = 0x00000008,
		b  = 0x00000010,
		z  = 0x00000020,
		IsInvalid  = 0x00000040,
		W  = 0x00000080,
		NoImm  = 0x00000100,
		Addr64  = 0x00000200,
		BranchImm8  = 0x00000400,
		Xbegin  = 0x00000800,
		Lock  = 0x00001000,
		AllowLock  = 0x00002000,
		NoMoreBytes  = 0x00004000,
		Has66  = 0x00008000,
		MvexSssMask  = 0x00000007,
		MvexSssShift  = 0x00000010,
		MvexEH  = 0x00080000,
		EncodingMask  = 0x00000007,
		EncodingShift  = 0x0000001D,
	};
	constexpr StateFlags& operator^=(StateFlags& a, const StateFlags& b) { return a = (StateFlags)((std::uint32_t)a ^ (std::uint32_t)b); }
	constexpr StateFlags operator^(const StateFlags& a, const StateFlags& b) { return (StateFlags)((std::uint32_t)a ^ (std::uint32_t)b); }
	constexpr StateFlags& operator|=(StateFlags& a, const StateFlags& b) { return a = (StateFlags)((std::uint32_t)a | (std::uint32_t)b); }
	constexpr StateFlags operator|(const StateFlags& a, const StateFlags& b) { return (StateFlags)((std::uint32_t)a | (std::uint32_t)b); }
	constexpr StateFlags& operator&=(StateFlags& a, const StateFlags& b) { return a = (StateFlags)((std::uint32_t)a & (std::uint32_t)b); }
	constexpr StateFlags operator&(const StateFlags& a, const StateFlags& b) { return (StateFlags)((std::uint32_t)a & (std::uint32_t)b); }
	constexpr StateFlags operator~(const StateFlags& a) { return (StateFlags)(~((std::uint32_t)a)); }
	constexpr std::uint32_t operator+(const StateFlags& a, const StateFlags& b) { return ((std::uint32_t)a + (std::uint32_t)b); }
	constexpr std::uint32_t operator+(const StateFlags& a, const std::uint32_t& b) { return ((std::uint32_t)a + b); }
	constexpr std::uint32_t operator+(const std::uint32_t& a, const StateFlags& b) { return (a + (std::uint32_t)b); }
	constexpr std::uint32_t operator-(const StateFlags& a, const StateFlags& b) { return ((std::uint32_t)a - (std::uint32_t)b); }
	constexpr std::uint32_t operator-(const StateFlags& a, const std::uint32_t& b) { return ((std::uint32_t)a - b); }
	constexpr std::uint32_t operator-(const std::uint32_t& a, const StateFlags& b) { return (a - (std::uint32_t)b); }
	constexpr StateFlags operator++(StateFlags& a, int) { auto temp = a; a = StateFlags(a + 1); return temp; }
	constexpr StateFlags& operator++(StateFlags& a) { return a = StateFlags(a + 1); }
	constexpr StateFlags operator--(StateFlags& a, int) { auto temp = a; a = StateFlags(a - 1); return temp; }
	constexpr StateFlags& operator--(StateFlags& a) { return a = StateFlags(a - 1); }
	constexpr bool operator==(const StateFlags& a, const std::uint32_t& b) { return ((std::uint32_t)a == b); }
	constexpr bool operator==(const std::uint32_t& a, const StateFlags& b) { return (a == (std::uint32_t)b); }
	constexpr bool operator>=(const StateFlags& a, const std::uint32_t& b) { return ((std::uint32_t)a >= b); }
	constexpr bool operator>=(const std::uint32_t& a, const StateFlags& b) { return (a >= (std::uint32_t)b); }
	constexpr bool operator<=(const StateFlags& a, const std::uint32_t& b) { return ((std::uint32_t)a <= b); }
	constexpr bool operator<=(const std::uint32_t& a, const StateFlags& b) { return (a <= (std::uint32_t)b); }
	constexpr bool operator>(const StateFlags& a, const std::uint32_t& b) { return ((std::uint32_t)a > b); }
	constexpr bool operator>(const std::uint32_t& a, const StateFlags& b) { return (a > (std::uint32_t)b); }
	constexpr bool operator<(const StateFlags& a, const std::uint32_t& b) { return ((std::uint32_t)a < b); }
	constexpr bool operator<(const std::uint32_t& a, const StateFlags& b) { return (a < (std::uint32_t)b); }
	constexpr bool operator!=(const StateFlags& a, const std::uint32_t& b) { return ((std::uint32_t)a != b); }
	constexpr bool operator!=(const std::uint32_t& a, const StateFlags& b) { return (a != (std::uint32_t)b); }
	// GENERATOR-END: StateFlags
	class RegInfo2 final
	{
	public:
		Register baseReg = static_cast<Register>(0);
		Register indexReg = static_cast<Register>(0);
		constexpr RegInfo2(Register baseReg, Register indexReg)
			: baseReg(baseReg), indexReg(indexReg)
		{
		}
		constexpr void Deconstruct(Register& baseReg, Register& indexReg) const
		{
			baseReg = this->baseReg;
			indexReg = this->indexReg;
		}
	private:
		friend class Decoder;
		RegInfo2() = default;
	};
	/// <summary>
	/// Decodes 16/32/64-bit x86 instructions
	/// </summary>
	class Decoder final : public std::vector<Instruction>
	{
	private:
		using OpCodeHandler = DecoderInternal::OpCodeHandler;
	private:
		std::int32_t Bitness = 0;
		std::uint64_t instructionPointer = 0;
		CodeReader * reader;
		std::vector<const OpCodeHandler*> handlers_MAP0;
#if !defined(NO_VEX) && defined(MVEX)
		std::vector<const OpCodeHandler*> handlers_VEX_MAP0;
#endif
#if !defined(NO_VEX)
		std::vector<const OpCodeHandler*> handlers_VEX_0F;
		std::vector<const OpCodeHandler*> handlers_VEX_0F38;
		std::vector<const OpCodeHandler*> handlers_VEX_0F3A;
#endif
#if !defined(NO_XOP)
		std::vector<const OpCodeHandler*> handlers_XOP_MAP8;
		std::vector<const OpCodeHandler*> handlers_XOP_MAP9;
		std::vector<const OpCodeHandler*> handlers_XOP_MAP10;
#endif
#if defined(MVEX)
		std::vector<const OpCodeHandler*> handlers_MVEX_0F;
		std::vector<const OpCodeHandler*> handlers_MVEX_0F38;
		std::vector<const OpCodeHandler*> handlers_MVEX_0F3A;
#endif
	public:
		class State
		{
		public:
			std::uint32_t modrm = 0, mod = 0, reg = 0, rm = 0;
			std::uint32_t instructionLength = 0;
			std::uint32_t extraRegisterBase = 0; // R << 3
			std::uint32_t extraIndexRegisterBase = 0; // X << 3
			std::uint32_t extraBaseRegisterBase = 0; // B << 3
			std::uint32_t extraIndexRegisterBaseVSIB = 0;
			StateFlags flags = static_cast<StateFlags>(0);
			MandatoryPrefixByte mandatoryPrefix = static_cast<MandatoryPrefixByte>(0);
			std::uint32_t vvvv = 0; // V`vvvv. Not stored in inverted form. If 16/32-bit mode, bits [4:3] are cleared
			std::uint32_t vvvv_invalidCheck = 0; // vvvv bits, even in 16/32-bit mode.
			std::uint32_t aaa = 0;
			std::uint32_t extraRegisterBaseEVEX = 0; // EVEX/MVEX.R' << 4
			std::uint32_t extraBaseRegisterBaseEVEX = 0; // EVEX/MVEX.XB << 3
			std::uint32_t vectorLength = 0;
			OpSize operandSize = static_cast<OpSize>(0);
			OpSize addressSize = static_cast<OpSize>(0);
			// 0=ES/CS/SS/DS, 1=FS/GS
			std::uint8_t segmentPrio = 0;
			constexpr EncodingKind GetEncoding() const
			{
				return static_cast<EncodingKind>((static_cast<std::uint32_t>(flags) >> static_cast<std::int32_t>(StateFlags::EncodingShift)) & static_cast<std::uint32_t>(StateFlags::EncodingMask));
			}
#if defined(MVEX)
			constexpr std::int32_t GetSss() const
			{
				return (static_cast<std::int32_t>(flags) >> static_cast<std::int32_t>(StateFlags::MvexSssShift)) & static_cast<std::int32_t>(StateFlags::MvexSssMask);
			}
#endif
			constexpr State() = default;
		};
	public:
		State state;
		std::uint32_t displIndex = 0;
		DecoderOptions options = static_cast<DecoderOptions>(0);
		std::uint32_t invalidCheckMask = 0; // All 1s if we should check for invalid instructions, else 0
		std::uint32_t is64bMode_and_W = 0; // StateFlags.W if 64-bit mode, 0 if 16/32-bit mode
		std::uint32_t reg15Mask = 0; // 7 in 16/32-bit mode, 15 in 64-bit mode
	private:
		std::uint32_t mask64b = 0;
	public:
		CodeSize defaultCodeSize = static_cast<CodeSize>(0);
		OpSize defaultOperandSize = static_cast<OpSize>(0);
	private:
		OpSize defaultAddressSize = static_cast<OpSize>(0);
	public:
		OpSize defaultInvertedOperandSize = static_cast<OpSize>(0);
		OpSize defaultInvertedAddressSize = static_cast<OpSize>(0);
		bool is64bMode = false;
		/// <summary>
		/// Current <c>IP</c>/<c>EIP</c>/<c>RIP</c> value.<br/>
		/// <br/>
		/// Writing to this property only updates the IP value, it does not change a <see cref="CodeReader"/>'s byte position.
		/// You can use <see cref="ByteArrayCodeReader.Position"/> to change its position.
		/// </summary>
	public:
		std::uint64_t GetIP() const;
		void SetIP(std::uint64_t value);
		/// <summary>
		/// Gets the bitness (16, 32 or 64)
		/// </summary>
		std::int32_t GetBitness() const;
	private:
		class StaticConstructor
		{
		public:
			StaticConstructor();
		};

	private:
		static Decoder::StaticConstructor staticConstructor;

		Decoder(CodeReader* reader, std::uint64_t ip, DecoderOptions options, std::int32_t bitness);
		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="reader">Code reader</param>
		/// <param name="ip"><c>RIP</c> value</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
	public:
		static Decoder Create(std::int32_t bitness, CodeReader* reader, std::uint64_t ip, DecoderOptions options = DecoderOptions::None);
		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="data">Data to decode</param>
		/// <param name="ip"><c>RIP</c> value</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		static Decoder Create(std::int32_t bitness, std::vector<std::uint8_t>& data, std::uint64_t ip, DecoderOptions options = DecoderOptions::None);
		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="reader">Code reader</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		static Decoder Create(std::int32_t bitness, CodeReader* reader, DecoderOptions options = DecoderOptions::None);
		/// <summary>
		/// Creates a decoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="data">Data to decode</param>
		/// <param name="options">Decoder options</param>
		/// <returns></returns>
		static Decoder Create(std::int32_t bitness, std::vector<std::uint8_t>& data, DecoderOptions options = DecoderOptions::None);
		std::uint32_t ReadByte();
		std::uint32_t ReadUInt16();
		std::uint32_t ReadUInt32();
		std::uint64_t ReadUInt64();
		/// <summary>
		/// Gets the last decoder error. Unless you need to know the reason it failed,
		/// it's better to check <see cref="Instruction.IsInvalid"/>.
		/// </summary>
		DecoderError GetLastError() const;
		/// <summary>
		/// Decodes the next instruction, see also <see cref="Decode(out Instruction)"/> which is faster
		/// if you already have an <see cref="Instruction"/> local, array element or field.
		/// <br/>
		/// See also <see cref="LastError"/>
		/// </summary>
		/// <returns></returns>
		Instruction Decode();
		/// <summary>
		/// Decodes the next instruction, see also <see cref="LastError"/>
		/// </summary>
		/// <param name="instruction">Decoded instruction</param>
		void Decode(Instruction& instruction);
		void ResetRexPrefixState();
		void CallOpCodeHandlerXXTable(Instruction& instruction);
		std::uint32_t GetCurrentInstructionPointer32();
		std::uint64_t GetCurrentInstructionPointer64();
		void ClearMandatoryPrefix(Instruction& instruction);
		void SetXacquireXrelease(Instruction& instruction);
		void ClearMandatoryPrefixF3(Instruction& instruction);
		void ClearMandatoryPrefixF2(Instruction& instruction);
		void SetInvalidInstruction();
		void DecodeTable(const std::span<const OpCodeHandler* const>& table, Instruction& instruction);
	private:
		void DecodeTable(const OpCodeHandler* handler, Instruction& instruction);
	public:
		void ReadModRM();
		void VEX2(Instruction& instruction);
		void VEX3(Instruction& instruction);
		void XOP(Instruction& instruction);
		void EVEX_MVEX(Instruction& instruction);
		Register ReadOpSegReg();
		bool ReadOpMem(Instruction& instruction);
		void ReadOpMemSib(Instruction& instruction);
		// All MPX instructions in 64-bit mode force 64-bit addressing, and
		// all MPX instructions in 16/32-bit mode require 32-bit addressing
		// (see SDM Vol 1, 17.5.1 Intel MPX and Operating Modes)
		void ReadOpMem_MPX(Instruction& instruction);
		void ReadOpMem(Instruction& instruction, TupleType tupleType);
		void ReadOpMem_VSIB(Instruction& instruction, Register vsibIndex, TupleType tupleType);
	private:
		inline static constexpr std::array s_memRegs16 = std::to_array({ RegInfo2(Register::BX, Register::SI), RegInfo2(Register::BX, Register::DI), RegInfo2(Register::BP, Register::SI), RegInfo2(Register::BP, Register::DI), RegInfo2(Register::SI, Register::None), RegInfo2(Register::DI, Register::None), RegInfo2(Register::BP, Register::None), RegInfo2(Register::BX, Register::None) });
		void ReadOpMem16(Instruction& instruction, TupleType tupleType);
		// Returns true if the SIB byte was read
		bool ReadOpMem32Or64(Instruction& instruction, Register baseReg, Register indexReg, TupleType tupleType, bool isVsib);
		std::uint32_t GetDisp8N(TupleType tupleType);
		/// <summary>
		/// Gets the offsets of the constants (memory displacement and immediate) in the decoded instruction.
		/// The caller can check if there are any relocations at those addresses.
		/// </summary>
		/// <param name="instruction">The latest instruction that was decoded by this decoder</param>
		/// <returns></returns>
	public:
		ConstantOffsets GetConstantOffsets(const Instruction& instruction);
	};
}

#include "DecoderInternal/OpCodeHandlers.h"
#endif
