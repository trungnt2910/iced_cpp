// C# helper headers
#include <csharp/classes.h>
#include <csharp/enum.h>
#include <csharp/interfaces.h>
#include <csharp/primitives.h>

// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#pragma once

#include "CodeWriter.h"
#include "EncoderInternal/EncoderOpCodeHandler.h"
#include "EncoderInternal/Enums.h"
#include "Iced.Intel.Instruction.h"
#include "OpKind.g.h"
#include "Register.g.h"
#include "ConstantOffsets.h"
#include <string>
#include <vector>
#include <limits>
#include <format>
#include <csharp/exceptionhelper.h>
#include <cassert>

// Code generated from Iced. Do not edit.
// Commit tag: badb6147c0994a4954fa27645aba2b02c2bb9502.
// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors
using namespace Iced::Intel::EncoderInternal;
namespace Iced::Intel
{
	/// <summary>
	/// Encodes instructions decoded by the decoder or instructions created by other code.
	/// See also BlockEncoder which can encode any number of instructions.
	/// </summary>
	class Encoder final
	{
		// GENERATOR-BEGIN: ImmSizes
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	private:
		static std::vector<std::uint32_t> s_immSizes;
		// GENERATOR-END: ImmSizes
		/// <summary>
		/// Disables 2-byte VEX encoding and encodes all VEX instructions with the 3-byte VEX encoding
		/// </summary>
	public:
		bool GetPreventVEX2() const;
		void SetPreventVEX2(bool value);
		std::uint32_t Internal_PreventVEX2 = 0;
		/// <summary>
		/// Value of the <c>VEX.W</c> bit to use if it's an instruction that ignores the bit. Default is 0.
		/// </summary>
		std::uint32_t GetVexWig() const;
		void SetVexWig(std::uint32_t value);
		std::uint32_t Internal_VEX_WIG_LIG = 0;
		std::uint32_t Internal_VEX_LIG = 0;
		/// <summary>
		/// Value of the <c>VEX.L</c> bit to use if it's an instruction that ignores the bit. Default is 0.
		/// </summary>
		std::uint32_t GetVexLig() const;
		void SetVexLig(std::uint32_t value);
		/// <summary>
		/// Value of the <c>EVEX.W</c> bit to use if it's an instruction that ignores the bit. Default is 0.
		/// </summary>
		std::uint32_t GetEvexWig() const;
		void SetEvexWig(std::uint32_t value);
		std::uint32_t Internal_EVEX_WIG = 0;
		/// <summary>
		/// Value of the <c>EVEX.L'L</c> bits to use if it's an instruction that ignores the bits. Default is 0.
		/// </summary>
		std::uint32_t GetEvexLig() const;
		void SetEvexLig(std::uint32_t value);
		std::uint32_t Internal_EVEX_LIG = 0;
		/// <summary>
		/// Value of the <c>MVEX.W</c> bit to use if it's an instruction that ignores the bit. Default is 0.
		/// </summary>
		std::uint32_t GetMvexWig() const;
		void SetMvexWig(std::uint32_t value);
		std::uint32_t Internal_MVEX_WIG = 0;
		static const std::string ERROR_ONLY_1632_BIT_MODE;
		static const std::string ERROR_ONLY_64_BIT_MODE;
		/* readonly */
	private:
		CodeWriter* writer;
		/* readonly */
		std::int32_t bitness = 0;
		/* readonly */
		std::vector<OpCodeHandler*> handlers;
		/* readonly */
		std::vector<std::uint32_t> immSizes;
		std::uint64_t currentRip = 0;
		//C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
		//ORIGINAL LINE: string? errorMessage;
		std::string errorMessage;
		OpCodeHandler* handler;
		std::uint32_t eip = 0;
		std::uint32_t displAddr = 0;
		std::uint32_t immAddr = 0;
	public:
		std::uint32_t Immediate = 0;
		// high 32 bits if it's a 64-bit immediate
		// high 32 bits if it's an IP relative immediate (jcc,call target)
		// high 32 bits if it's a 64-bit absolute address
		std::uint32_t ImmediateHi = 0;
	private:
		std::uint32_t Displ = 0;
		// high 32 bits if it's an IP relative mem displ (target)
		std::uint32_t DisplHi = 0;
		/* readonly */
		EncoderFlags opSize16Flags = static_cast<EncoderFlags>(0);
		/* readonly */
		EncoderFlags opSize32Flags = static_cast<EncoderFlags>(0);
		/* readonly */
		EncoderFlags adrSize16Flags = static_cast<EncoderFlags>(0);
		/* readonly */
		EncoderFlags adrSize32Flags = static_cast<EncoderFlags>(0);
	public:
		std::uint32_t OpCode = 0;
		EncoderFlags EncoderFlags = static_cast<EncoderFlags>(0);
	private:
		DisplSize DisplSize = static_cast<DisplSize>(0);
	public:
		ImmSize ImmSize = static_cast<ImmSize>(0);
	private:
		std::uint8_t ModRM = 0;
		std::uint8_t Sib = 0;
		/// <summary>
		/// Gets the bitness (16, 32 or 64)
		/// </summary>
	public:
		std::int32_t GetBitness() const;
	private:
		Encoder(CodeWriter* writer, std::int32_t bitness);
		/// <summary>
		/// Creates an encoder
		/// </summary>
		/// <param name="bitness">16, 32 or 64</param>
		/// <param name="writer">Destination</param>
		/// <returns></returns>
	public:
		static Encoder* Create(std::int32_t bitness, CodeWriter* writer);
		/// <summary>
		/// Encodes an instruction and returns the size of the encoded instruction.
		/// A <see cref="EncoderException"/> is thrown if it failed to encode the instruction.
		/// </summary>
		/// <param name="instruction">Instruction to encode</param>
		/// <param name="rip">RIP of the encoded instruction</param>
		/// <returns></returns>
		std::uint32_t Encode(Instruction const instruction, std::uint64_t rip);
	private:
		static void ThrowEncoderException(Instruction const instruction, const std::string& errorMessage);
		/// <summary>
		/// Encodes an instruction
		/// </summary>
		/// <param name="instruction">Instruction to encode</param>
		/// <param name="rip"><c>RIP</c> of the encoded instruction</param>
		/// <param name="encodedLength">Updated with length of encoded instruction if successful</param>
		/// <param name="errorMessage">Set to the error message if we couldn't encode the instruction</param>
		/// <returns></returns>
	public:
		//C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
		//ORIGINAL LINE: public bool TryEncode(in Instruction instruction, ulong rip, out uint encodedLength, [NotNullWhen(false)] out string? errorMessage)
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		bool TryEncode(Instruction const instruction, std::uint64_t rip, std::uint32_t& encodedLength, std::string& errorMessage);
		//C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
		//ORIGINAL LINE: internal string? ErrorMessage
		void SetErrorMessage(const std::string& value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal bool Verify(int operand, OpKind expected, OpKind actual)
		bool Verify(std::int32_t operand, OpKind expected, OpKind actual);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal bool Verify(int operand, Register expected, Register actual)
		bool Verify(std::int32_t operand, Register expected, Register actual);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal bool Verify(int operand, Register register, Register regLo, Register regHi)
		bool Verify(std::int32_t operand, Register register_, Register regLo, Register regHi);
		void AddBranch(OpKind opKind, std::int32_t immSize, Instruction const instruction, std::int32_t operand);
		void AddBranchX(std::int32_t immSize, Instruction const instruction, std::int32_t operand);
		void AddBranchDisp(std::int32_t displSize, Instruction const instruction, std::int32_t operand);
		void AddFarBranch(Instruction const instruction, std::int32_t operand, std::int32_t size);
		void SetAddrSize(std::int32_t regSize);
		void AddAbsMem(Instruction const instruction, std::int32_t operand);
		void AddModRMRegister(Instruction const instruction, std::int32_t operand, Register regLo, Register regHi);
		void AddReg(Instruction const instruction, std::int32_t operand, Register regLo, Register regHi);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void AddRegOrMem(in Instruction instruction, int operand, Register regLo, Register regHi, bool allowMemOp, bool allowRegOp)
		void AddRegOrMem(Instruction const instruction, std::int32_t operand, Register regLo, Register regHi, bool allowMemOp, bool allowRegOp);
		void AddRegOrMem(Instruction const instruction, std::int32_t operand, Register regLo, Register regHi, Register vsibIndexRegLo, Register vsibIndexRegHi, bool allowMemOp, bool allowRegOp);
	private:
		static std::int32_t GetRegisterOpSize(Instruction const instruction);
		bool TryConvertToDisp8N(Instruction const instruction, std::int32_t displ, std::int8_t& compressedValue);
		void AddMemOp16(Instruction const instruction, std::int32_t operand);
		void AddMemOp(Instruction const instruction, std::int32_t operand, std::int32_t addrSize, Register vsibIndexRegLo, Register vsibIndexRegHi);
		static std::vector<std::uint8_t> SegmentOverrides;
	public:
		void WritePrefixes(Instruction const instruction, bool canWriteF3 = true);
	private:
		void WriteModRM();
		void WriteImmediate();
		/// <summary>
		/// Writes a byte to the output buffer
		/// </summary>
		/// <param name="value">Value to write</param>
	public:
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] public void WriteByte(byte value)
		void WriteByte(std::uint8_t value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void WriteByteInternal(uint value)
		void WriteByteInternal(std::uint32_t value);
		/// <summary>
		/// Gets the offsets of the constants (memory displacement and immediate) in the encoded instruction.
		/// The caller can use this information to add relocations if needed.
		/// </summary>
		/// <returns></returns>
		ConstantOffsets GetConstantOffsets();
	};
}
