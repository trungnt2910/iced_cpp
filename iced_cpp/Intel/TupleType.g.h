/* 
SPDX-License-Identifier: MIT
Copyright (C) 2018-present iced project and contributors
 */

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once

#if defined(DECODER) || defined(ENCODER) || (defined(ENCODER) && defined(OPCODE_INFO))
#include <array>
#include <stdexcept>
#include <string>
#include "ToString.h"
#include "Internal/StringHelpers.h"
namespace Iced::Intel {
	enum class TupleType {
		/// <summary><c>N = 1</c></summary>
		N1  = 0,
		/// <summary><c>N = 2</c></summary>
		N2  = 1,
		/// <summary><c>N = 4</c></summary>
		N4  = 2,
		/// <summary><c>N = 8</c></summary>
		N8  = 3,
		/// <summary><c>N = 16</c></summary>
		N16  = 4,
		/// <summary><c>N = 32</c></summary>
		N32  = 5,
		/// <summary><c>N = 64</c></summary>
		N64  = 6,
		/// <summary><c>N = b ? 4 : 8</c></summary>
		N8b4  = 7,
		/// <summary><c>N = b ? 4 : 16</c></summary>
		N16b4  = 8,
		/// <summary><c>N = b ? 4 : 32</c></summary>
		N32b4  = 9,
		/// <summary><c>N = b ? 4 : 64</c></summary>
		N64b4  = 10,
		/// <summary><c>N = b ? 8 : 16</c></summary>
		N16b8  = 11,
		/// <summary><c>N = b ? 8 : 32</c></summary>
		N32b8  = 12,
		/// <summary><c>N = b ? 8 : 64</c></summary>
		N64b8  = 13,
		/// <summary><c>N = b ? 2 : 4</c></summary>
		N4b2  = 14,
		/// <summary><c>N = b ? 2 : 8</c></summary>
		N8b2  = 15,
		/// <summary><c>N = b ? 2 : 16</c></summary>
		N16b2  = 16,
		/// <summary><c>N = b ? 2 : 32</c></summary>
		N32b2  = 17,
		/// <summary><c>N = b ? 2 : 64</c></summary>
		N64b2  = 18,
	};
	constexpr int operator+(const TupleType& a, const TupleType& b) { return ((int)a + (int)b); }
	constexpr int operator+(const TupleType& a, const int& b) { return ((int)a + b); }
	constexpr int operator+(const int& a, const TupleType& b) { return (a + (int)b); }
	constexpr int operator-(const TupleType& a, const TupleType& b) { return ((int)a - (int)b); }
	constexpr int operator-(const TupleType& a, const int& b) { return ((int)a - b); }
	constexpr int operator-(const int& a, const TupleType& b) { return (a - (int)b); }
	constexpr TupleType operator++(TupleType& a, int) { auto temp = a; a = TupleType(a + 1); return temp; }
	constexpr TupleType& operator++(TupleType& a) { return a = TupleType(a + 1); }
	constexpr TupleType operator--(TupleType& a, int) { auto temp = a; a = TupleType(a - 1); return temp; }
	constexpr TupleType& operator--(TupleType& a) { return a = TupleType(a - 1); }
	constexpr bool operator==(const TupleType& a, const int& b) { return ((int)a == b); }
	constexpr bool operator==(const int& a, const TupleType& b) { return (a == (int)b); }
	constexpr bool operator>=(const TupleType& a, const int& b) { return ((int)a >= b); }
	constexpr bool operator>=(const int& a, const TupleType& b) { return (a >= (int)b); }
	constexpr bool operator<=(const TupleType& a, const int& b) { return ((int)a <= b); }
	constexpr bool operator<=(const int& a, const TupleType& b) { return (a <= (int)b); }
	constexpr bool operator>(const TupleType& a, const int& b) { return ((int)a > b); }
	constexpr bool operator>(const int& a, const TupleType& b) { return (a > (int)b); }
	constexpr bool operator<(const TupleType& a, const int& b) { return ((int)a < b); }
	constexpr bool operator<(const int& a, const TupleType& b) { return (a < (int)b); }
	constexpr bool operator!=(const TupleType& a, const int& b) { return ((int)a != b); }
	constexpr bool operator!=(const int& a, const TupleType& b) { return (a != (int)b); }
}
template <>
constexpr std::string Iced::Intel::ToString(const Iced::Intel::TupleType& e) {
	switch (e) {
		case Iced::Intel::TupleType::N1: return "N1";
		case Iced::Intel::TupleType::N2: return "N2";
		case Iced::Intel::TupleType::N4: return "N4";
		case Iced::Intel::TupleType::N8: return "N8";
		case Iced::Intel::TupleType::N16: return "N16";
		case Iced::Intel::TupleType::N32: return "N32";
		case Iced::Intel::TupleType::N64: return "N64";
		case Iced::Intel::TupleType::N8b4: return "N8b4";
		case Iced::Intel::TupleType::N16b4: return "N16b4";
		case Iced::Intel::TupleType::N32b4: return "N32b4";
		case Iced::Intel::TupleType::N64b4: return "N64b4";
		case Iced::Intel::TupleType::N16b8: return "N16b8";
		case Iced::Intel::TupleType::N32b8: return "N32b8";
		case Iced::Intel::TupleType::N64b8: return "N64b8";
		case Iced::Intel::TupleType::N4b2: return "N4b2";
		case Iced::Intel::TupleType::N8b2: return "N8b2";
		case Iced::Intel::TupleType::N16b2: return "N16b2";
		case Iced::Intel::TupleType::N32b2: return "N32b2";
		case Iced::Intel::TupleType::N64b2: return "N64b2";
		default: return Internal::StringHelpers::ToDec((int)e);
	}
}
#endif
