/* 
SPDX-License-Identifier: MIT
Copyright (C) 2018-present iced project and contributors
 */

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once

#if defined(INSTR_INFO)
#include <array>
#include <stdexcept>
#include <string>
#include "ToString.h"
#include "Internal/StringHelpers.h"
namespace Iced::Intel {
	enum class ConditionCode {
		/// <summary>The instruction doesn&apos;t have a condition code</summary>
		None  = 0,
		/// <summary>Overflow (<c>OF=1</c>)</summary>
		o  = 1,
		/// <summary>Not overflow (<c>OF=0</c>)</summary>
		no  = 2,
		/// <summary>Below (unsigned) (<c>CF=1</c>)</summary>
		b  = 3,
		/// <summary>Above or equal (unsigned) (<c>CF=0</c>)</summary>
		ae  = 4,
		/// <summary>Equal / zero (<c>ZF=1</c>)</summary>
		e  = 5,
		/// <summary>Not equal / zero (<c>ZF=0</c>)</summary>
		ne  = 6,
		/// <summary>Below or equal (unsigned) (<c>CF=1 or ZF=1</c>)</summary>
		be  = 7,
		/// <summary>Above (unsigned) (<c>CF=0 and ZF=0</c>)</summary>
		a  = 8,
		/// <summary>Signed (<c>SF=1</c>)</summary>
		s  = 9,
		/// <summary>Not signed (<c>SF=0</c>)</summary>
		ns  = 10,
		/// <summary>Parity (<c>PF=1</c>)</summary>
		p  = 11,
		/// <summary>Not parity (<c>PF=0</c>)</summary>
		np  = 12,
		/// <summary>Less (signed) (<c>SF!=OF</c>)</summary>
		l  = 13,
		/// <summary>Greater than or equal (signed) (<c>SF=OF</c>)</summary>
		ge  = 14,
		/// <summary>Less than or equal (signed) (<c>ZF=1 or SF!=OF</c>)</summary>
		le  = 15,
		/// <summary>Greater (signed) (<c>ZF=0 and SF=OF</c>)</summary>
		g  = 16,
	};
	constexpr int operator+(const ConditionCode& a, const ConditionCode& b) { return ((int)a + (int)b); }
	constexpr int operator+(const ConditionCode& a, const int& b) { return ((int)a + b); }
	constexpr int operator+(const int& a, const ConditionCode& b) { return (a + (int)b); }
	constexpr int operator-(const ConditionCode& a, const ConditionCode& b) { return ((int)a - (int)b); }
	constexpr int operator-(const ConditionCode& a, const int& b) { return ((int)a - b); }
	constexpr int operator-(const int& a, const ConditionCode& b) { return (a - (int)b); }
	constexpr ConditionCode operator++(ConditionCode& a, int) { auto temp = a; a = ConditionCode(a + 1); return temp; }
	constexpr ConditionCode& operator++(ConditionCode& a) { return a = ConditionCode(a + 1); }
	constexpr ConditionCode operator--(ConditionCode& a, int) { auto temp = a; a = ConditionCode(a - 1); return temp; }
	constexpr ConditionCode& operator--(ConditionCode& a) { return a = ConditionCode(a - 1); }
	constexpr bool operator==(const ConditionCode& a, const int& b) { return ((int)a == b); }
	constexpr bool operator==(const int& a, const ConditionCode& b) { return (a == (int)b); }
	constexpr bool operator>=(const ConditionCode& a, const int& b) { return ((int)a >= b); }
	constexpr bool operator>=(const int& a, const ConditionCode& b) { return (a >= (int)b); }
	constexpr bool operator<=(const ConditionCode& a, const int& b) { return ((int)a <= b); }
	constexpr bool operator<=(const int& a, const ConditionCode& b) { return (a <= (int)b); }
	constexpr bool operator>(const ConditionCode& a, const int& b) { return ((int)a > b); }
	constexpr bool operator>(const int& a, const ConditionCode& b) { return (a > (int)b); }
	constexpr bool operator<(const ConditionCode& a, const int& b) { return ((int)a < b); }
	constexpr bool operator<(const int& a, const ConditionCode& b) { return (a < (int)b); }
	constexpr bool operator!=(const ConditionCode& a, const int& b) { return ((int)a != b); }
	constexpr bool operator!=(const int& a, const ConditionCode& b) { return (a != (int)b); }
}
template <>
constexpr std::string Iced::Intel::ToString(const Iced::Intel::ConditionCode& e) {
	switch (e) {
		case Iced::Intel::ConditionCode::None: return "None";
		case Iced::Intel::ConditionCode::o: return "o";
		case Iced::Intel::ConditionCode::no: return "no";
		case Iced::Intel::ConditionCode::b: return "b";
		case Iced::Intel::ConditionCode::ae: return "ae";
		case Iced::Intel::ConditionCode::e: return "e";
		case Iced::Intel::ConditionCode::ne: return "ne";
		case Iced::Intel::ConditionCode::be: return "be";
		case Iced::Intel::ConditionCode::a: return "a";
		case Iced::Intel::ConditionCode::s: return "s";
		case Iced::Intel::ConditionCode::ns: return "ns";
		case Iced::Intel::ConditionCode::p: return "p";
		case Iced::Intel::ConditionCode::np: return "np";
		case Iced::Intel::ConditionCode::l: return "l";
		case Iced::Intel::ConditionCode::ge: return "ge";
		case Iced::Intel::ConditionCode::le: return "le";
		case Iced::Intel::ConditionCode::g: return "g";
		default: return Internal::StringHelpers::ToDec((int)e);
	}
}
#endif
