/* 
SPDX-License-Identifier: MIT
Copyright (C) 2018-present iced project and contributors
 */

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once

#if defined(INSTR_INFO)
#include <array>
#include <stdexcept>
#include <string>
#include "ToString.h"
#include "Internal/StringHelpers.h"
namespace Iced::Intel {
	enum class OpAccess {
		/// <summary>Nothing is read and nothing is written</summary>
		None  = 0,
		/// <summary>The value is read</summary>
		Read  = 1,
		/// <summary>The value is sometimes read and sometimes not</summary>
		CondRead  = 2,
		/// <summary>The value is completely overwritten</summary>
		Write  = 3,
		/// <summary>Conditional write, sometimes it&apos;s written and sometimes it&apos;s not modified</summary>
		CondWrite  = 4,
		/// <summary>The value is read and written</summary>
		ReadWrite  = 5,
		/// <summary>The value is read and sometimes written</summary>
		ReadCondWrite  = 6,
		/// <summary>The memory operand doesn&apos;t refer to memory (eg. <c>LEA</c> instruction) or it&apos;s an instruction that doesn&apos;t read the data to a register or doesn&apos;t write to the memory location, it just prefetches/invalidates it, eg. <c>INVLPG</c>, <c>PREFETCHNTA</c>, <c>VGATHERPF0DPS</c>, etc. Some of those instructions still check if the code can access the memory location.</summary>
		NoMemAccess  = 7,
	};
	constexpr int operator+(const OpAccess& a, const OpAccess& b) { return ((int)a + (int)b); }
	constexpr int operator+(const OpAccess& a, const int& b) { return ((int)a + b); }
	constexpr int operator+(const int& a, const OpAccess& b) { return (a + (int)b); }
	constexpr int operator-(const OpAccess& a, const OpAccess& b) { return ((int)a - (int)b); }
	constexpr int operator-(const OpAccess& a, const int& b) { return ((int)a - b); }
	constexpr int operator-(const int& a, const OpAccess& b) { return (a - (int)b); }
	constexpr OpAccess operator++(OpAccess& a, int) { auto temp = a; a = OpAccess(a + 1); return temp; }
	constexpr OpAccess& operator++(OpAccess& a) { return a = OpAccess(a + 1); }
	constexpr OpAccess operator--(OpAccess& a, int) { auto temp = a; a = OpAccess(a - 1); return temp; }
	constexpr OpAccess& operator--(OpAccess& a) { return a = OpAccess(a - 1); }
	constexpr bool operator==(const OpAccess& a, const int& b) { return ((int)a == b); }
	constexpr bool operator==(const int& a, const OpAccess& b) { return (a == (int)b); }
	constexpr bool operator>=(const OpAccess& a, const int& b) { return ((int)a >= b); }
	constexpr bool operator>=(const int& a, const OpAccess& b) { return (a >= (int)b); }
	constexpr bool operator<=(const OpAccess& a, const int& b) { return ((int)a <= b); }
	constexpr bool operator<=(const int& a, const OpAccess& b) { return (a <= (int)b); }
	constexpr bool operator>(const OpAccess& a, const int& b) { return ((int)a > b); }
	constexpr bool operator>(const int& a, const OpAccess& b) { return (a > (int)b); }
	constexpr bool operator<(const OpAccess& a, const int& b) { return ((int)a < b); }
	constexpr bool operator<(const int& a, const OpAccess& b) { return (a < (int)b); }
	constexpr bool operator!=(const OpAccess& a, const int& b) { return ((int)a != b); }
	constexpr bool operator!=(const int& a, const OpAccess& b) { return (a != (int)b); }
}
template <>
constexpr std::string Iced::Intel::ToString(const Iced::Intel::OpAccess& e) {
	switch (e) {
		case Iced::Intel::OpAccess::None: return "None";
		case Iced::Intel::OpAccess::Read: return "Read";
		case Iced::Intel::OpAccess::CondRead: return "CondRead";
		case Iced::Intel::OpAccess::Write: return "Write";
		case Iced::Intel::OpAccess::CondWrite: return "CondWrite";
		case Iced::Intel::OpAccess::ReadWrite: return "ReadWrite";
		case Iced::Intel::OpAccess::ReadCondWrite: return "ReadCondWrite";
		case Iced::Intel::OpAccess::NoMemAccess: return "NoMemAccess";
		default: return Internal::StringHelpers::ToDec((int)e);
	}
}
#endif
