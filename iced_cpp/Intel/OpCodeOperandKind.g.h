/* 
SPDX-License-Identifier: MIT
Copyright (C) 2018-present iced project and contributors
 */

// ‚ö†Ô∏èThis file was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è

#pragma once

#if defined(ENCODER) && defined(OPCODE_INFO)
#include <array>
#include <stdexcept>
#include <string>
#include "ToString.h"
#include "Internal/StringHelpers.h"
namespace Iced::Intel {
	enum class OpCodeOperandKind {
		/// <summary>No operand</summary>
		None  = 0,
		/// <summary>Far branch 16-bit offset, 16-bit segment/selector</summary>
		farbr2_2  = 1,
		/// <summary>Far branch 32-bit offset, 16-bit segment/selector</summary>
		farbr4_2  = 2,
		/// <summary>Memory offset without a modrm byte (eg. <c>MOV AL,[offset]</c>)</summary>
		mem_offs  = 3,
		/// <summary>Memory (modrm)</summary>
		mem  = 4,
		/// <summary>Memory (modrm), MPX:<br/>
		/// <br/>
		/// 16/32-bit mode: must be 32-bit addressing<br/>
		/// <br/>
		/// 64-bit mode: 64-bit addressing is forced and must not be RIP relative</summary>
		mem_mpx  = 5,
		/// <summary>Memory (modrm), MPX:<br/>
		/// <br/>
		/// 16/32-bit mode: must be 32-bit addressing<br/>
		/// <br/>
		/// 64-bit mode: 64-bit addressing is forced and must not be RIP relative</summary>
		mem_mib  = 6,
		/// <summary>Memory (modrm), vsib32, <c>XMM</c> registers</summary>
		mem_vsib32x  = 7,
		/// <summary>Memory (modrm), vsib64, <c>XMM</c> registers</summary>
		mem_vsib64x  = 8,
		/// <summary>Memory (modrm), vsib32, <c>YMM</c> registers</summary>
		mem_vsib32y  = 9,
		/// <summary>Memory (modrm), vsib64, <c>YMM</c> registers</summary>
		mem_vsib64y  = 10,
		/// <summary>Memory (modrm), vsib32, <c>ZMM</c> registers</summary>
		mem_vsib32z  = 11,
		/// <summary>Memory (modrm), vsib64, <c>ZMM</c> registers</summary>
		mem_vsib64z  = 12,
		/// <summary>8-bit GPR or memory</summary>
		r8_or_mem  = 13,
		/// <summary>16-bit GPR or memory</summary>
		r16_or_mem  = 14,
		/// <summary>32-bit GPR or memory</summary>
		r32_or_mem  = 15,
		/// <summary>32-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced</summary>
		r32_or_mem_mpx  = 16,
		/// <summary>64-bit GPR or memory</summary>
		r64_or_mem  = 17,
		/// <summary>64-bit GPR or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced</summary>
		r64_or_mem_mpx  = 18,
		/// <summary><c>MM</c> register or memory</summary>
		mm_or_mem  = 19,
		/// <summary><c>XMM</c> register or memory</summary>
		xmm_or_mem  = 20,
		/// <summary><c>YMM</c> register or memory</summary>
		ymm_or_mem  = 21,
		/// <summary><c>ZMM</c> register or memory</summary>
		zmm_or_mem  = 22,
		/// <summary><c>BND</c> register or memory, MPX: 16/32-bit mode: must be 32-bit addressing, 64-bit mode: 64-bit addressing is forced</summary>
		bnd_or_mem_mpx  = 23,
		/// <summary><c>K</c> register or memory</summary>
		k_or_mem  = 24,
		/// <summary>8-bit GPR encoded in the <c>reg</c> field of the modrm byte</summary>
		r8_reg  = 25,
		/// <summary>8-bit GPR encoded in the low 3 bits of the opcode</summary>
		r8_opcode  = 26,
		/// <summary>16-bit GPR encoded in the <c>reg</c> field of the modrm byte</summary>
		r16_reg  = 27,
		/// <summary>16-bit GPR encoded in the <c>reg</c> field of the modrm byte. This is a memory operand and it uses the address size prefix (<c>67h</c>) not the operand size prefix (<c>66h</c>).</summary>
		r16_reg_mem  = 28,
		/// <summary>16-bit GPR encoded in the <c>mod + r/m</c> fields of the modrm byte</summary>
		r16_rm  = 29,
		/// <summary>16-bit GPR encoded in the low 3 bits of the opcode</summary>
		r16_opcode  = 30,
		/// <summary>32-bit GPR encoded in the <c>reg</c> field of the modrm byte</summary>
		r32_reg  = 31,
		/// <summary>32-bit GPR encoded in the <c>reg</c> field of the modrm byte. This is a memory operand and it uses the address size prefix (<c>67h</c>) not the operand size prefix (<c>66h</c>).</summary>
		r32_reg_mem  = 32,
		/// <summary>32-bit GPR encoded in the <c>mod + r/m</c> fields of the modrm byte</summary>
		r32_rm  = 33,
		/// <summary>32-bit GPR encoded in the low 3 bits of the opcode</summary>
		r32_opcode  = 34,
		/// <summary>32-bit GPR encoded in the the <c>V&apos;vvvv</c> field (VEX/EVEX/XOP)</summary>
		r32_vvvv  = 35,
		/// <summary>64-bit GPR encoded in the <c>reg</c> field of the modrm byte</summary>
		r64_reg  = 36,
		/// <summary>64-bit GPR encoded in the <c>reg</c> field of the modrm byte. This is a memory operand and it uses the address size prefix (<c>67h</c>) not the operand size prefix (<c>66h</c>).</summary>
		r64_reg_mem  = 37,
		/// <summary>64-bit GPR encoded in the <c>mod + r/m</c> fields of the modrm byte</summary>
		r64_rm  = 38,
		/// <summary>64-bit GPR encoded in the low 3 bits of the opcode</summary>
		r64_opcode  = 39,
		/// <summary>64-bit GPR encoded in the the <c>V&apos;vvvv</c> field (VEX/EVEX/XOP)</summary>
		r64_vvvv  = 40,
		/// <summary>Segment register encoded in the <c>reg</c> field of the modrm byte</summary>
		seg_reg  = 41,
		/// <summary><c>K</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		k_reg  = 42,
		/// <summary><c>K</c> register (+1) encoded in the <c>reg</c> field of the modrm byte</summary>
		kp1_reg  = 43,
		/// <summary><c>K</c> register encoded in the <c>mod + r/m</c> fields of the modrm byte</summary>
		k_rm  = 44,
		/// <summary><c>K</c> register encoded in the the <c>V&apos;vvvv</c> field (VEX/EVEX/MVEX/XOP)</summary>
		k_vvvv  = 45,
		/// <summary><c>MM</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		mm_reg  = 46,
		/// <summary><c>MM</c> register encoded in the <c>mod + r/m</c> fields of the modrm byte</summary>
		mm_rm  = 47,
		/// <summary><c>XMM</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		xmm_reg  = 48,
		/// <summary><c>XMM</c> register encoded in the <c>mod + r/m</c> fields of the modrm byte</summary>
		xmm_rm  = 49,
		/// <summary><c>XMM</c> register encoded in the the <c>V&apos;vvvv</c> field (VEX/EVEX/XOP)</summary>
		xmm_vvvv  = 50,
		/// <summary><c>XMM</c> register (+3) encoded in the the <c>V&apos;vvvv</c> field (VEX/EVEX/XOP)</summary>
		xmmp3_vvvv  = 51,
		/// <summary><c>XMM</c> register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only <c>XMM0</c>-<c>XMM15</c>)</summary>
		xmm_is4  = 52,
		/// <summary><c>XMM</c> register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only <c>XMM0</c>-<c>XMM15</c>)</summary>
		xmm_is5  = 53,
		/// <summary><c>YMM</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		ymm_reg  = 54,
		/// <summary><c>YMM</c> register encoded in the <c>mod + r/m</c> fields of the modrm byte</summary>
		ymm_rm  = 55,
		/// <summary><c>YMM</c> register encoded in the the <c>V&apos;vvvv</c> field (VEX/EVEX/XOP)</summary>
		ymm_vvvv  = 56,
		/// <summary><c>YMM</c> register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only <c>YMM0</c>-<c>YMM15</c>)</summary>
		ymm_is4  = 57,
		/// <summary><c>YMM</c> register encoded in the the high 4 bits of the last 8-bit immediate (VEX/XOP only so only <c>YMM0</c>-<c>YMM15</c>)</summary>
		ymm_is5  = 58,
		/// <summary><c>ZMM</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		zmm_reg  = 59,
		/// <summary><c>ZMM</c> register encoded in the <c>mod + r/m</c> fields of the modrm byte</summary>
		zmm_rm  = 60,
		/// <summary><c>ZMM</c> register encoded in the the <c>V&apos;vvvv</c> field (VEX/EVEX/MVEX/XOP)</summary>
		zmm_vvvv  = 61,
		/// <summary><c>ZMM</c> register (+3) encoded in the the <c>V&apos;vvvv</c> field (VEX/EVEX/XOP)</summary>
		zmmp3_vvvv  = 62,
		/// <summary><c>CR</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		cr_reg  = 63,
		/// <summary><c>DR</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		dr_reg  = 64,
		/// <summary><c>TR</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		tr_reg  = 65,
		/// <summary><c>BND</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		bnd_reg  = 66,
		/// <summary><c>ES</c> register</summary>
		es  = 67,
		/// <summary><c>CS</c> register</summary>
		cs  = 68,
		/// <summary><c>SS</c> register</summary>
		ss  = 69,
		/// <summary><c>DS</c> register</summary>
		ds  = 70,
		/// <summary><c>FS</c> register</summary>
		fs  = 71,
		/// <summary><c>GS</c> register</summary>
		gs  = 72,
		/// <summary><c>AL</c> register</summary>
		al  = 73,
		/// <summary><c>CL</c> register</summary>
		cl  = 74,
		/// <summary><c>AX</c> register</summary>
		ax  = 75,
		/// <summary><c>DX</c> register</summary>
		dx  = 76,
		/// <summary><c>EAX</c> register</summary>
		eax  = 77,
		/// <summary><c>RAX</c> register</summary>
		rax  = 78,
		/// <summary><c>ST(0)</c> register</summary>
		st0  = 79,
		/// <summary><c>ST(i)</c> register encoded in the low 3 bits of the opcode</summary>
		sti_opcode  = 80,
		/// <summary>4-bit immediate (m2z field, low 4 bits of the /is5 immediate, eg. <c>VPERMIL2PS</c>)</summary>
		imm4_m2z  = 81,
		/// <summary>8-bit immediate</summary>
		imm8  = 82,
		/// <summary>Constant 1 (8-bit immediate)</summary>
		imm8_const_1  = 83,
		/// <summary>8-bit immediate sign extended to 16 bits</summary>
		imm8sex16  = 84,
		/// <summary>8-bit immediate sign extended to 32 bits</summary>
		imm8sex32  = 85,
		/// <summary>8-bit immediate sign extended to 64 bits</summary>
		imm8sex64  = 86,
		/// <summary>16-bit immediate</summary>
		imm16  = 87,
		/// <summary>32-bit immediate</summary>
		imm32  = 88,
		/// <summary>32-bit immediate sign extended to 64 bits</summary>
		imm32sex64  = 89,
		/// <summary>64-bit immediate</summary>
		imm64  = 90,
		/// <summary><c>seg:[rSI]</c> memory operand (string instructions)</summary>
		seg_rSI  = 91,
		/// <summary><c>es:[rDI]</c> memory operand (string instructions)</summary>
		es_rDI  = 92,
		/// <summary><c>seg:[rDI]</c> memory operand (<c>(V)MASKMOVQ</c> instructions)</summary>
		seg_rDI  = 93,
		/// <summary><c>seg:[rBX+al]</c> memory operand (<c>XLATB</c> instruction)</summary>
		seg_rBX_al  = 94,
		/// <summary>16-bit branch, 1-byte signed relative offset</summary>
		br16_1  = 95,
		/// <summary>32-bit branch, 1-byte signed relative offset</summary>
		br32_1  = 96,
		/// <summary>64-bit branch, 1-byte signed relative offset</summary>
		br64_1  = 97,
		/// <summary>16-bit branch, 2-byte signed relative offset</summary>
		br16_2  = 98,
		/// <summary>32-bit branch, 4-byte signed relative offset</summary>
		br32_4  = 99,
		/// <summary>64-bit branch, 4-byte signed relative offset</summary>
		br64_4  = 100,
		/// <summary><c>XBEGIN</c>, 2-byte signed relative offset</summary>
		xbegin_2  = 101,
		/// <summary><c>XBEGIN</c>, 4-byte signed relative offset</summary>
		xbegin_4  = 102,
		/// <summary>2-byte branch offset (<c>JMPE</c> instruction)</summary>
		brdisp_2  = 103,
		/// <summary>4-byte branch offset (<c>JMPE</c> instruction)</summary>
		brdisp_4  = 104,
		/// <summary>Memory (modrm) and the sib byte must be present</summary>
		sibmem  = 105,
		/// <summary><c>TMM</c> register encoded in the <c>reg</c> field of the modrm byte</summary>
		tmm_reg  = 106,
		/// <summary><c>TMM</c> register encoded in the <c>mod + r/m</c> fields of the modrm byte</summary>
		tmm_rm  = 107,
		/// <summary><c>TMM</c> register encoded in the the <c>V&apos;vvvv</c> field (VEX/EVEX/XOP)</summary>
		tmm_vvvv  = 108,
	};
	constexpr int operator+(const OpCodeOperandKind& a, const OpCodeOperandKind& b) { return ((int)a + (int)b); }
	constexpr int operator+(const OpCodeOperandKind& a, const int& b) { return ((int)a + b); }
	constexpr int operator+(const int& a, const OpCodeOperandKind& b) { return (a + (int)b); }
	constexpr int operator-(const OpCodeOperandKind& a, const OpCodeOperandKind& b) { return ((int)a - (int)b); }
	constexpr int operator-(const OpCodeOperandKind& a, const int& b) { return ((int)a - b); }
	constexpr int operator-(const int& a, const OpCodeOperandKind& b) { return (a - (int)b); }
	constexpr OpCodeOperandKind operator++(OpCodeOperandKind& a, int) { auto temp = a; a = OpCodeOperandKind(a + 1); return temp; }
	constexpr OpCodeOperandKind& operator++(OpCodeOperandKind& a) { return a = OpCodeOperandKind(a + 1); }
	constexpr OpCodeOperandKind operator--(OpCodeOperandKind& a, int) { auto temp = a; a = OpCodeOperandKind(a - 1); return temp; }
	constexpr OpCodeOperandKind& operator--(OpCodeOperandKind& a) { return a = OpCodeOperandKind(a - 1); }
	constexpr bool operator==(const OpCodeOperandKind& a, const int& b) { return ((int)a == b); }
	constexpr bool operator==(const int& a, const OpCodeOperandKind& b) { return (a == (int)b); }
	constexpr bool operator>=(const OpCodeOperandKind& a, const int& b) { return ((int)a >= b); }
	constexpr bool operator>=(const int& a, const OpCodeOperandKind& b) { return (a >= (int)b); }
	constexpr bool operator<=(const OpCodeOperandKind& a, const int& b) { return ((int)a <= b); }
	constexpr bool operator<=(const int& a, const OpCodeOperandKind& b) { return (a <= (int)b); }
	constexpr bool operator>(const OpCodeOperandKind& a, const int& b) { return ((int)a > b); }
	constexpr bool operator>(const int& a, const OpCodeOperandKind& b) { return (a > (int)b); }
	constexpr bool operator<(const OpCodeOperandKind& a, const int& b) { return ((int)a < b); }
	constexpr bool operator<(const int& a, const OpCodeOperandKind& b) { return (a < (int)b); }
	constexpr bool operator!=(const OpCodeOperandKind& a, const int& b) { return ((int)a != b); }
	constexpr bool operator!=(const int& a, const OpCodeOperandKind& b) { return (a != (int)b); }
}
template <>
constexpr std::string Iced::Intel::ToString(const Iced::Intel::OpCodeOperandKind& e) {
	switch (e) {
		case Iced::Intel::OpCodeOperandKind::None: return "None";
		case Iced::Intel::OpCodeOperandKind::farbr2_2: return "farbr2_2";
		case Iced::Intel::OpCodeOperandKind::farbr4_2: return "farbr4_2";
		case Iced::Intel::OpCodeOperandKind::mem_offs: return "mem_offs";
		case Iced::Intel::OpCodeOperandKind::mem: return "mem";
		case Iced::Intel::OpCodeOperandKind::mem_mpx: return "mem_mpx";
		case Iced::Intel::OpCodeOperandKind::mem_mib: return "mem_mib";
		case Iced::Intel::OpCodeOperandKind::mem_vsib32x: return "mem_vsib32x";
		case Iced::Intel::OpCodeOperandKind::mem_vsib64x: return "mem_vsib64x";
		case Iced::Intel::OpCodeOperandKind::mem_vsib32y: return "mem_vsib32y";
		case Iced::Intel::OpCodeOperandKind::mem_vsib64y: return "mem_vsib64y";
		case Iced::Intel::OpCodeOperandKind::mem_vsib32z: return "mem_vsib32z";
		case Iced::Intel::OpCodeOperandKind::mem_vsib64z: return "mem_vsib64z";
		case Iced::Intel::OpCodeOperandKind::r8_or_mem: return "r8_or_mem";
		case Iced::Intel::OpCodeOperandKind::r16_or_mem: return "r16_or_mem";
		case Iced::Intel::OpCodeOperandKind::r32_or_mem: return "r32_or_mem";
		case Iced::Intel::OpCodeOperandKind::r32_or_mem_mpx: return "r32_or_mem_mpx";
		case Iced::Intel::OpCodeOperandKind::r64_or_mem: return "r64_or_mem";
		case Iced::Intel::OpCodeOperandKind::r64_or_mem_mpx: return "r64_or_mem_mpx";
		case Iced::Intel::OpCodeOperandKind::mm_or_mem: return "mm_or_mem";
		case Iced::Intel::OpCodeOperandKind::xmm_or_mem: return "xmm_or_mem";
		case Iced::Intel::OpCodeOperandKind::ymm_or_mem: return "ymm_or_mem";
		case Iced::Intel::OpCodeOperandKind::zmm_or_mem: return "zmm_or_mem";
		case Iced::Intel::OpCodeOperandKind::bnd_or_mem_mpx: return "bnd_or_mem_mpx";
		case Iced::Intel::OpCodeOperandKind::k_or_mem: return "k_or_mem";
		case Iced::Intel::OpCodeOperandKind::r8_reg: return "r8_reg";
		case Iced::Intel::OpCodeOperandKind::r8_opcode: return "r8_opcode";
		case Iced::Intel::OpCodeOperandKind::r16_reg: return "r16_reg";
		case Iced::Intel::OpCodeOperandKind::r16_reg_mem: return "r16_reg_mem";
		case Iced::Intel::OpCodeOperandKind::r16_rm: return "r16_rm";
		case Iced::Intel::OpCodeOperandKind::r16_opcode: return "r16_opcode";
		case Iced::Intel::OpCodeOperandKind::r32_reg: return "r32_reg";
		case Iced::Intel::OpCodeOperandKind::r32_reg_mem: return "r32_reg_mem";
		case Iced::Intel::OpCodeOperandKind::r32_rm: return "r32_rm";
		case Iced::Intel::OpCodeOperandKind::r32_opcode: return "r32_opcode";
		case Iced::Intel::OpCodeOperandKind::r32_vvvv: return "r32_vvvv";
		case Iced::Intel::OpCodeOperandKind::r64_reg: return "r64_reg";
		case Iced::Intel::OpCodeOperandKind::r64_reg_mem: return "r64_reg_mem";
		case Iced::Intel::OpCodeOperandKind::r64_rm: return "r64_rm";
		case Iced::Intel::OpCodeOperandKind::r64_opcode: return "r64_opcode";
		case Iced::Intel::OpCodeOperandKind::r64_vvvv: return "r64_vvvv";
		case Iced::Intel::OpCodeOperandKind::seg_reg: return "seg_reg";
		case Iced::Intel::OpCodeOperandKind::k_reg: return "k_reg";
		case Iced::Intel::OpCodeOperandKind::kp1_reg: return "kp1_reg";
		case Iced::Intel::OpCodeOperandKind::k_rm: return "k_rm";
		case Iced::Intel::OpCodeOperandKind::k_vvvv: return "k_vvvv";
		case Iced::Intel::OpCodeOperandKind::mm_reg: return "mm_reg";
		case Iced::Intel::OpCodeOperandKind::mm_rm: return "mm_rm";
		case Iced::Intel::OpCodeOperandKind::xmm_reg: return "xmm_reg";
		case Iced::Intel::OpCodeOperandKind::xmm_rm: return "xmm_rm";
		case Iced::Intel::OpCodeOperandKind::xmm_vvvv: return "xmm_vvvv";
		case Iced::Intel::OpCodeOperandKind::xmmp3_vvvv: return "xmmp3_vvvv";
		case Iced::Intel::OpCodeOperandKind::xmm_is4: return "xmm_is4";
		case Iced::Intel::OpCodeOperandKind::xmm_is5: return "xmm_is5";
		case Iced::Intel::OpCodeOperandKind::ymm_reg: return "ymm_reg";
		case Iced::Intel::OpCodeOperandKind::ymm_rm: return "ymm_rm";
		case Iced::Intel::OpCodeOperandKind::ymm_vvvv: return "ymm_vvvv";
		case Iced::Intel::OpCodeOperandKind::ymm_is4: return "ymm_is4";
		case Iced::Intel::OpCodeOperandKind::ymm_is5: return "ymm_is5";
		case Iced::Intel::OpCodeOperandKind::zmm_reg: return "zmm_reg";
		case Iced::Intel::OpCodeOperandKind::zmm_rm: return "zmm_rm";
		case Iced::Intel::OpCodeOperandKind::zmm_vvvv: return "zmm_vvvv";
		case Iced::Intel::OpCodeOperandKind::zmmp3_vvvv: return "zmmp3_vvvv";
		case Iced::Intel::OpCodeOperandKind::cr_reg: return "cr_reg";
		case Iced::Intel::OpCodeOperandKind::dr_reg: return "dr_reg";
		case Iced::Intel::OpCodeOperandKind::tr_reg: return "tr_reg";
		case Iced::Intel::OpCodeOperandKind::bnd_reg: return "bnd_reg";
		case Iced::Intel::OpCodeOperandKind::es: return "es";
		case Iced::Intel::OpCodeOperandKind::cs: return "cs";
		case Iced::Intel::OpCodeOperandKind::ss: return "ss";
		case Iced::Intel::OpCodeOperandKind::ds: return "ds";
		case Iced::Intel::OpCodeOperandKind::fs: return "fs";
		case Iced::Intel::OpCodeOperandKind::gs: return "gs";
		case Iced::Intel::OpCodeOperandKind::al: return "al";
		case Iced::Intel::OpCodeOperandKind::cl: return "cl";
		case Iced::Intel::OpCodeOperandKind::ax: return "ax";
		case Iced::Intel::OpCodeOperandKind::dx: return "dx";
		case Iced::Intel::OpCodeOperandKind::eax: return "eax";
		case Iced::Intel::OpCodeOperandKind::rax: return "rax";
		case Iced::Intel::OpCodeOperandKind::st0: return "st0";
		case Iced::Intel::OpCodeOperandKind::sti_opcode: return "sti_opcode";
		case Iced::Intel::OpCodeOperandKind::imm4_m2z: return "imm4_m2z";
		case Iced::Intel::OpCodeOperandKind::imm8: return "imm8";
		case Iced::Intel::OpCodeOperandKind::imm8_const_1: return "imm8_const_1";
		case Iced::Intel::OpCodeOperandKind::imm8sex16: return "imm8sex16";
		case Iced::Intel::OpCodeOperandKind::imm8sex32: return "imm8sex32";
		case Iced::Intel::OpCodeOperandKind::imm8sex64: return "imm8sex64";
		case Iced::Intel::OpCodeOperandKind::imm16: return "imm16";
		case Iced::Intel::OpCodeOperandKind::imm32: return "imm32";
		case Iced::Intel::OpCodeOperandKind::imm32sex64: return "imm32sex64";
		case Iced::Intel::OpCodeOperandKind::imm64: return "imm64";
		case Iced::Intel::OpCodeOperandKind::seg_rSI: return "seg_rSI";
		case Iced::Intel::OpCodeOperandKind::es_rDI: return "es_rDI";
		case Iced::Intel::OpCodeOperandKind::seg_rDI: return "seg_rDI";
		case Iced::Intel::OpCodeOperandKind::seg_rBX_al: return "seg_rBX_al";
		case Iced::Intel::OpCodeOperandKind::br16_1: return "br16_1";
		case Iced::Intel::OpCodeOperandKind::br32_1: return "br32_1";
		case Iced::Intel::OpCodeOperandKind::br64_1: return "br64_1";
		case Iced::Intel::OpCodeOperandKind::br16_2: return "br16_2";
		case Iced::Intel::OpCodeOperandKind::br32_4: return "br32_4";
		case Iced::Intel::OpCodeOperandKind::br64_4: return "br64_4";
		case Iced::Intel::OpCodeOperandKind::xbegin_2: return "xbegin_2";
		case Iced::Intel::OpCodeOperandKind::xbegin_4: return "xbegin_4";
		case Iced::Intel::OpCodeOperandKind::brdisp_2: return "brdisp_2";
		case Iced::Intel::OpCodeOperandKind::brdisp_4: return "brdisp_4";
		case Iced::Intel::OpCodeOperandKind::sibmem: return "sibmem";
		case Iced::Intel::OpCodeOperandKind::tmm_reg: return "tmm_reg";
		case Iced::Intel::OpCodeOperandKind::tmm_rm: return "tmm_rm";
		case Iced::Intel::OpCodeOperandKind::tmm_vvvv: return "tmm_vvvv";
		default: return Internal::StringHelpers::ToDec((int)e);
	}
}
#endif
