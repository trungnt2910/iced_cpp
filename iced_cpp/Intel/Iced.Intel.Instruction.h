// C# helper headers
#include <csharp/classes.h>
#include <csharp/enum.h>
#include <csharp/interfaces.h>
#include <csharp/primitives.h>

// Commonly used headers
#include <cstdint>
#include <format>
#include <functional>
#include <memory>
#include <stdexcept>
#include <string>
#include <vector>

#pragma once

#include "Code.g.h"
#include "OpKind.g.h"
#include "Instruction.Create.h"
#include "Register.g.h"
#include "MemoryOperand.h"
#include "CodeSize.g.h"
#include "Mnemonic.g.h"
#include "MvexRegMemConv.g.h"
#include "MemorySize.g.h"
#include "RoundingControl.g.h"
#include "OpCodeInfo.h"
#include "Instruction.Info.h"
#include "EncodingKind.g.h"
#include "CpuidFeature.g.h"
#include "FlowControl.g.h"
#include "InstructionInfoInternal/InfoHandlerFlags.h"
#include "RflagsBits.g.h"
#include "ConditionCode.g.h"
#include "Instruction.VA.h"
#include <string>
#include <vector>
#include <limits>
#include <stdexcept>
#include <any>
#include <format>
#include <csharp/exceptionhelper.h>
#include <cassert>

// Code generated from Iced. Do not edit.
// Commit tag: badb6147c0994a4954fa27645aba2b02c2bb9502.
// SPDX-License-Identifier: MIT
// Copyright (C) 2018-present iced project and contributors
namespace Iced::Intel
{
	// GENERATOR-BEGIN: RepPrefixKind
	// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	/// <summary><c>REP</c>/<c>REPE</c>/<c>REPNE</c> prefix</summary>
	 /// <summary>No <c>REP</c>/<c>REPE</c>/<c>REPNE</c> prefix</summary>
	 /// <summary><c>REP</c>/<c>REPE</c> prefix</summary>
	 /// <summary><c>REPNE</c> prefix</summary>

	DEFINE_COMP(RepPrefixKind)
		DEFINE_ARITH(RepPrefixKind)

		// GENERATOR-END: RepPrefixKind
		/// <summary>
		/// A 16/32/64-bit instruction. Created by Decoder or by Instruction.Create() methods.
		/// </summary>
		/// Contains the FPU <c>TOP</c> increment, whether it's conditional and whether the instruction writes to <c>TOP</c>
		 /// <summary>
		 /// Used if <see cref="WritesTop"/> is <see langword="true"/>:<br/>
		 /// <br/>
		 /// Value added to <c>TOP</c>.<br/>
		 /// This is negative if it pushes one or more values and positive if it pops one or more values
		 /// and <c>0</c> if it writes to <c>TOP</c> (eg. <c>FLDENV</c>, etc) without pushing/popping anything.
		 /// </summary>
		 /// <see langword="true"/> if it's a conditional push/pop (eg. <c>FPTAN</c> or <c>FSINCOS</c>)
		 /// <see langword="true"/> if <c>TOP</c> is written (it's a conditional/unconditional push/pop, <c>FNSAVE</c>, <c>FLDENV</c>, etc)
		 /// Constructor
		 /// <param name="increment"></param>
		 /// <param name="conditional"></param>
		 /// <param name="writesTop"></param>
		class Instruction : public IEquatable<Instruction>
	{
	private:
		static void InitializeSignedImmediate(Instruction& instruction, std::int32_t operand, std::int64_t immediate);
		static void InitializeUnsignedImmediate(Instruction& instruction, std::int32_t operand, std::uint64_t immediate);
		static OpKind GetImmediateOpKind(Iced::Intel::Code code, std::int32_t operand);
		static OpKind GetNearBranchOpKind(Iced::Intel::Code code, std::int32_t operand);
		static OpKind GetFarBranchOpKind(Iced::Intel::Code code, std::int32_t operand);
		static Instruction CreateString_Reg_SegRSI(Iced::Intel::Code code, std::int32_t addressSize, Register register_, Register segmentPrefix, RepPrefixKind repPrefix);
		static Instruction CreateString_Reg_ESRDI(Iced::Intel::Code code, std::int32_t addressSize, Register register_, RepPrefixKind repPrefix);
		static Instruction CreateString_ESRDI_Reg(Iced::Intel::Code code, std::int32_t addressSize, Register register_, RepPrefixKind repPrefix);
		static Instruction CreateString_SegRSI_ESRDI(Iced::Intel::Code code, std::int32_t addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
		static Instruction CreateString_ESRDI_SegRSI(Iced::Intel::Code code, std::int32_t addressSize, Register segmentPrefix, RepPrefixKind repPrefix);
		static Instruction CreateMaskmov(Iced::Intel::Code code, std::int32_t addressSize, Register register1, Register register2, Register segmentPrefix);
		static void InitMemoryOperand(Instruction& instruction, MemoryOperand const memory);
		// GENERATOR-BEGIN: Create
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
		/// <summary>
		/// Creates an instruction with no operands
		/// </summary>
		/// <param name="code">Code value</param>
	public:
		static Instruction Create(Iced::Intel::Code code);
		/// <summary>
		/// Creates an instruction with 1 operand
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		static Instruction Create(Iced::Intel::Code code, Register register_);
		/// <summary>
		/// Creates an instruction with 1 operand
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="immediate">op0: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 1 operand
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="immediate">op0: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 1 operand
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="memory">op0: Memory operand</param>
		static Instruction Create(Iced::Intel::Code code, MemoryOperand const memory);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		/// <param name="immediate">op1: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register_, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		/// <param name="immediate">op1: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register_, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		/// <param name="immediate">op1: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register_, std::int64_t immediate);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		/// <param name="immediate">op1: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register_, std::uint64_t immediate);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		/// <param name="memory">op1: Memory operand</param>
		static Instruction Create(Iced::Intel::Code code, Register register_, MemoryOperand const memory);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="immediate">op0: Immediate value</param>
		/// <param name="register">op1: Register</param>
		static Instruction Create(Iced::Intel::Code code, std::int32_t immediate, Register register_);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="immediate">op0: Immediate value</param>
		/// <param name="register">op1: Register</param>
		static Instruction Create(Iced::Intel::Code code, std::uint32_t immediate, Register register_);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="immediate1">op0: Immediate value</param>
		/// <param name="immediate2">op1: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, std::int32_t immediate1, std::int32_t immediate2);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="immediate1">op0: Immediate value</param>
		/// <param name="immediate2">op1: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, std::uint32_t immediate1, std::uint32_t immediate2);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="memory">op0: Memory operand</param>
		/// <param name="register">op1: Register</param>
		static Instruction Create(Iced::Intel::Code code, MemoryOperand const memory, Register register_);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="memory">op0: Memory operand</param>
		/// <param name="immediate">op1: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, MemoryOperand const memory, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 2 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="memory">op0: Memory operand</param>
		/// <param name="immediate">op1: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, MemoryOperand const memory, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="register3">op2: Register</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, Register register3);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="immediate">op2: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="immediate">op2: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="memory">op2: Memory operand</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, MemoryOperand const memory);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		/// <param name="immediate1">op1: Immediate value</param>
		/// <param name="immediate2">op2: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register_, std::int32_t immediate1, std::int32_t immediate2);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		/// <param name="immediate1">op1: Immediate value</param>
		/// <param name="immediate2">op2: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register_, std::uint32_t immediate1, std::uint32_t immediate2);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="memory">op1: Memory operand</param>
		/// <param name="register2">op2: Register</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, MemoryOperand const memory, Register register2);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		/// <param name="memory">op1: Memory operand</param>
		/// <param name="immediate">op2: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register_, MemoryOperand const memory, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register">op0: Register</param>
		/// <param name="memory">op1: Memory operand</param>
		/// <param name="immediate">op2: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register_, MemoryOperand const memory, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="memory">op0: Memory operand</param>
		/// <param name="register1">op1: Register</param>
		/// <param name="register2">op2: Register</param>
		static Instruction Create(Iced::Intel::Code code, MemoryOperand const memory, Register register1, Register register2);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="memory">op0: Memory operand</param>
		/// <param name="register">op1: Register</param>
		/// <param name="immediate">op2: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, MemoryOperand const memory, Register register_, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 3 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="memory">op0: Memory operand</param>
		/// <param name="register">op1: Register</param>
		/// <param name="immediate">op2: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, MemoryOperand const memory, Register register_, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 4 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="register3">op2: Register</param>
		/// <param name="register4">op3: Register</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, Register register3, Register register4);
		/// <summary>
		/// Creates an instruction with 4 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="register3">op2: Register</param>
		/// <param name="immediate">op3: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, Register register3, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 4 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="register3">op2: Register</param>
		/// <param name="immediate">op3: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, Register register3, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 4 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="register3">op2: Register</param>
		/// <param name="memory">op3: Memory operand</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, Register register3, MemoryOperand const memory);
		/// <summary>
		/// Creates an instruction with 4 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="immediate1">op2: Immediate value</param>
		/// <param name="immediate2">op3: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, std::int32_t immediate1, std::int32_t immediate2);
		/// <summary>
		/// Creates an instruction with 4 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="immediate1">op2: Immediate value</param>
		/// <param name="immediate2">op3: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, std::uint32_t immediate1, std::uint32_t immediate2);
		/// <summary>
		/// Creates an instruction with 4 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="memory">op2: Memory operand</param>
		/// <param name="register3">op3: Register</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, MemoryOperand const memory, Register register3);
		/// <summary>
		/// Creates an instruction with 4 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="memory">op2: Memory operand</param>
		/// <param name="immediate">op3: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, MemoryOperand const memory, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 4 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="memory">op2: Memory operand</param>
		/// <param name="immediate">op3: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, MemoryOperand const memory, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 5 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="register3">op2: Register</param>
		/// <param name="register4">op3: Register</param>
		/// <param name="immediate">op4: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, Register register3, Register register4, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 5 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="register3">op2: Register</param>
		/// <param name="register4">op3: Register</param>
		/// <param name="immediate">op4: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, Register register3, Register register4, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 5 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="register3">op2: Register</param>
		/// <param name="memory">op3: Memory operand</param>
		/// <param name="immediate">op4: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, Register register3, MemoryOperand const memory, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 5 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="register3">op2: Register</param>
		/// <param name="memory">op3: Memory operand</param>
		/// <param name="immediate">op4: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, Register register3, MemoryOperand const memory, std::uint32_t immediate);
		/// <summary>
		/// Creates an instruction with 5 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="memory">op2: Memory operand</param>
		/// <param name="register3">op3: Register</param>
		/// <param name="immediate">op4: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, MemoryOperand const memory, Register register3, std::int32_t immediate);
		/// <summary>
		/// Creates an instruction with 5 operands
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="register1">op0: Register</param>
		/// <param name="register2">op1: Register</param>
		/// <param name="memory">op2: Memory operand</param>
		/// <param name="register3">op3: Register</param>
		/// <param name="immediate">op4: Immediate value</param>
		static Instruction Create(Iced::Intel::Code code, Register register1, Register register2, MemoryOperand const memory, Register register3, std::uint32_t immediate);
		/// <summary>
		/// Creates a new near/short branch instruction
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="target">Target address</param>
		static Instruction CreateBranch(Iced::Intel::Code code, std::uint64_t target);
		/// <summary>
		/// Creates a new far branch instruction
		/// </summary>
		/// <param name="code">Code value</param>
		/// <param name="selector">Selector/segment value</param>
		/// <param name="offset">Offset</param>
		static Instruction CreateBranch(Iced::Intel::Code code, std::uint16_t selector, std::uint32_t offset);
		/// <summary>
		/// Creates a new <c>XBEGIN</c> instruction
		/// </summary>
		/// <param name="bitness">16, 32, or 64</param>
		/// <param name="target">Target address</param>
		static Instruction CreateXbegin(std::int32_t bitness, std::uint64_t target);
		/// <summary>
		/// Creates a <c>OUTSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateOutsb(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP OUTSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepOutsb(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>OUTSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateOutsw(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP OUTSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepOutsw(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>OUTSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateOutsd(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP OUTSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepOutsd(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>LODSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateLodsb(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP LODSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepLodsb(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>LODSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateLodsw(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP LODSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepLodsw(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>LODSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateLodsd(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP LODSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepLodsd(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>LODSQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateLodsq(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP LODSQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepLodsq(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>SCASB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateScasb(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REPE SCASB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepeScasb(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>REPNE SCASB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepneScasb(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>SCASW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateScasw(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REPE SCASW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepeScasw(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>REPNE SCASW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepneScasw(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>SCASD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateScasd(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REPE SCASD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepeScasd(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>REPNE SCASD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepneScasd(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>SCASQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateScasq(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REPE SCASQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepeScasq(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>REPNE SCASQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepneScasq(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>INSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateInsb(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP INSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepInsb(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>INSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateInsw(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP INSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepInsw(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>INSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateInsd(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP INSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepInsd(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>STOSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateStosb(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP STOSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepStosb(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>STOSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateStosw(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP STOSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepStosw(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>STOSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateStosd(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP STOSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepStosd(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>STOSQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateStosq(std::int32_t addressSize, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP STOSQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepStosq(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>CMPSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateCmpsb(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REPE CMPSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepeCmpsb(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>REPNE CMPSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepneCmpsb(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>CMPSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateCmpsw(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REPE CMPSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepeCmpsw(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>REPNE CMPSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepneCmpsw(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>CMPSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateCmpsd(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REPE CMPSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepeCmpsd(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>REPNE CMPSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepneCmpsd(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>CMPSQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateCmpsq(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REPE CMPSQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepeCmpsq(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>REPNE CMPSQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepneCmpsq(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>MOVSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateMovsb(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP MOVSB</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepMovsb(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>MOVSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateMovsw(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP MOVSW</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepMovsw(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>MOVSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateMovsd(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP MOVSD</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepMovsd(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>MOVSQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		/// <param name="repPrefix">Rep prefix or <see cref="RepPrefixKind.None"/></param>
		static Instruction CreateMovsq(std::int32_t addressSize, Register segmentPrefix = Register::None, RepPrefixKind repPrefix = RepPrefixKind::None);
		/// <summary>
		/// Creates a <c>REP MOVSQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		static Instruction CreateRepMovsq(std::int32_t addressSize);
		/// <summary>
		/// Creates a <c>MASKMOVQ</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="register1">Register</param>
		/// <param name="register2">Register</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		static Instruction CreateMaskmovq(std::int32_t addressSize, Register register1, Register register2, Register segmentPrefix = Register::None);
		/// <summary>
		/// Creates a <c>MASKMOVDQU</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="register1">Register</param>
		/// <param name="register2">Register</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		static Instruction CreateMaskmovdqu(std::int32_t addressSize, Register register1, Register register2, Register segmentPrefix = Register::None);
		/// <summary>
		/// Creates a <c>VMASKMOVDQU</c> instruction
		/// </summary>
		/// <param name="addressSize">16, 32, or 64</param>
		/// <param name="register1">Register</param>
		/// <param name="register2">Register</param>
		/// <param name="segmentPrefix">Segment override or <see cref="Register.None"/></param>
		static Instruction CreateVmaskmovdqu(std::int32_t addressSize, Register register1, Register register2, Register segmentPrefix = Register::None);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		static Instruction CreateDeclareByte(std::uint8_t b0);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		/// <param name="b7">Byte 7</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6, std::uint8_t b7);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		/// <param name="b7">Byte 7</param>
		/// <param name="b8">Byte 8</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6, std::uint8_t b7, std::uint8_t b8);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		/// <param name="b7">Byte 7</param>
		/// <param name="b8">Byte 8</param>
		/// <param name="b9">Byte 9</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6, std::uint8_t b7, std::uint8_t b8, std::uint8_t b9);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		/// <param name="b7">Byte 7</param>
		/// <param name="b8">Byte 8</param>
		/// <param name="b9">Byte 9</param>
		/// <param name="b10">Byte 10</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6, std::uint8_t b7, std::uint8_t b8, std::uint8_t b9, std::uint8_t b10);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		/// <param name="b7">Byte 7</param>
		/// <param name="b8">Byte 8</param>
		/// <param name="b9">Byte 9</param>
		/// <param name="b10">Byte 10</param>
		/// <param name="b11">Byte 11</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6, std::uint8_t b7, std::uint8_t b8, std::uint8_t b9, std::uint8_t b10, std::uint8_t b11);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		/// <param name="b7">Byte 7</param>
		/// <param name="b8">Byte 8</param>
		/// <param name="b9">Byte 9</param>
		/// <param name="b10">Byte 10</param>
		/// <param name="b11">Byte 11</param>
		/// <param name="b12">Byte 12</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6, std::uint8_t b7, std::uint8_t b8, std::uint8_t b9, std::uint8_t b10, std::uint8_t b11, std::uint8_t b12);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		/// <param name="b7">Byte 7</param>
		/// <param name="b8">Byte 8</param>
		/// <param name="b9">Byte 9</param>
		/// <param name="b10">Byte 10</param>
		/// <param name="b11">Byte 11</param>
		/// <param name="b12">Byte 12</param>
		/// <param name="b13">Byte 13</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6, std::uint8_t b7, std::uint8_t b8, std::uint8_t b9, std::uint8_t b10, std::uint8_t b11, std::uint8_t b12, std::uint8_t b13);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		/// <param name="b7">Byte 7</param>
		/// <param name="b8">Byte 8</param>
		/// <param name="b9">Byte 9</param>
		/// <param name="b10">Byte 10</param>
		/// <param name="b11">Byte 11</param>
		/// <param name="b12">Byte 12</param>
		/// <param name="b13">Byte 13</param>
		/// <param name="b14">Byte 14</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6, std::uint8_t b7, std::uint8_t b8, std::uint8_t b9, std::uint8_t b10, std::uint8_t b11, std::uint8_t b12, std::uint8_t b13, std::uint8_t b14);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="b0">Byte 0</param>
		/// <param name="b1">Byte 1</param>
		/// <param name="b2">Byte 2</param>
		/// <param name="b3">Byte 3</param>
		/// <param name="b4">Byte 4</param>
		/// <param name="b5">Byte 5</param>
		/// <param name="b6">Byte 6</param>
		/// <param name="b7">Byte 7</param>
		/// <param name="b8">Byte 8</param>
		/// <param name="b9">Byte 9</param>
		/// <param name="b10">Byte 10</param>
		/// <param name="b11">Byte 11</param>
		/// <param name="b12">Byte 12</param>
		/// <param name="b13">Byte 13</param>
		/// <param name="b14">Byte 14</param>
		/// <param name="b15">Byte 15</param>
		static Instruction CreateDeclareByte(std::uint8_t b0, std::uint8_t b1, std::uint8_t b2, std::uint8_t b3, std::uint8_t b4, std::uint8_t b5, std::uint8_t b6, std::uint8_t b7, std::uint8_t b8, std::uint8_t b9, std::uint8_t b10, std::uint8_t b11, std::uint8_t b12, std::uint8_t b13, std::uint8_t b14, std::uint8_t b15);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		static Instruction CreateDeclareByte(std::vector<std::uint8_t>& data);
		/// <summary>
		/// Creates a <c>db</c>/<c>.byte</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="index">Start index</param>
		/// <param name="length">Number of bytes</param>
		static Instruction CreateDeclareByte(std::vector<std::uint8_t>& data, std::int32_t index, std::int32_t length);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="w0">Word 0</param>
		static Instruction CreateDeclareWord(std::uint16_t w0);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="w0">Word 0</param>
		/// <param name="w1">Word 1</param>
		static Instruction CreateDeclareWord(std::uint16_t w0, std::uint16_t w1);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="w0">Word 0</param>
		/// <param name="w1">Word 1</param>
		/// <param name="w2">Word 2</param>
		static Instruction CreateDeclareWord(std::uint16_t w0, std::uint16_t w1, std::uint16_t w2);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="w0">Word 0</param>
		/// <param name="w1">Word 1</param>
		/// <param name="w2">Word 2</param>
		/// <param name="w3">Word 3</param>
		static Instruction CreateDeclareWord(std::uint16_t w0, std::uint16_t w1, std::uint16_t w2, std::uint16_t w3);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="w0">Word 0</param>
		/// <param name="w1">Word 1</param>
		/// <param name="w2">Word 2</param>
		/// <param name="w3">Word 3</param>
		/// <param name="w4">Word 4</param>
		static Instruction CreateDeclareWord(std::uint16_t w0, std::uint16_t w1, std::uint16_t w2, std::uint16_t w3, std::uint16_t w4);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="w0">Word 0</param>
		/// <param name="w1">Word 1</param>
		/// <param name="w2">Word 2</param>
		/// <param name="w3">Word 3</param>
		/// <param name="w4">Word 4</param>
		/// <param name="w5">Word 5</param>
		static Instruction CreateDeclareWord(std::uint16_t w0, std::uint16_t w1, std::uint16_t w2, std::uint16_t w3, std::uint16_t w4, std::uint16_t w5);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="w0">Word 0</param>
		/// <param name="w1">Word 1</param>
		/// <param name="w2">Word 2</param>
		/// <param name="w3">Word 3</param>
		/// <param name="w4">Word 4</param>
		/// <param name="w5">Word 5</param>
		/// <param name="w6">Word 6</param>
		static Instruction CreateDeclareWord(std::uint16_t w0, std::uint16_t w1, std::uint16_t w2, std::uint16_t w3, std::uint16_t w4, std::uint16_t w5, std::uint16_t w6);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="w0">Word 0</param>
		/// <param name="w1">Word 1</param>
		/// <param name="w2">Word 2</param>
		/// <param name="w3">Word 3</param>
		/// <param name="w4">Word 4</param>
		/// <param name="w5">Word 5</param>
		/// <param name="w6">Word 6</param>
		/// <param name="w7">Word 7</param>
		static Instruction CreateDeclareWord(std::uint16_t w0, std::uint16_t w1, std::uint16_t w2, std::uint16_t w3, std::uint16_t w4, std::uint16_t w5, std::uint16_t w6, std::uint16_t w7);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		static Instruction CreateDeclareWord(std::vector<std::uint8_t>& data);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="index">Start index</param>
		/// <param name="length">Number of bytes</param>
		static Instruction CreateDeclareWord(std::vector<std::uint8_t>& data, std::int32_t index, std::int32_t length);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		static Instruction CreateDeclareWord(std::vector<std::uint16_t>& data);
		/// <summary>
		/// Creates a <c>dw</c>/<c>.word</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="index">Start index</param>
		/// <param name="length">Number of elements</param>
		static Instruction CreateDeclareWord(std::vector<std::uint16_t>& data, std::int32_t index, std::int32_t length);
		/// <summary>
		/// Creates a <c>dd</c>/<c>.int</c> asm directive
		/// </summary>
		/// <param name="d0">Dword 0</param>
		static Instruction CreateDeclareDword(std::uint32_t d0);
		/// <summary>
		/// Creates a <c>dd</c>/<c>.int</c> asm directive
		/// </summary>
		/// <param name="d0">Dword 0</param>
		/// <param name="d1">Dword 1</param>
		static Instruction CreateDeclareDword(std::uint32_t d0, std::uint32_t d1);
		/// <summary>
		/// Creates a <c>dd</c>/<c>.int</c> asm directive
		/// </summary>
		/// <param name="d0">Dword 0</param>
		/// <param name="d1">Dword 1</param>
		/// <param name="d2">Dword 2</param>
		static Instruction CreateDeclareDword(std::uint32_t d0, std::uint32_t d1, std::uint32_t d2);
		/// <summary>
		/// Creates a <c>dd</c>/<c>.int</c> asm directive
		/// </summary>
		/// <param name="d0">Dword 0</param>
		/// <param name="d1">Dword 1</param>
		/// <param name="d2">Dword 2</param>
		/// <param name="d3">Dword 3</param>
		static Instruction CreateDeclareDword(std::uint32_t d0, std::uint32_t d1, std::uint32_t d2, std::uint32_t d3);
		/// <summary>
		/// Creates a <c>dd</c>/<c>.int</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		static Instruction CreateDeclareDword(std::vector<std::uint8_t>& data);
		/// <summary>
		/// Creates a <c>dd</c>/<c>.int</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="index">Start index</param>
		/// <param name="length">Number of bytes</param>
		static Instruction CreateDeclareDword(std::vector<std::uint8_t>& data, std::int32_t index, std::int32_t length);
		/// <summary>
		/// Creates a <c>dd</c>/<c>.int</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		static Instruction CreateDeclareDword(std::vector<std::uint32_t>& data);
		/// <summary>
		/// Creates a <c>dd</c>/<c>.int</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="index">Start index</param>
		/// <param name="length">Number of elements</param>
		static Instruction CreateDeclareDword(std::vector<std::uint32_t>& data, std::int32_t index, std::int32_t length);
		/// <summary>
		/// Creates a <c>dq</c>/<c>.quad</c> asm directive
		/// </summary>
		/// <param name="q0">Qword 0</param>
		static Instruction CreateDeclareQword(std::uint64_t q0);
		/// <summary>
		/// Creates a <c>dq</c>/<c>.quad</c> asm directive
		/// </summary>
		/// <param name="q0">Qword 0</param>
		/// <param name="q1">Qword 1</param>
		static Instruction CreateDeclareQword(std::uint64_t q0, std::uint64_t q1);
		/// <summary>
		/// Creates a <c>dq</c>/<c>.quad</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		static Instruction CreateDeclareQword(std::vector<std::uint8_t>& data);
		/// <summary>
		/// Creates a <c>dq</c>/<c>.quad</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="index">Start index</param>
		/// <param name="length">Number of bytes</param>
		static Instruction CreateDeclareQword(std::vector<std::uint8_t>& data, std::int32_t index, std::int32_t length);
		/// <summary>
		/// Creates a <c>dq</c>/<c>.quad</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		static Instruction CreateDeclareQword(std::vector<std::uint64_t>& data);
		/// <summary>
		/// Creates a <c>dq</c>/<c>.quad</c> asm directive
		/// </summary>
		/// <param name="data">Data</param>
		/// <param name="index">Start index</param>
		/// <param name="length">Number of elements</param>
		static Instruction CreateDeclareQword(std::vector<std::uint64_t>& data, std::int32_t index, std::int32_t length);
		// GENERATOR-END: Create


		// GENERATOR-BEGIN: InstrFlags1
		// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	private:
		enum class InstrFlags1 : int
		{
			SegmentPrefixMask = 0x00000007,
			SegmentPrefixShift = 0x00000005,
			DataLengthMask = 0x0000000F,
			DataLengthShift = 0x00000008,
			RoundingControlMask = 0x00000007,
			RoundingControlShift = 0x0000000C,
			OpMaskMask = 0x00000007,
			OpMaskShift = 0x0000000F,
			CodeSizeMask = 0x00000003,
			CodeSizeShift = 0x00000012,
			Broadcast = 0x04000000,
			SuppressAllExceptions = 0x08000000,
			ZeroingMasking = 0x10000000,
			RepePrefix = 0x20000000,
			RepnePrefix = 0x40000000,
			LockPrefix = 0x80000000,
			EqualsIgnoreMask = 0x000C0000
		};
		DEFINE_FLAGS(InstrFlags1)
			DEFINE_COMP(InstrFlags1)
			DEFINE_ARITH(InstrFlags1)

			// GENERATOR-END: InstrFlags1
			// GENERATOR-BEGIN: MvexInstrFlags
			// ‚ö†Ô∏èThis was generated by GENERATOR!ü¶π‚Äç‚ôÇÔ∏è
	private:
		enum class MvexInstrFlags : int
		{
			MvexRegMemConvShift = 0x00000010,
			MvexRegMemConvMask = 0x0000001F,
			EvictionHint = 0x80000000
		};
		DEFINE_FLAGS(MvexInstrFlags)
			DEFINE_COMP(MvexInstrFlags)
			DEFINE_ARITH(MvexInstrFlags)

			// GENERATOR-END: MvexInstrFlags
	public:
		static constexpr std::int32_t TOTAL_SIZE = 40;
		// Next RIP is only needed by RIP relative memory operands. Without this field the user would have
		// to pass this value to the formatter and encoder methods.
	private:
		std::uint64_t nextRip = 0;
		std::uint64_t memDispl = 0;
		std::uint32_t flags1 = 0; // InstrFlags1
		std::uint32_t immediate = 0;
		std::uint16_t code = 0;
		std::uint8_t memBaseReg = 0; // Register
		std::uint8_t memIndexReg = 0; // Register
		std::uint8_t reg0 = 0, reg1 = 0, reg2 = 0, reg3 = 0; // Register
		std::uint8_t opKind0 = 0, opKind1 = 0, opKind2 = 0, opKind3 = 0; // OpKind
		std::uint8_t scale = 0;
		std::uint8_t displSize = 0;
		std::uint8_t len = 0;
		std::uint8_t pad = 0;
	public:
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator ==(in Instruction left, in Instruction right)
		bool operator == (Instruction const right);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] public static bool operator !=(in Instruction left, in Instruction right)
		bool operator != (Instruction const right);
		/// <summary>
		/// Checks if this instance equals <paramref name="other"/>
		/// </summary>
		/// <param name="other">Other instruction</param>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] public bool Equals(in Instruction other)
		bool Equals(Instruction const other) override;
		/* readonly */
		bool IEquatable_Equals(Instruction other) override;
	private:
		static bool EqualsInternal(Instruction const a, Instruction const b);
		/// <summary>
		/// Gets the hash code
		/// </summary>
		/// <returns></returns>
	public:
		std::int32_t GetHashCode();
		/// <summary>
		/// Checks if this instance equals <paramref name="obj"/>
		/// </summary>
		/// <param name="obj">Other instruction</param>
		/// <returns></returns>
	  //C# TO C++ CONVERTER WARNING: Nullable reference types have no equivalent in C++:
	  //ORIGINAL LINE: public override bool Equals(Object? obj)
		bool Equals(std::any obj);
		/// <summary>
		/// Checks if two instructions are equal, comparing all bits, not ignoring anything
		/// </summary>
		/// <param name="a">Instruction #1</param>
		/// <param name="b">Instruction #2</param>
		/// <returns></returns>
		static bool EqualsAllBits(Instruction const a, Instruction const b);
		/// <summary>
		/// 16-bit IP of the instruction
		/// </summary>
		 /* readonly */
		std::uint16_t GetIP16() const;
		void SetIP16(std::uint16_t value);
		/// <summary>
		/// 32-bit IP of the instruction
		/// </summary>
		 /* readonly */
		std::uint32_t GetIP32() const;
		void SetIP32(std::uint32_t value);
		/// <summary>
		/// 64-bit IP of the instruction
		/// </summary>
		 /* readonly */
		std::uint64_t GetIP() const;
		void SetIP(std::uint64_t value);
		/// <summary>
		/// 16-bit IP of the next instruction
		/// </summary>
		 /* readonly */
		std::uint16_t GetNextIP16() const;
		void SetNextIP16(std::uint16_t value);
		/// <summary>
		/// 32-bit IP of the next instruction
		/// </summary>
		 /* readonly */
		std::uint32_t GetNextIP32() const;
		void SetNextIP32(std::uint32_t value);
		/// <summary>
		/// 64-bit IP of the next instruction
		/// </summary>
		 /* readonly */
		std::uint64_t GetNextIP() const;
		void SetNextIP(std::uint64_t value);
		/// <summary>
		/// Gets the code size when the instruction was decoded. This value is informational and can
		/// be used by a formatter.
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		Iced::Intel::CodeSize GetCodeSize() const;
		void SetCodeSize(Iced::Intel::CodeSize value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetInternalCodeSize(Iced::Intel::CodeSize value);
		/// <summary>
		/// Checks if it's an invalid instruction (<see cref="Code"/> == <see cref="Code.INVALID"/>)
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsInvalid() const;
		/// <summary>
		/// Instruction code, see also <see cref="Mnemonic"/>
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		Iced::Intel::Code GetCode() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetCode(Iced::Intel::Code value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetCodeNoCheck(Code code)
		void InternalSetCodeNoCheck(Iced::Intel::Code code);
		/// <summary>
		/// Gets the mnemonic, see also <see cref="Code"/>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		Iced::Intel::Mnemonic GetMnemonic() const;
		/// <summary>
		/// Gets the operand count. An instruction can have 0-5 operands.
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::int32_t GetOpCount() const;
		/// <summary>
		/// Gets the length of the instruction, 0-15 bytes. This is just informational. If you modify the instruction
		/// or create a new one, this property could return the wrong value.
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::int32_t GetLength() const;
		void SetLength(std::int32_t value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetInternalHasRepeOrRepnePrefix() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::uint32_t GetHasAnyOfLockRepRepnePrefix() const;
		/* readonly */
	private:
		bool IsXacquireInstr();
		/* readonly */
		bool IsXreleaseInstr();
		/// <summary>
		/// <see langword="true"/> if the instruction has the <c>XACQUIRE</c> prefix (<c>F2</c>)
		/// </summary>
	public:
		/* readonly */
	 //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	 //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasXacquirePrefix() const;
		void SetHasXacquirePrefix(bool value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetHasXacquirePrefix()
		void InternalSetHasXacquirePrefix();
		/// <summary>
		/// <see langword="true"/> if the instruction has the <c>XRELEASE</c> prefix (<c>F3</c>)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasXreleasePrefix() const;
		void SetHasXreleasePrefix(bool value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetHasXreleasePrefix()
		void InternalSetHasXreleasePrefix();
		/// <summary>
		/// <see langword="true"/> if the instruction has the <c>REPE</c> or <c>REP</c> prefix (<c>F3</c>)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasRepPrefix() const;
		void SetHasRepPrefix(bool value);
		/// <summary>
		/// <see langword="true"/> if the instruction has the <c>REPE</c> or <c>REP</c> prefix (<c>F3</c>)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasRepePrefix() const;
		void SetHasRepePrefix(bool value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetHasRepePrefix()
		void InternalSetHasRepePrefix();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalClearHasRepePrefix()
		void InternalClearHasRepePrefix();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalClearHasRepeRepnePrefix()
		void InternalClearHasRepeRepnePrefix();
		/// <summary>
		/// <see langword="true"/> if the instruction has the <c>REPNE</c> prefix (<c>F2</c>)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasRepnePrefix() const;
		void SetHasRepnePrefix(bool value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetHasRepnePrefix()
		void InternalSetHasRepnePrefix();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalClearHasRepnePrefix()
		void InternalClearHasRepnePrefix();
		/// <summary>
		/// <see langword="true"/> if the instruction has the <c>LOCK</c> prefix (<c>F0</c>)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasLockPrefix() const;
		void SetHasLockPrefix(bool value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetHasLockPrefix()
		void InternalSetHasLockPrefix();
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalClearHasLockPrefix()
		void InternalClearHasLockPrefix();
		/// <summary>
		/// Gets operand #0's kind if the operand exists (see <see cref="OpCount"/> and <see cref="GetOpKind(int)"/>)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		OpKind GetOp0Kind() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetOp0Kind(OpKind value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetInternalOp0IsNotRegOrOp1IsNotReg() const;
		/// <summary>
		/// Gets operand #1's kind if the operand exists (see <see cref="OpCount"/> and <see cref="GetOpKind(int)"/>)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		OpKind GetOp1Kind() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetOp1Kind(OpKind value);
		/// <summary>
		/// Gets operand #2's kind if the operand exists (see <see cref="OpCount"/> and <see cref="GetOpKind(int)"/>)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		OpKind GetOp2Kind() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetOp2Kind(OpKind value);
		/// <summary>
		/// Gets operand #3's kind if the operand exists (see <see cref="OpCount"/> and <see cref="GetOpKind(int)"/>)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		OpKind GetOp3Kind() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetOp3Kind(OpKind value);
		/// <summary>
		/// Gets operand #4's kind if the operand exists (see <see cref="OpCount"/> and <see cref="GetOpKind(int)"/>)
		/// </summary>
		 /* readonly */
		OpKind GetOp4Kind() const;
		void SetOp4Kind(OpKind value);
		/// <summary>
		/// Gets an operand's kind if it exists (see <see cref="OpCount"/>)
		/// </summary>
		/// <param name="operand">Operand number, 0-4</param>
		/// <returns></returns>
		OpKind GetOpKind(std::int32_t operand);
		/// <summary>
		/// Gets whether a specific operand's kind exists
		/// </summary>
		/// <param name="opKind">Operand kind</param>
		/// <returns></returns>
		bool HasOpKind(OpKind opKind);
		/// <summary>
		/// Sets an operand's kind
		/// </summary>
		/// <param name="operand">Operand number, 0-4</param>
		/// <param name="opKind">Operand kind</param>
		void SetOpKind(std::int32_t operand, OpKind opKind);
		/// <summary>
		/// Checks if the instruction has a segment override prefix, see <see cref="SegmentPrefix"/>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasSegmentPrefix() const;
		/// <summary>
		/// Gets the segment override prefix or <see cref="Register.None"/> if none. See also <see cref="MemorySegment"/>.
		/// Use this property if the operand has kind <see cref="OpKind.Memory"/>,
		/// <see cref="OpKind.MemorySegSI"/>, <see cref="OpKind.MemorySegESI"/>, <see cref="OpKind.MemorySegRSI"/>
		/// </summary>
		 /* readonly */
		Register GetSegmentPrefix() const;
		void SetSegmentPrefix(Register value);
		/// <summary>
		/// Gets the effective segment register used to reference the memory location.
		/// Use this property if the operand has kind <see cref="OpKind.Memory"/>,
		/// <see cref="OpKind.MemorySegSI"/>, <see cref="OpKind.MemorySegESI"/>, <see cref="OpKind.MemorySegRSI"/>
		/// </summary>
		Register GetMemorySegment() const;
		/// <summary>
		/// Gets the size of the memory displacement in bytes. Valid values are <c>0</c>, <c>1</c> (16/32/64-bit), <c>2</c> (16-bit), <c>4</c> (32-bit), <c>8</c> (64-bit).
		/// Note that the return value can be 1 and <see cref="MemoryDisplacement64"/> may still not fit in
		/// a signed byte if it's an EVEX/MVEX encoded instruction.
		/// Use this property if the operand has kind <see cref="OpKind.Memory"/>
		/// </summary>
		 /* readonly */
		std::int32_t GetMemoryDisplSize() const;
		void SetMemoryDisplSize(std::int32_t value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetMemoryDisplSize(uint scale)
		void InternalSetMemoryDisplSize(std::uint32_t scale);
		/// <summary>
		/// <see langword="true"/> if the data is broadcast (EVEX instructions only)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsBroadcast() const;
		void SetBroadcast(bool value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetIsBroadcast()
		void InternalSetIsBroadcast();
		/// <summary>
		/// <see langword="true"/> if the data is broadcast (EVEX instructions only)
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsMvexEvictionHint() const;
		void SetMvexEvictionHint(bool value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetIsMvexEvictionHint()
		void InternalSetIsMvexEvictionHint();
		/// <summary>
		/// (MVEX) Register/memory operand conversion function
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		Iced::Intel::MvexRegMemConv GetMvexRegMemConv() const;
		void SetMvexRegMemConv(Iced::Intel::MvexRegMemConv value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetMvexRegMemConv(MvexRegMemConv newValue)
		void InternalSetMvexRegMemConv(Iced::Intel::MvexRegMemConv newValue);
		/// <summary>
		/// Gets the size of the memory location that is referenced by the operand. See also <see cref="IsBroadcast"/>.
		/// Use this property if the operand has kind <see cref="OpKind.Memory"/>,
		/// <see cref="OpKind.MemorySegSI"/>, <see cref="OpKind.MemorySegESI"/>, <see cref="OpKind.MemorySegRSI"/>,
		/// <see cref="OpKind.MemoryESDI"/>, <see cref="OpKind.MemoryESEDI"/>, <see cref="OpKind.MemoryESRDI"/>
		/// </summary>
		Iced::Intel::MemorySize GetMemorySize() const;
		/// <summary>
		/// Gets the index register scale value, valid values are <c>*1</c>, <c>*2</c>, <c>*4</c>, <c>*8</c>. Use this property if the operand has kind <see cref="OpKind.Memory"/>
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::int32_t GetMemoryIndexScale() const;
		void SetMemoryIndexScale(std::int32_t value);
		/* readonly */
	 //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	 //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::int32_t GetInternalMemoryIndexScale() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetInternalMemoryIndexScale(std::int32_t value);
		/// <summary>
		/// Gets the memory operand's displacement or the 32-bit absolute address if it's
		/// an <c>EIP</c> or <c>RIP</c> relative memory operand.
		/// Use this property if the operand has kind <see cref="OpKind.Memory"/>
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::uint32_t GetMemoryDisplacement32() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetMemoryDisplacement32(std::uint32_t value);
		/// <summary>
		/// Gets the memory operand's displacement or the 64-bit absolute address if it's
		/// an <c>EIP</c> or <c>RIP</c> relative memory operand.
		/// Use this property if the operand has kind <see cref="OpKind.Memory"/>
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::uint64_t GetMemoryDisplacement64() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetMemoryDisplacement64(std::uint64_t value);
		/// <summary>
		/// Gets an operand's immediate value
		/// </summary>
		/// <param name="operand">Operand number, 0-4</param>
		/// <returns></returns>
		std::uint64_t GetImmediate(std::int32_t operand);
		/// <summary>
		/// Sets an operand's immediate value
		/// </summary>
		/// <param name="operand">Operand number, 0-4</param>
		/// <param name="immediate">New immediate</param>
		/// <returns></returns>
		void SetImmediate(std::int32_t operand, std::int32_t immediate);
		/// <summary>
		/// Sets an operand's immediate value
		/// </summary>
		/// <param name="operand">Operand number, 0-4</param>
		/// <param name="immediate">New immediate</param>
		/// <returns></returns>
		void SetImmediate(std::int32_t operand, std::uint32_t immediate);
		/// <summary>
		/// Sets an operand's immediate value
		/// </summary>
		/// <param name="operand">Operand number, 0-4</param>
		/// <param name="immediate">New immediate</param>
		/// <returns></returns>
		void SetImmediate(std::int32_t operand, std::int64_t immediate);
		/// <summary>
		/// Sets an operand's immediate value
		/// </summary>
		/// <param name="operand">Operand number, 0-4</param>
		/// <param name="immediate">New immediate</param>
		/// <returns></returns>
		void SetImmediate(std::int32_t operand, std::uint64_t immediate);
		/// <summary>
		/// Gets the operand's immediate value. Use this property if the operand has kind <see cref="OpKind.Immediate8"/>
		/// </summary>
		 /* readonly */
		std::uint8_t GetImmediate8() const;
		void SetImmediate8(std::uint8_t value);
		void SetInternalImmediate8(std::uint32_t value);
		/// <summary>
		/// Gets the operand's immediate value. Use this property if the operand has kind <see cref="OpKind.Immediate8_2nd"/>
		/// </summary>
		 /* readonly */
		std::uint8_t GetImmediate8_2nd() const;
		void SetImmediate8_2nd(std::uint8_t value);
		void SetInternalImmediate8_2nd(std::uint32_t value);
		/// <summary>
		/// Gets the operand's immediate value. Use this property if the operand has kind <see cref="OpKind.Immediate16"/>
		/// </summary>
		 /* readonly */
		std::uint16_t GetImmediate16() const;
		void SetImmediate16(std::uint16_t value);
		void SetInternalImmediate16(std::uint32_t value);
		/// <summary>
		/// Gets the operand's immediate value. Use this property if the operand has kind <see cref="OpKind.Immediate32"/>
		/// </summary>
		 /* readonly */
		std::uint32_t GetImmediate32() const;
		void SetImmediate32(std::uint32_t value);
		/// <summary>
		/// Gets the operand's immediate value. Use this property if the operand has kind <see cref="OpKind.Immediate64"/>
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::uint64_t GetImmediate64() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetImmediate64(std::uint64_t value);
		void SetInternalImmediate64Lo(std::uint32_t value);
		void SetInternalImmediate64Hi(std::uint32_t value);
		/// <summary>
		/// Gets the operand's immediate value. Use this property if the operand has kind <see cref="OpKind.Immediate8to16"/>
		/// </summary>
		 /* readonly */
		std::int16_t GetImmediate8to16() const;
		void SetImmediate8to16(std::int16_t value);
		/// <summary>
		/// Gets the operand's immediate value. Use this property if the operand has kind <see cref="OpKind.Immediate8to32"/>
		/// </summary>
		 /* readonly */
		std::int32_t GetImmediate8to32() const;
		void SetImmediate8to32(std::int32_t value);
		/// <summary>
		/// Gets the operand's immediate value. Use this property if the operand has kind <see cref="OpKind.Immediate8to64"/>
		/// </summary>
		 /* readonly */
		std::int64_t GetImmediate8to64() const;
		void SetImmediate8to64(std::int64_t value);
		/// <summary>
		/// Gets the operand's immediate value. Use this property if the operand has kind <see cref="OpKind.Immediate32to64"/>
		/// </summary>
		 /* readonly */
		std::int64_t GetImmediate32to64() const;
		void SetImmediate32to64(std::int64_t value);
		/// <summary>
		/// Gets the operand's branch target. Use this property if the operand has kind <see cref="OpKind.NearBranch16"/>
		/// </summary>
		 /* readonly */
		std::uint16_t GetNearBranch16() const;
		void SetNearBranch16(std::uint16_t value);
		void SetInternalNearBranch16(std::uint32_t value);
		/// <summary>
		/// Gets the operand's branch target. Use this property if the operand has kind <see cref="OpKind.NearBranch32"/>
		/// </summary>
		 /* readonly */
		std::uint32_t GetNearBranch32() const;
		void SetNearBranch32(std::uint32_t value);
		/// <summary>
		/// Gets the operand's branch target. Use this property if the operand has kind <see cref="OpKind.NearBranch64"/>
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::uint64_t GetNearBranch64() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetNearBranch64(std::uint64_t value);
		/// <summary>
		/// Gets the near branch target if it's a <c>CALL</c>/<c>JMP</c>/<c>Jcc</c> near branch instruction
		/// (i.e., if <see cref="Op0Kind"/> is <see cref="OpKind.NearBranch16"/>, <see cref="OpKind.NearBranch32"/> or <see cref="OpKind.NearBranch64"/>)
		/// </summary>
		std::uint64_t GetNearBranchTarget() const;
		/// <summary>
		/// Gets the operand's branch target. Use this property if the operand has kind <see cref="OpKind.FarBranch16"/>
		/// </summary>
		 /* readonly */
		std::uint16_t GetFarBranch16() const;
		void SetFarBranch16(std::uint16_t value);
		void SetInternalFarBranch16(std::uint32_t value);
		/// <summary>
		/// Gets the operand's branch target. Use this property if the operand has kind <see cref="OpKind.FarBranch32"/>
		/// </summary>
		 /* readonly */
		std::uint32_t GetFarBranch32() const;
		void SetFarBranch32(std::uint32_t value);
		/// <summary>
		/// Gets the operand's branch target selector. Use this property if the operand has kind <see cref="OpKind.FarBranch16"/> or <see cref="OpKind.FarBranch32"/>
		/// </summary>
		 /* readonly */
		std::uint16_t GetFarBranchSelector() const;
		void SetFarBranchSelector(std::uint16_t value);
		void SetInternalFarBranchSelector(std::uint32_t value);
		/// <summary>
		/// Gets the memory operand's base register or <see cref="Register.None"/> if none. Use this property if the operand has kind <see cref="OpKind.Memory"/>
		/// </summary>
		 /* readonly */
		Register GetMemoryBase() const;
		void SetMemoryBase(Register value);
		void SetInternalMemoryBase(Register value);
		/// <summary>
		/// Gets the memory operand's index register or <see cref="Register.None"/> if none. Use this property if the operand has kind <see cref="OpKind.Memory"/>
		/// </summary>
		 /* readonly */
		Register GetMemoryIndex() const;
		void SetMemoryIndex(Register value);
		void SetInternalMemoryIndex(Register value);
		/// <summary>
		/// Gets operand #0's register value. Use this property if operand #0 (<see cref="Op0Kind"/>) has kind <see cref="OpKind.Register"/>, see <see cref="OpCount"/> and <see cref="GetOpRegister(int)"/>
		/// </summary>
		 /* readonly */
		Register GetOp0Register() const;
		void SetOp0Register(Register value);
		void SetInternalOp0Register(Register value);
		/// <summary>
		/// Gets operand #1's register value. Use this property if operand #1 (<see cref="Op1Kind"/>) has kind <see cref="OpKind.Register"/>, see <see cref="OpCount"/> and <see cref="GetOpRegister(int)"/>
		/// </summary>
		 /* readonly */
		Register GetOp1Register() const;
		void SetOp1Register(Register value);
		void SetInternalOp1Register(Register value);
		/// <summary>
		/// Gets operand #2's register value. Use this property if operand #2 (<see cref="Op2Kind"/>) has kind <see cref="OpKind.Register"/>, see <see cref="OpCount"/> and <see cref="GetOpRegister(int)"/>
		/// </summary>
		 /* readonly */
		Register GetOp2Register() const;
		void SetOp2Register(Register value);
		void SetInternalOp2Register(Register value);
		/// <summary>
		/// Gets operand #3's register value. Use this property if operand #3 (<see cref="Op3Kind"/>) has kind <see cref="OpKind.Register"/>, see <see cref="OpCount"/> and <see cref="GetOpRegister(int)"/>
		/// </summary>
		 /* readonly */
		Register GetOp3Register() const;
		void SetOp3Register(Register value);
		void SetInternalOp3Register(Register value);
		/// <summary>
		/// Gets operand #4's register value. Use this property if operand #4 (<see cref="Op4Kind"/>) has kind <see cref="OpKind.Register"/>, see <see cref="OpCount"/> and <see cref="GetOpRegister(int)"/>
		/// </summary>
		 /* readonly */
		Register GetOp4Register() const;
		void SetOp4Register(Register value);
		/// <summary>
		/// Gets the operand's register value. Use this property if the operand has kind <see cref="OpKind.Register"/>
		/// </summary>
		/// <param name="operand">Operand number, 0-4</param>
		/// <returns></returns>
		Register GetOpRegister(std::int32_t operand);
		/// <summary>
		/// Sets the operand's register value. Use this property if the operand has kind <see cref="OpKind.Register"/>
		/// </summary>
		/// <param name="operand">Operand number, 0-4</param>
		/// <param name="register">Register</param>
		void SetOpRegister(std::int32_t operand, Register register_);
		/// <summary>
		/// Gets the opmask register (<see cref="Register.K1"/> - <see cref="Register.K7"/>) or <see cref="Register.None"/> if none
		/// </summary>
		 /* readonly */
		Register GetOpMask() const;
		void SetOpMask(Register value);
		/* readonly */
	 //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	 //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::uint32_t GetInternalOpMask() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetInternalOpMask(std::uint32_t value);
		/// <summary>
		/// <see langword="true"/> if there's an opmask register (<see cref="OpMask"/>)
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasOpMask() const;
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasOpMaskOrZeroingMasking() const;
		/// <summary>
		/// <see langword="true"/> if zeroing-masking, <see langword="false"/> if merging-masking.
		/// Only used by most EVEX encoded instructions that use opmask registers.
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetZeroingMasking() const;
		void SetZeroingMasking(bool value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetZeroingMasking()
		void InternalSetZeroingMasking();
		/// <summary>
		/// <see langword="true"/> if merging-masking, <see langword="false"/> if zeroing-masking.
		/// Only used by most EVEX encoded instructions that use opmask registers.
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetMergingMasking() const;
		void SetMergingMasking(bool value);
		/// <summary>
		/// Rounding control (SAE is implied but <see cref="SuppressAllExceptions"/> still returns <see langword="false"/>)
		/// or <see cref="RoundingControl.None"/> if the instruction doesn't use it.
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		Iced::Intel::RoundingControl GetRoundingControl() const;
		void SetRoundingControl(Iced::Intel::RoundingControl value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetInternalRoundingControl(std::uint32_t value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetHasRoundingControlOrSae() const;
		/// <summary>
		/// Number of elements in a db/dw/dd/dq directive: <c>db</c>: 1-16; <c>dw</c>: 1-8; <c>dd</c>: 1-4; <c>dq</c>: 1-2.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareByte"/>, <see cref="Code.DeclareWord"/>, <see cref="Code.DeclareDword"/>, <see cref="Code.DeclareQword"/>
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		std::int32_t GetDeclareDataCount() const;
		void SetDeclareDataCount(std::int32_t value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] set
		void SetInternalDeclareDataCount(std::uint32_t value);
		/// <summary>
		/// Sets a new 'db' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareByte"/>
		/// </summary>
		/// <param name="index">Index (0-15)</param>
		/// <param name="value">New value</param>
		void SetDeclareByteValue(std::int32_t index, std::int8_t value);
		/// <summary>
		/// Sets a new 'db' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareByte"/>
		/// </summary>
		/// <param name="index">Index (0-15)</param>
		/// <param name="value">New value</param>
		void SetDeclareByteValue(std::int32_t index, std::uint8_t value);
		/// <summary>
		/// Gets a 'db' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareByte"/>
		/// </summary>
		/// <param name="index">Index (0-15)</param>
		/// <returns></returns>
		std::uint8_t GetDeclareByteValue(std::int32_t index);
		/// <summary>
		/// Sets a new 'dw' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareWord"/>
		/// </summary>
		/// <param name="index">Index (0-7)</param>
		/// <param name="value">New value</param>
		void SetDeclareWordValue(std::int32_t index, std::int16_t value);
		/// <summary>
		/// Sets a new 'dw' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareWord"/>
		/// </summary>
		/// <param name="index">Index (0-7)</param>
		/// <param name="value">New value</param>
		void SetDeclareWordValue(std::int32_t index, std::uint16_t value);
		/// <summary>
		/// Gets a 'dw' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareWord"/>
		/// </summary>
		/// <param name="index">Index (0-7)</param>
		/// <returns></returns>
		std::uint16_t GetDeclareWordValue(std::int32_t index);
		/// <summary>
		/// Sets a new 'dd' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareDword"/>
		/// </summary>
		/// <param name="index">Index (0-3)</param>
		/// <param name="value">New value</param>
		void SetDeclareDwordValue(std::int32_t index, std::int32_t value);
		/// <summary>
		/// Sets a new 'dd' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareDword"/>
		/// </summary>
		/// <param name="index">Index (0-3)</param>
		/// <param name="value">New value</param>
		void SetDeclareDwordValue(std::int32_t index, std::uint32_t value);
		/// <summary>
		/// Gets a 'dd' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareDword"/>
		/// </summary>
		/// <param name="index">Index (0-3)</param>
		/// <returns></returns>
		std::uint32_t GetDeclareDwordValue(std::int32_t index);
		/// <summary>
		/// Sets a new 'dq' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareQword"/>
		/// </summary>
		/// <param name="index">Index (0-1)</param>
		/// <param name="value">New value</param>
		void SetDeclareQwordValue(std::int32_t index, std::int64_t value);
		/// <summary>
		/// Sets a new 'dq' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareQword"/>
		/// </summary>
		/// <param name="index">Index (0-1)</param>
		/// <param name="value">New value</param>
		void SetDeclareQwordValue(std::int32_t index, std::uint64_t value);
		/// <summary>
		/// Gets a 'dq' value, see also <see cref="DeclareDataCount"/>.
		/// Can only be called if <see cref="Code"/> is <see cref="Code.DeclareQword"/>
		/// </summary>
		/// <param name="index">Index (0-1)</param>
		/// <returns></returns>
		std::uint64_t GetDeclareQwordValue(std::int32_t index);
		/// <summary>
		/// Checks if this is a VSIB instruction, see also <see cref="IsVsib32"/>, <see cref="IsVsib64"/>
		/// </summary>
		bool IsVsib() const;
		/// <summary>
		/// VSIB instructions only (<see cref="IsVsib"/>): <see langword="true"/> if it's using 32-bit indexes, <see langword="false"/> if it's using 64-bit indexes
		/// </summary>
		bool IsVsib32() const;
		/// <summary>
		/// VSIB instructions only (<see cref="IsVsib"/>): <see langword="true"/> if it's using 64-bit indexes, <see langword="false"/> if it's using 32-bit indexes
		/// </summary>
		bool IsVsib64() const;
		/// <summary>
		/// Checks if it's a VSIB instruction. If it's a VSIB instruction, it sets <paramref name="vsib64"/> to <see langword="true"/> if it's
		/// a VSIB instruction with 64-bit indexes, and clears it if it's using 32-bit indexes.
		/// </summary>
		/// <param name="vsib64">If it's a VSIB instruction, set to <see langword="true"/> if it's using 64-bit indexes, set to <see langword="false"/> if it's using 32-bit indexes</param>
		/// <returns></returns>
		bool TryGetVsib64(bool& vsib64);
		/// <summary>
		/// Suppress all exceptions (EVEX/MVEX encoded instructions). Note that if <see cref="RoundingControl"/> is
		/// not <see cref="RoundingControl.None"/>, SAE is implied but this property will still return <see langword="false"/>.
		/// </summary>
		 /* readonly */
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool GetSuppressAllExceptions() const;
		void SetSuppressAllExceptions(bool value);
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] internal void InternalSetSuppressAllExceptions()
		void InternalSetSuppressAllExceptions();
		/// <summary>
		/// Checks if the memory operand is RIP/EIP relative
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsIPRelativeMemoryOperand() const;
		/// <summary>
		/// Gets the <c>RIP</c>/<c>EIP</c> releative address (<see cref="MemoryDisplacement32"/> or <see cref="MemoryDisplacement64"/>).
		/// This property is only valid if there's a memory operand with <c>RIP</c>/<c>EIP</c> relative addressing, see <see cref="IsIPRelativeMemoryOperand"/>
		/// </summary>
		std::uint64_t GetIPRelativeMemoryAddress() const;
		/// <summary>
		/// Gets the <see cref="OpCodeInfo"/>
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		OpCodeInfo* GetOpCode() const;
		/// <summary>
		/// Formats the instruction using the default formatter with default formatter options
		/// </summary>
		/// <returns></returns>
		std::string ToString();


		/// <summary>
		/// Gets the number of bytes added to <c>SP</c>/<c>ESP</c>/<c>RSP</c> or 0 if it's not an instruction that pushes or pops data. This method assumes
		/// the instruction doesn't change the privilege level (eg. <c>IRET/D/Q</c>). If it's the <c>LEAVE</c> instruction, this method returns 0.
		/// </summary>
		/// <returns></returns>
		std::int32_t GetStackPointerIncrement() const;
		/// <summary>
		/// Gets the FPU status word's <c>TOP</c> increment and whether it's a conditional or unconditional push/pop
		/// and whether <c>TOP</c> is written.
		/// </summary>
		/// <returns></returns>
		FpuStackIncrementInfo GetFpuStackIncrementInfo();
		/// <summary>
		/// Instruction encoding, eg. Legacy, 3DNow!, VEX, EVEX, XOP
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		EncodingKind GetEncoding() const;
		/// <summary>
		/// Gets the CPU or CPUID feature flags
		/// </summary>
		std::vector<CpuidFeature> GetCpuidFeatures() const;
		/// <summary>
		/// Control flow info
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		Iced::Intel::FlowControl GetFlowControl() const;
		/// <summary>
		/// <see langword="true"/> if it's a privileged instruction (all CPL=0 instructions (except <c>VMCALL</c>) and IOPL instructions <c>IN</c>, <c>INS</c>, <c>OUT</c>, <c>OUTS</c>, <c>CLI</c>, <c>STI</c>)
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsPrivileged() const;
		/// <summary>
		/// <see langword="true"/> if this is an instruction that implicitly uses the stack pointer (<c>SP</c>/<c>ESP</c>/<c>RSP</c>), eg. <c>CALL</c>, <c>PUSH</c>, <c>POP</c>, <c>RET</c>, etc.
		/// See also <see cref="StackPointerIncrement"/>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsStackInstruction() const;
		/// <summary>
		/// <see langword="true"/> if it's an instruction that saves or restores too many registers (eg. <c>FXRSTOR</c>, <c>XSAVE</c>, etc).
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsSaveRestoreInstruction() const;
		/* readonly */
	private:
		InstructionInfoInternal::RflagsInfo GetRflagsInfo();
		/// <summary>
		/// All flags that are read by the CPU when executing the instruction. See also <see cref="RflagsModified"/>
		/// </summary>
	public:
		//C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
		//ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		RflagsBits GetRflagsRead() const;
		/// <summary>
		/// All flags that are written by the CPU, except those flags that are known to be undefined, always set or always cleared. See also <see cref="RflagsModified"/>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		RflagsBits GetRflagsWritten() const;
		/// <summary>
		/// All flags that are always cleared by the CPU. See also <see cref="RflagsModified"/>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		RflagsBits GetRflagsCleared() const;
		/// <summary>
		/// All flags that are always set by the CPU. See also <see cref="RflagsModified"/>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		RflagsBits GetRflagsSet() const;
		/// <summary>
		/// All flags that are undefined after executing the instruction. See also <see cref="RflagsModified"/>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		RflagsBits GetRflagsUndefined() const;
		/// <summary>
		/// All flags that are modified by the CPU. This is <see cref="RflagsWritten"/> + <see cref="RflagsCleared"/> + <see cref="RflagsSet"/> + <see cref="RflagsUndefined"/>
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		RflagsBits GetRflagsModified() const;
		/// <summary>
		/// Checks if it's a <c>Jcc SHORT</c> or <c>Jcc NEAR</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJccShortOrNear() const;
		/// <summary>
		/// Checks if it's a <c>Jcc NEAR</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJccNear() const;
		/// <summary>
		/// Checks if it's a <c>Jcxz SHORT</c>, <c>Jecxz SHORT</c> or <c>Jrcxz SHORT</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJcxShort() const;
		/// <summary>
		/// Checks if it's a <c>Jcc SHORT</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJccShort() const;
		/// <summary>
		/// Checks if it's a <c>JMP SHORT</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJmpShort() const;
		/// <summary>
		/// Checks if it's a <c>JMP NEAR</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJmpNear() const;
		/// <summary>
		/// Checks if it's a <c>JMP SHORT</c> or a <c>JMP NEAR</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJmpShortOrNear() const;
		/// <summary>
		/// Checks if it's a <c>JMP FAR</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJmpFar() const;
		/// <summary>
		/// Checks if it's a <c>CALL NEAR</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsCallNear() const;
		/// <summary>
		/// Checks if it's a <c>CALL FAR</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsCallFar() const;
		/// <summary>
		/// Checks if it's a <c>JMP NEAR reg/[mem]</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJmpNearIndirect() const;
		/// <summary>
		/// Checks if it's a <c>JMP FAR [mem]</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJmpFarIndirect() const;
		/// <summary>
		/// Checks if it's a <c>CALL NEAR reg/[mem]</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsCallNearIndirect() const;
		/// <summary>
		/// Checks if it's a <c>CALL FAR [mem]</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsCallFarIndirect() const;
		/// <summary>
		/// Checks if it's a <c>LOOPcc SHORT</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsLoopcc() const;
		/// <summary>
		/// Checks if it's a <c>LOOP SHORT</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsLoop() const;
		/// <summary>
		/// Checks if it's a <c>JKccD SHORT</c> or <c>JKccD NEAR</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJkccShortOrNear() const;
		/// <summary>
		/// Checks if it's a <c>JKccD NEAR</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJkccNear() const;
		/// <summary>
		/// Checks if it's a <c>JKccD SHORT</c> instruction
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsJkccShort() const;
		/// <summary>
		/// Negates the condition code, eg. <c>JE</c> -> <c>JNE</c>. Can be used if it's <c>Jcc</c>, <c>SETcc</c>, <c>CMOVcc</c>, <c>LOOPcc</c>
		/// and does nothing if the instruction doesn't have a condition code.
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] public void NegateConditionCode()
		void NegateConditionCode();
		/// <summary>
		/// Converts <c>Jcc/JMP NEAR</c> to <c>Jcc/JMP SHORT</c> and does nothing if it's not a <c>Jcc/JMP NEAR</c> instruction
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] public void ToShortBranch()
		void ToShortBranch();
		/// <summary>
		/// Converts <c>Jcc/JMP SHORT</c> to <c>Jcc/JMP NEAR</c> and does nothing if it's not a <c>Jcc/JMP SHORT</c> instruction
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] public void ToNearBranch()
		void ToNearBranch();
		/// <summary>
		/// Gets the condition code if it's <c>Jcc</c>, <c>SETcc</c>, <c>CMOVcc</c>, <c>LOOPcc</c> else <see cref="ConditionCode.None"/> is returned
		/// </summary>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		Iced::Intel::ConditionCode GetConditionCode() const;
		/// <summary>
		/// Checks if it's a string instruction such as <c>MOVS</c>, <c>LODS</c>, <c>STOS</c>, etc.
		/// </summary>
		/// <returns></returns>
	  //C# TO C++ CONVERTER NOTE: The following .NET attribute has no direct equivalent in C++:
	  //ORIGINAL LINE: [MethodImpl(MethodImplOptions.AggressiveInlining)] get
		bool IsStringInstruction() const;


		/// <summary>
		/// Gets the virtual address of a memory operand
		/// </summary>
		/// <param name="operand">Operand number, must be a memory operand</param>
		/// <param name="elementIndex">Only used if it's a vsib memory operand. This is the element index of the vector index register.</param>
		/// <param name="getRegisterValue">Delegate that returns the value of a register or the base address of a segment register</param>
		/// <returns></returns>
		std::uint64_t GetVirtualAddress(std::int32_t operand, std::int32_t elementIndex, VAGetRegisterValue getRegisterValue);
		/// <summary>
		/// Gets the virtual address of a memory operand
		/// </summary>
		/// <param name="operand">Operand number, must be a memory operand</param>
		/// <param name="elementIndex">Only used if it's a vsib memory operand. This is the element index of the vector index register.</param>
		/// <param name="registerValueProvider">Returns values of registers and segment base addresses</param>
		/// <returns></returns>
		std::uint64_t GetVirtualAddress(std::int32_t operand, std::int32_t elementIndex, IVARegisterValueProvider* registerValueProvider);
		/// <summary>
		/// Gets the virtual address of a memory operand
		/// </summary>
		/// <param name="operand">Operand number, must be a memory operand</param>
		/// <param name="elementIndex">Only used if it's a vsib memory operand. This is the element index of the vector index register.</param>
		/// <param name="result">Result if this method returns <see langword="true"/></param>
		/// <param name="getRegisterValue">Returns values of registers and segment base addresses</param>
		/// <returns></returns>
		bool TryGetVirtualAddress(std::int32_t operand, std::int32_t elementIndex, std::uint64_t& result, VATryGetRegisterValue getRegisterValue);
		/// <summary>
		/// Gets the virtual address of a memory operand
		/// </summary>
		/// <param name="operand">Operand number, must be a memory operand</param>
		/// <param name="elementIndex">Only used if it's a vsib memory operand. This is the element index of the vector index register.</param>
		/// <param name="registerValueProvider">Returns values of registers and segment base addresses</param>
		/// <param name="result">Result if this method returns <see langword="true"/></param>
		/// <returns></returns>
		bool TryGetVirtualAddress(std::int32_t operand, std::int32_t elementIndex, IVATryGetRegisterValueProvider* registerValueProvider, std::uint64_t& result);
	};
}
